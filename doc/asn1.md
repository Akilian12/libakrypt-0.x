# Форматы хранения контента с использованием ASN.1 кодирования

Для локального хранения данных и, при необходимости, передачи данных по каналам связи
в библиотеке поддерживается единый формат хранения контента, основанный на использовании ASN.1 кодирования
данных. Данный формат основан на методических рекомендациях Р 50.1.110-2016, Р 1322565.1.023-2018 и Р 1323565.1. (рекомендации по CMS),
однако, за исключением формата сертификатов открытых ключей, с ними не совместим.

Далее под контентом понимаются следующие сущности:

 1. Симметричные ключи алгоритмов шифрования и имитозащиты (`SymmetricKey`).
 2. Секретные ключи асимметричных алгоритмов шифрования (`SecretKey`).
 3. Открытые ключи асимметричных алгоритмов шифрования (`PublicKey`).
 4. Произвольные, как правило двоичные, данные, для которых требуется шифрование и имитозащита (`EncryptedContent`).
 5. Произвольные, как правило двоичные, данные, для которых требуется только имитозащита (`PlainContent`).

В ASN.1 нотации допустимый тип контента описывается следующим образом.


    ContentType ::= INTEGER (0..255) -- допустимые значения контента:
                                        --  0  -  симметричный ключ
                                        --  1  -  секретный ключ
                                        --  2  -  открытый ключ
                                        --  3  -  произвольные двоичные зашифрованные данные
                                        --  4  -  произвольные двоичные открытые данные


Контент помещается в контейнер - отформатированную последовательность октетов,
которая может быть сохранена в виде файла или передана по каналам связи.
Вместе с контентом в контейнер помещается, при необходимости, дополнительная мета-информация.

Помещаемые в контейнер данные могут быть зашифрованы, а также снабжены кодом целостности --
имитовставкой или электронной подписью.
Выбор криптографических механизмов, используемых для шифрования и имитозащиты данных, зависит от типа контента `ContentType`:

 * данные типов `SymmetricKey`, `SecretKey` и `EncryptedContent` помещаются
   в контейнер в зашифрованном виде и для них реализуется имитозащита.

 * данные типов `PublicKey` и `PlainContent` помещаются в контейнер в незашифрованном виде,
   имитозащита указанных данных является опциональной.

Тип данных, описывающий формат контейнера для одной единицы контента,
в ASN.1 нотации определяется следующим образом.


    ContentContainer ::= SEQUENCE {
      version INTEGER (0..255) DEFAULT 1,  -- версия ключевого контейнера;
                                           -- по-умолчанию это значение равно 1,
      content Content,                     -- собственно содержимое контейнера,
      icode Integrity OPTIONAL             -- код целостности (имитовставка или электронная подпись)
                                           -- и параметры, необходимые для его проверки,
    }


Контейнер состоит из следующих полей:

 1.  `version` - данное значение определяет наличие и последовательность полей контейнера,
     в текущий момент времени версия должна принимать значение 1;
 2.  `content` - собственно данные, помещаемые в контейнер; данные могут быть дополнены мета-данными, описывающими
     способ хранения контента и его параметры;
 3.  `icode` - код целостности, представляющий собой имитовставку или электронную подпись, дополненную
     параметрами, необходимыми для проверки кода целостности; данное поле является обязательным для симметричных и секретных ключей.


## Ключевая информации

Для размещения зашифрованного контента необходимо использование исходного ключа,
обозначаемого далее `BasicKey`. Данный ключ может иметь длину 256 или 512 бит, в зависимости
от способа его выработки.

Допускается вырабатывать исходный ключ следующими способами:

 * из пароля, с использованием алгоритма PBKDF2, регламентируемого рекомендациями
   по стандартизации Р 50.1.111-2016;
 * с использованием открытого ключа получателя, для которого предназначен зашифровываемый контент
   (в основе этого механизма лежит схема, основанная на протоколе Диффи-Хеллмана с эфемерным ключом);
 * с использованием независимого распередения ключевой информации,
   позволяющего идентифицировать `BasicKey` по его уникальному номеру.

Все три способа позволяют выработать ключ длиной как 256, так и 512 бит.

Для описания способа генерации исходного ключа используется
тип данных, описываемый в ASN.1 нотации следующим образом.


    BasicKeyMetaData ::= SEQUENCE {
      method BasicKeyGenerationMethod, -- метод генерации исходного ключа,
      parameters BasicKeyParameters    -- параметры метода генерации
      ukm OCTET STRING OPTIONAL        -- случайный вектор, используемый
                                       -- в алгоритме выработки производных ключей
    }

    BasicKeyGenerationMethod ::= INTEGER (0..255) -- допустимые методы генерации контента
                                    -- 0 - генерация из пароля
                                    -- 1 - генерация с использованием открытого ключа получателя
                                    -- 2 - независимое распределение


Поле `method` определяет метод генерации исходного ключа.

Поле `parameters` представляет структуру,
описывающую параметры алгоритма генерации и восстанволения исходного ключа.
Для каждого метода генерации используется одна из структур данных,
определенных ниже.


    BasicKeyParameters ::= CHOICE {
      PBKDF2Parameters,  -- параметры генерации ключа из пароля
      DHKeyParameters,        -- параметры для генерации ключа на основе гибридной схемы
      ExternalKeyParameters   -- параметры независимого распределения ключа
    }


Поле `ukm` содержит случайное значение, используемое в дальнейшем для выработки производных ключей.
Данное значение должно быть определено только для ключей длины 256 бит.

### Выработка исходного ключа из пароля


При генерации исходного ключа `basicKey` из пароля
необходимо определить:

  - пароль `password`, представленный в виде строки символов произвольной длины
    в формате UTF8Sting (желательная длина пароля не менее 8 символов),
  - длину `len` вырабатываемого ключа в октетах (допустимыми значениями являются 32 или 64 октета),
  - число итераций `count` алгоритма `PBKDF2` (минимальное значение `count` должно равняться 1000,
    рекомендуемое - 2000),
  - случайную последовательность октетов `salt`, длина которой должна быть принимать значения
    в интервале от 8-ми октетов до 32-х (рекомендуемое значение 32),

Тогда, см. раздел 4 рекомендаций Р 50.1.111-2016,
пароль `basicKey` должен быть определен равенством


    basicKey = PBKDF2( password, salt, count, len )


Отметим, что
для реализации алгоритма `PBKDF2` можно использовать функцию ak_hmac_context_pbkdf2_streebog512();

После выработки исходного ключа использованная информация `salt`, `count` и `len`
должна помещаться в поле `parameters` введенной ранее структуры `BasicKeyMetaData`.
Для этого должна использоваться структура
данных `PBKDF2Parameters`, определяемая в ASN.1 нотации следующим образом.


    PBKDF2Parameters ::= SEQUENCE {
      salt OCTET STRING,                   -- инициализационный вектор для алгоритма PBKDF2
      iterationCount INTEGER (0..65535),   -- число итераций алгоритма PBKDF2
      keyLength INTEGER (0..255) OPTIONAL, -- длина ключа (в октетах)
      prf OBJECT IDENTIFIER OPTIONAL,      -- идентификатор псевдослучайной функции
    }


Структура `PBKDF2Parameters` содерит два опциональных поля, которые могут отсутствовать.

Поле `keyLength` может быть опущено для ключей длины 256 бит (32 октета).
Более того, может быть опущено поле `prf`, если оно должно содержать идентификатор используемой
в алгоритме `PBKDF2` псевдослучайной функции


    hmac-streebog512 OBJECT IDENTIFIER ::= { 1.2.643.7.1.1.4.2 }


### Выработка исходного ключа с использованием открытого ключа получателя


При генерации исходного ключа с использованием открытого ключа получателя для формирования поля `parameters`
должна использоваться структура данных `DHKeyParameters`, определяемая в ASN.1 нотации следующим образом.


    DHKeyParameters ::= SEQUENCE {
       сертификат открытого ключа получателя
       ukmDH случайное значение
    }


### Использование незавимо распределенного исходного ключа


При независимом распределении исходного ключа для формирования поля `parameters` должна использоваться
структура данных `ExternalKeyParameters`, определяемая в ASN.1 нотации как последовательность октетов.


    ExternalKeyParameters := OCTET STRING


Данная структура данных содержит только одно поле - уникальный номер исходного ключа `BasicKey`.


### Выработка производных ключей шифрования и имитозащиты


В дальнейшем, исходный ключ `BasicKey` используется для выработки производных ключей:
  * ключа `KEK` - ключа шифрования длиной 256 бит, используемоего для шифрования контента,
  * ключа `KIM` - ключа имитозащиты, используемого для имитозащиты контента.

Алгоритм выработки производных ключей зависит от размера ключа `BasicKey`.
Если размер ключа равен 512 бит (64 октета), то производные ключи определяются равенствами


    KEK = Lsb( 256, BasicKey ) = BasicKey[0..31],
    KIM = Msb( 256, BasicKey ) = BasicKey[32..63],


то есть, ключ `KEK` представляет собой младшую половину ключа `BasicKey`, а ключ `KIM` - старшую половину.

Если длина ключа `BasicKey` равна 256 бит (32 октета), то производные ключи определяются равенствами,
введенными  в рекомендациях по CMS, см. раздел 8.3.2 в Р 1323565 ???,


    KExtract( BasicKey, ukm ) =
      = KDF_TREE_3411_2012_256( BasicKey, label = "kdftree", seed = ukm, R = 1 ) = { K(1), K(2) }
    KEK = K(1),
    KIM = K(2)


где функция `KDF_TREE_3411_2012_256` определена в разделе 4.5 рекомендаций по стандартизации Р 50.1.113-2016,
а `ukm` - некоторое случайное значение длиной 8 октетов, вырабатываемое при помещении данных в контейнер.


## Формирование и хранение контента

Тип данных, описывающий формат хранения контента, в ASN.1 нотации определяется следующим образом.


    Content ::= SEQUENCE {
      type ContentType,           -- тип контента,
      metaData ContentMetaData,   -- метаданные контента,
      data OCTET STRING OPTIONAL  -- собственно данные контента
    }

Поле `type` содержит тип контента, принимающий одно из пяти определенных выше значений.

Поле `metaData` представляет собой структуру данных, содержащую метаданные контента.
Каждому типу контента соответствует одна структура хранения мета-данных
из приводимого далее перечня.


    ContentMetaData ::= CHOICE {
      symKey SymmetricKey,          -- ключ симметричного алгоритма,
      secKey SecretKey,             -- секретный ключ асимметричного алгоритма,
      pubKey PublicKey,             -- открытый ключ асимметричного алгоритма,
      encContent EncryptedContent,  -- произвольные зашифровываемые данные,
      plainContent PlainContent     -- произвольные открытые данные, подлежащие имитозащите
    }


Поле `data` представляет собой ber-последовательность, кодирующую данные, помещаемые в контейнер.
Способ представления данных зависит от типа контента и детально описывается далее.

### Помещение в контейнер данных типа SymmetricKey

Для контента, представляющего собой симметричный ключ криптографического преобразования,
определена следующая структура хранения мета-данных.


    SymmetricKey ::= SEQUENCE {
      basicKey BasicKeyMetaData,       -- метаданные, позволяющие вычислить исходный ключ basicKey,
      keyData SymmetricKeyMetaData,    -- метаданные, описывающие параметры симметричного ключа,
      algInfo EncryptionAlgorithmInfo  -- параметры алгоритма шифрования симметричного ключа
    }


1. Поле `basicKey` содерит в себе информацию, необходимую для восстановления исходного ключа.
Формат структуры `BasicKeyMetaData` был приведен ранее.

2. Поле `keyData` содержит в себе метаданные симметричного ключа, помещаемого в контейнер.

3. Поле `algInfo` содержит в себе параметры алгоритма, используемого для шифрования данных (собственно ключевого значения),
помещаемого в контейнер.


Структура данных `SymmetricKeyMetaData`, описывающая метаданные симметричного ключа,
определяется в ASN.1 нотации следующим образом.


    SymmetricKeyMetaData ::= SEQUENCE {
      oid OBJECT IDENTIFIER,          -- алгоритм, для которого предназначен ключ,
      number OCTET STRING,            -- уникальный идентификатор ключа,
      resource SymmetricKeyResource,  -- ресурс симметричного ключа
    }

где
 * `oid` - идентификатор алгоритма, для которого предназначен ключ симметричного криптографического алгоритма;
 данное значение позволяет однозначно определить конструктор ключа при его чтении из контейнера;

 * `number` - уникальный номер (идентификатор) ключа, присвоенный ему при создании;

 * `resource`  - множество параметров симметричного ключа, определяющая его ресурс (набор ограничений на использование ключа);
 структура `SymmetricKeyResource`, в которую помещается ресурс, определяется в ASN.1 нотации следующим образом.


    SymmetricKeyResource ::= SEQUENCE {
      counterType INTEGER (0..255),                -- тип счетчика,
      counter KeyResourceCounter (0..4294967295),  -- значение счетчика,
      timeValidity Validity OPTIONAL               -- время действия ключа
    }

    Validity ::= SEQUENCE {
      notBefore Time,
      notAfter Time
    }

    Time ::= CHOICE {
      utcTime UTCTime,
      generalTime generalizedTime
    }


Структура `EncryptionAlgorithmInfo` определяющая параметры зашифрования симметричного ключа,
определяется в ASN.1 нотации следующим образом.


    EncryptionAlgorithmInfo ::= SEQUENCE {
      algorithm OBJECT IDENTIFIER, -- идентификатор блочного алгоритма и режима его использования
      iv OCTET STRING -- синхропосылка, используемая при шифровании
    }


Поле `algorithm` содержит идентификатор пары: алгоритма блочного шифрования и
режима работы блочных шифров. Данное поле может принимать следующие значения,
см. рекомендации по CMS, раздел 8.3.1.


    ctr-magma OBJECT IDENTIFIER ::= { 1.2.643.2.52.1.8.1.1 }
    ctr-kuznechik OBJECT IDENTIFIER ::= { 1.2.643.2.52.1.8.2.1 }
    id-gostr3412-2015-magma-ctracpkm OBJECT IDENTIFIER ::= { 1.2.643.7.1.1.5.1.1 }
    id-gostr3412-2015-kuznechik-ctracpkm OBJECT IDENTIFIER ::= { 1.2.643.7.1.1.5.2.1 }


Поле `iv` содержит в себе значение синхропосылки, использованной при зашифровании симметричного ключа.
Длина имитовставки определяется используемым режимом шифрования.

Алгоритм размещения симметричного ключа `SymmetricKey` в контейнере
заключается в следующем.

 1. Необходимо выбрать способ генерации исходного ключа `basicKey`.

  * В случае генерации ключа из пароля, необходимо определить:


  * В случае использования открытого ключа получателя необходимо определить:
    - сертификат открытого ключа получателя, содержащий идентификатор некоторой эллиптической кривой и точку
      на этой кривой, являющуюся открытым ключом получателя,
    - случайное число,

  * В случае использования независимо распределенного ключа необходимо определить номер исходного ключа.

 2. ы

 3. ыы

 4. ыыы

 5. ыыыы

### Помещение в контейнер данных типа SecretKey

### Помещение в контейнер данных типа EncryptedContent

### Помещение в контейнер данных типа PublicKey

### Помещение в контейнер данных типа PlainContent


## Формирование и хранение кода целостности

Для хранения кода целостности предназначен тип данных, кодируемый в ASN.1 нотации следующим образом.


    Integrity ::= SEQUENCE {
       algorithm OBJECT IDENTIFIER, -- алгоритм вычисления кода целостности
       value BIT STRING,            -- значение кода целостности
       other IntegrityData OPTIONAL -- дополнительные данные, необходимые для
                                    -- проверки кода целостности
    }

Для формирования кода целостности может быть использован:

 * симметричный алгоритм - в этом случае кодом целостности является имитовставка, либо
 * асимметричный алгоритм - в этом случае кодом целостности является электронная подпись.


### Использование имитозащиты

В случае использования имитовставки в качестве кода целостности,
необходимо определить алгоритм выработки имитовставки и симметричный ключ имитозащиты.

Допустимыми алгоритмами являются:

 * Алгоритм `OMAC`, регламентированный ГОСТ Р 34.13-2015.
 Для вычисления имитовставки в этом случае может быть использована функция внутреннего интерфейса
 ak_bckey_context_omac(). Для указания алгоритма OMAC поле `algorithm` типа данных `Integrity` должно принимать значения,
 зависящие от используемого алгоритма блочного шифрования.


    omac-magma OBJECT IDENTIFIER ::= { 1.2.643.2.52.1.4.1 }
    omac-kuznechik OBJECT IDENTIFIER ::= { 1.2.643.2.52.1.4.2 }


 Отметим, что данные значения не определены в рамках дерева идентификаторов ТК26 и могут быть, в дальнейшем, изменены.

 * Алгоритм выработки имитовставки `HMAC`, оcнованный на применении функции хеширования "Стрибог-256" и
 регламентированный рекомендациями по стандартизации Р 50.1.113-2016.
 Для вычисления имитовставки в этом случае может быть использована функция внутреннего интерфейса
 ak_hmac_context_ptr(). Для указания алгоритма `HMAC-Streebog256` поле `algorithm` типа данных `Integrity` должно
 принимать следующее значение, см. раздел 4.1 в Р 50.1.113-2016,


    hmac-streebog256 OBJECT IDENTIFIER ::= { 1.2.643.7.1.1.4.1 }


 В качестве ключа выработки имитовставки должен выступать ключ `KIM`, размером 256 бит,
 выработанный из ключа `BasicKey` описанным ранее способом.

 Значение имитовставки вычисляется от ber-представления поля `ContentContainer.content` и
 помещается в поле `Integrity.value`.

 В случае использования имитовставки дополнительные данные (поле `other`) должны отсутствовать.

 ### Использование электронной подписи

 В случае использования электронной подписи в качестве кода целостности,
 необходимо определить алгоритмы формирования и проверки подписи,
 а также ключевую пару - секретный и открытый ключи подписи.
 При этом мы полагаем, что открытый ключ подписи содержится в сертификате,
 гарантирующем его целостность и валидность.



