
Задачи для дальнейшего развития библиотеки (задания: весна 2017)

 I. Режимы шифрования (на основе ГОСТ Р 34.13-2015, ГОСТ 28147-89)
 
  1.1.  Режим гаммирования (простая, "наивная" реализация)
  1.2.  Режим гаммирования (многопоточная реализация, число потоков совпадает с числом ядер процессора)
  1.3.  Режим гаммирования с обратной связью по выходу (простая реализация с поддержкой длинных синхропосылок)
  1.4.  Режим гаммирования с обратной связью по выходу (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.5.  Режим простой замены с зацеплением (простая реализация с поддержкой длинных синхропосылок)
  1.6.  Режим простой замены с зацеплением (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.7.  Режим гаммирования с обратной связью по шифртексту (простая реализация с поддержкой длинных синхропосылок)
  1.8.  Режим гаммирования с обратной связью по шифртексту (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.9.  Режим выработки имитовставки ГОСТ Р 34.13-2015
        (с созданием контекста ключа выработки имитовставки)
  
  1.10. Режим гаммирования согласно ГОСТ 28147-89 (простая, "наивная" реализация)
  1.11. Режим гаммирования согласно ГОСТ 28147-89 (многопоточная реализация, число потоков совпадает с числом ядер процессора)
  1.12. Режим XTS (простая реализация)
  1.13. Режим XTS (многопоточная реализация, число потоков совпадает с числом ядер процессора)

 II. Криптографические преобразования (на основе Р 50.1.113-2016)
 
  2.1.  Изменение существующего экспортируемого инфтерфейса функций хеширования
        (комментарий 07.01.2016: 
         - для переделки интерфейса функции хеширования в три вызова
           (new, update, finalize) нужно сделать буффер
           для хранения промежуточных значений обрабатываемого текста.
           Этот буффер естественно поместить в контекст хеширования
           и выделять под него память/удалять память в функциях create/delete.

           Поскольку размер буффера зависит от размера входного блока функции (bsize)
           хеширования, то его надо выделять в ak_hash_new,
           передавая размер в качестве второго параметра функции.
         )
        
  2.2.  Реализация алгоритма HMAC с внешним интерфейсом, аналогичным новому интерфейсу функций хеширования.
        (создание контекста hmac, создание контекста ключа выработки имитовставки)
      
  2.3.  Реализация функции выработки ключа VKO (п.4.3 из Р 50.1.113-2016)
        (создание контекста секретного/открытого ключей, реализация алгоритма)  
   
  2.4.  Реализация алгоритма диверсификации (выработки производного ключа) KDF_GOSTR3411_2012_256 (п.4.4 из Р 50.1.113-2016)
        (алгоритм должен быть реализован в виде функции на вход которой подается секретный ключ и параметры алгоритма,
         на выходе также появляется секретный ключ (с маскированием, установленным ресурсом и т.п.)
        )
  2.5.  Разработка вычислений с кривыми Эдварса (класс ak_ecurve, в манере, аналогичной ak_wcurve)
        (включая операции на кривой и тестовые примеры согласно Р.50.1.114-2016)
  2.6.  Реализация ГОСТ Р 34.10-2012 (включая контексты открытых/секретных ключей, алгоритмы выработки и проверки ЭЦП,
        тестовые примеры)
        
  Вражеское (совершенно не нужно):
  2.5.  Блочное шифрование: AES
  2.6.  Блочное шифрование: RC6
  2.7.  Функции хеширования: Keccak
        
 III. Генераторы псевдослучайных чисел
  
  3.1.  Генератор, использующий функцию GenCryptRandom() для выработки псевдослучайных значений (только для Windows)
  3.2.  Генератор на основе функции хеширования, 
        предлагаемый проектом методических рекомендаций ТК26 "Механизмы выработки псевдослучайных последовательностей"
        (используемая хеш-функция - параметр генератора)
  3.3.  Генератор, реализующий "вихрь Мерсенна" (Mersenne twister). 
        Сравнение с аналогичной реализацией в C++ библиотеке STL.
        
 IV. Структурные разработки (сложные задачи) 
  4.1.  Разработка менеджера памяти для хранения ключевой информации
        (собственная несвопируемая, блокируемая память, с контролем целостности)
  4.2.  Разработка механизма контроля открытых/секретных ключей библиотеки с поддержкой (возможно, прототипов) функций:
        чтения, сохранения, предоставления интерфейса к криптографическим функциям.
        (функционал криптопровайдера)        
  4.3.  Реализация механизма ASN1 через asn1c и его интеграция в библиотеку       
  4.4.  Исследование модуля ядра, реализующего /dev/random и dev/urandom для ядер версии 4.x
        Предложения по его модификации в русле отечественных требований.
  4.5.  Портирование текущей версии библиотеки на BSD (FreeBSD, OpenBSD, NetBSD и т.д. )
        с предоставлением соответствующей виртуалки (VirtualBox, QEMU)
    
 V. Упражнения на ассемблере (факультатив)
    
  5.1.  Реализация ассемблерной вставки umul_pmul для MSVC и 32х и 64х битной архитектуры
  5.2.  Реализация существующего кода для ak_mpzn на ассемблере под архитектуру x64 (x86)
        для сборки gcc и clang
  5.3.  Реализация существующего кода для ak_mpzn на ассемблере под архитектуру x64 (x86)
        для сборки MSVC

        
axelkenzo:TODO

26.12.2016  - отключено ak_keylist_create/destroy .. изза проблем с Valgrind.
              надо протестировать сей механизм.
            - убрать keylist из текущей ветки и соответствующие вызовы из libakrypt.h

04.12.2016  - Для функции ak_mpzn_modpow_montgomery() необходима оптимизация.
              Текущая реализация существенно проигрывает библиотеке gmp.

07.11.2016  - Вызов _mm_set_epi64x() под msvc 10 не работает на той же машине
              под clang/gcc + linux все работает корректно
              - нужна эквивалентная реализация
