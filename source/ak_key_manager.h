/* ----------------------------------------------------------------------------------------------- */
/*  Copyright (c) 2014 - 2019 by Axel Kenzo, axelkenzo@mail.ru                                     */
/*                                                                                                 */
/*  Файл ak_key_manager.h                                                                          */
/*  - содержит определение интерфейса для механизмов хранения ключевой информации                  */
/* ----------------------------------------------------------------------------------------------- */
 #ifndef    __AK_KEY_MANAGER_H__
 #define    __AK_KEY_MANAGER_H__

/* ----------------------------------------------------------------------------------------------- */
 #include <libakrypt.h>

/* ----------------------------------------------------------------------------------------------- */
#ifdef LIBAKRYPT_HAVE_STDIO_H
 #include <stdio.h>
#else
 #error Library cannot be compiled without stdio.h header
#endif
#ifdef LIBAKRYPT_HAVE_STDLIB_H
 #include <stdlib.h>
#else
 #error Library cannot be compiled without stdlib.h header
#endif

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Тип ключа, помещаемого в ключевое хранилище */
 typedef enum {
  /*! \brief Ключ симметричного криптографического преобразования.
      \details К симметричным ключам относятся объекты классов skey, bckey, hmac, omac и mgm. */
  symmetric_key,
 /*! \brief Секретный ключ асимметричного криптографического алгоритма.
     \details К открытым ключам относятся объекты класса signkey. */
  secret_key,
 /*! \brief Открытый ключ асимметричного криптографического алгоритма.
     \details К открытым ключам относятся объекты класса verifykey. */
  public_key
} stored_key_t;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Формат хранения ключевой информации. */
 typedef enum {
  /*! \brief Простой формат хранения секретных ключей, реализуемый библиотекой libakrypt.
      \details В данном фомате ключевой контекст преобразуется в последовательность октетов,
      которая зашифровывается при помощи ключа, выработанного из пароля. Предполагается,
      что для каждого ключа используется свой собственный пароль 
      (ebpp, encrypt by personal password). Способ формирования последовательности октетов 
      описывается в 
      
      
   */
   ebpp_plain_secret_key_format
} key_storage_format_t;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Флаги получения ключевой информации. */
 typedef enum {
   /*! \brief Флаг точного соответствия номера ключа. */
    exact_key_number_flag = 0x01uLL
} key_storage_flags_t;

/* ----------------------------------------------------------------------------------------------- */
 typedef struct key_manager *ak_key_manager;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция добавления ключа.
    \details Функция должна добавлять ключ в ключевое хранилище. В случае успешного добавления
    должно возвращаться значение \ref ak_error_ok.

    Тип добавляемого ключа определяется переменной типа oid_engines_t. Ключевой менеджер должен
    поддерживать сохранение ключей хотя бы одного типа. Если тип не поддерживается, должна
    возвращаться ошибка ak_error_key_engine.

    Формат, в котором будет храниться ключ, определяется переменной типа key_storage_format.
    Ключевой менеджер должен поддерживать сохранение ключей хотя бы в одном формате. Если заданный
    формат не поддерживается, должна возвращаться ошибка ak_error_key_format.

    Последний параметр функции определяет указатель на произвольную структуру (область памяти),
    в которой передаются параметры, необходимые для сохранения ключа в ключевом хранилище.
    Конкретный вид передаваемых параметров должен определяться типом key_storage_format.
    В случае, если дополнительные данные не нужны, должно использоваться значение NULL. */
 typedef int ( ak_function_add_key )
               ( ak_key_manager , ak_pointer , oid_engines_t , key_storage_format_t , ak_pointer );

/* ----------------------------------------------------------------------------------------------- */
   все не так идеально,
   вот как я узнаю, что мне нужно передать пароль для считывания ключа =>
   сначала поиск ключа по номеру (+максимум вспомогательной информации oid_engines_t *, key_storage_format_t *),
   только потом чтение ключа

/*! \brief Функция получения ключа по его номеру.
    \details По заданному номеру ключа, передаваемому в объекте клсса buffer,
    функция должна возвращать указатель на контекст ключа, размещенный в оперативной памяти.
    В переменной типа key_storage_flags_t должны передаваться параметры (флаги), уточняющие 
    процедуру поиска ключа.
    
    В переменную oid_engines_t должен помещаться тип криптографического механизма, 
    для которого создан ключ. Последний параметр функции определяет указатель на произвольную 
    структуру (область памяти), в которой передаются параметры, необходимые для чтения 
    ключа из ключевого хранилища.
    
    В случае ошибки, функция должна возвращать NULL и устанавливать значение, которое 
    можно получить с помощью функции ak_error_get_value(). */
 typedef ak_pointer ( ak_function_get_key )
               ( ak_key_manager , ak_buffer , key_storage_flags_t , oid_engines_t * , ak_pointer );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Стуктура, описывающая общий интерфейс к менеджерам ключевой инфорации.
    \details Менеджер ключевой информации представляет собой совокупность функций, позволяющих
    сохранять ключевую информацию, получать доступ к ключам по их номеру,
    искать ключи, экспортировать и импортировать ключевую информацию. */
/* ----------------------------------------------------------------------------------------------- */
 struct key_manager {
  /*! \brief Идентификатор конкретного объекта мененджера ключевой информации.
      \details Может содержать любую последовательность октетов, в частности,
      имя файла, каталога или уникальный идентифкатор UUID. */
   ak_uint8 name[FILENAME_MAX];
  /*! \brief Функция добавления ключа. */
   ak_function_add_key *add_key;
  /*! \brief Функция получения ключа. */
   ak_function_get_key *get_key;
};

 #endif
/* ----------------------------------------------------------------------------------------------- */
/*                                                                               ak_key_manager.h  */
/* ----------------------------------------------------------------------------------------------- */
