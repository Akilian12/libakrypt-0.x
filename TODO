Общие требования к решению задач:
 1. Язык разработки -- С (стандарт С99)
 2. Алгоритм должен быть реализован как составная часть библиотеки (с добавлением заголовков функций
    в соответствующие заголовочные файлы),
    использующая только встроенные типы данных, преобразования и другие механизмы.
 3. Использование внешних библиотек не допускается.
 4. Для новых алгоритмов должны быть добавлены их OID'ы
 5. Все функции должны быть откомментированы в соответствии с принятыми правилами (doxygen нотация)
 6. К каждому алгоритму должен быть реализован контрольный пример (если есть)
    и тестовая функция, которая также должна быть встроена в библиотеку.
 7. Программа не должна иметь утечек памяти и переходов на неинициализированные области памяти
    (обязательная проверка через Valgrind и т.п.)
 8. Сборка должна осуществляться существующим механизмом cmake.
    Обязательно тестирование сборки под linux и Windows


Задачи для дальнейшего развития библиотеки (задания: весна 2017)

 I. Режимы шифрования (на основе ГОСТ Р 34.13-2015, ГОСТ 28147-89)

  1.1.  Режим гаммирования (простая, "наивная" реализация)
  1.2.  Режим гаммирования (многопоточная реализация, число потоков совпадает с числом ядер процессора)
  1.3.  Режим гаммирования с обратной связью по выходу (простая реализация с поддержкой длинных синхропосылок)
  1.4.  Режим гаммирования с обратной связью по выходу (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.5.  Режим простой замены с зацеплением (простая реализация с поддержкой длинных синхропосылок)
  1.6.  Режим простой замены с зацеплением (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.7.  Режим гаммирования с обратной связью по шифртексту (простая реализация с поддержкой длинных синхропосылок)
  1.8.  Режим гаммирования с обратной связью по шифртексту (многопоточная реализация, число потоков кратно длине синхропосылки)
  1.9.  Режим выработки имитовставки ГОСТ Р 34.13-2015
        (с созданием контекста ключа выработки имитовставки)

  1.10. Режим гаммирования согласно ГОСТ 28147-89 (простая, "наивная" реализация)
  1.11. Режим гаммирования согласно ГОСТ 28147-89 (многопоточная реализация, число потоков совпадает с числом ядер процессора)
  1.12. Режим XTS (простая реализация)
  1.13. Режим XTS (многопоточная реализация, число потоков совпадает с числом ядер процессора)

 II. Криптографические алгоритмы (блочного шифрования и хеширования)

   2.1  Алгоритм ГОСТ 27147-89 (с произвольными таблицами замен)
   2.2. Алгоритм ГОСТ Р 34.12-2005 (Кузнечик)
   2.3. Алгоритм AES
   2.4. Алгоритм RC6
   2.5. Алгоритм Keccak (хеширование)
   2.6. Алгоритм Wirlpool (хеширование)

 III. Криптографические преобразования (на основе Р 50.1.113-2016)

  2.1.  Реализация алгоритма HMAC с внешним интерфейсом.
        (создание контекста hmac, создание контекста ключа выработки имитовставки)

  2.2.  Реализация функции выработки ключа VKO (п.4.3 из Р 50.1.113-2016)
        (создание контекста секретного/открытого ключей, реализация алгоритма)

  2.3.  Реализация алгоритма диверсификации (выработки производного ключа) KDF_GOSTR3411_2012_256 (п.4.4 из Р 50.1.113-2016)
        (алгоритм должен быть реализован в виде функции на вход которой подается секретный ключ и параметры алгоритма,
         на выходе также появляется секретный ключ (с маскированием, установленным ресурсом и т.п.)
        )
  2.4.  Разработка вычислений с кривыми Эдварса (класс ak_ecurve, в манере, аналогичной ak_wcurve)
        (включая операции на кривой и тестовые примеры согласно Р.50.1.114-2016)
  2.5.  Реализация ГОСТ Р 34.10-2012 (включая контексты открытых/секретных ключей, алгоритмы выработки и проверки ЭЦП,
        тестовые примеры)

 IV. Генераторы псевдослучайных чисел

  3.1.  Генератор, использующий функцию GenCryptRandom() для выработки псевдослучайных значений (только для Windows)
  3.2.  Генератор на основе функции хеширования,
        предлагаемый проектом методических рекомендаций ТК26 "Механизмы выработки псевдослучайных последовательностей"
        (используемая хеш-функция - параметр генератора)
  3.3.  Генератор, реализующий "вихрь Мерсенна" (Mersenne twister)
        Сравнение с аналогичной реализацией в C++ библиотеке STL.
  3.4.  Генератор BBS (Блюм-Блюм-Шуб), использующий вычисления по модулю составного 512 битного числа
  3.5.  Генератор Макларена-Марсальи (перемешивающий генератор)

 V. Структурные разработки (сложные задачи)
  4.1.  Разработка менеджера памяти для хранения ключевой информации
        (собственная несвопируемая, блокируемая память, с контролем целостности)
  4.2.  Разработка механизма контроля открытых/секретных ключей библиотеки с поддержкой (возможно, прототипов) функций:
        чтения, сохранения, предоставления интерфейса к криптографическим функциям.
        (функционал криптопровайдера)
  4.3.  Реализация механизма ASN1 через asn1c и его интеграция в библиотеку
  4.4.  Исследование модуля ядра, реализующего /dev/random и dev/urandom для ядер версии 4.x
        Предложения по его модификации в русле отечественных требований.
  4.5.  Портирование текущей версии библиотеки на BSD (FreeBSD, OpenBSD, NetBSD и т.д. )
        с предоставлением соответствующей виртуалки (VirtualBox, QEMU)

 VI. Упражнения на ассемблере (факультатив)

  5.1.  Реализация ассемблерной вставки umul_pmul для MSVC и 32х и 64х битной архитектуры
  5.2.  Реализация существующего кода для ak_mpzn на ассемблере под архитектуру x64 (x86)
        для сборки gcc и clang
  5.3.  Реализация существующего кода для ak_mpzn на ассемблере под архитектуру x64 (x86)
        для сборки MSVC


axelkenzo:TODO

26.12.2016  - отключено ak_keylist_create/destroy .. изза проблем с Valgrind.
              надо протестировать сей механизм.
            - убрать keylist из текущей ветки и соответствующие вызовы из libakrypt.h

04.12.2016  - Для функции ak_mpzn_modpow_montgomery() необходима оптимизация.
              Текущая реализация существенно проигрывает библиотеке gmp.

07.11.2016  - Вызов _mm_set_epi64x() под msvc 10 не работает на той же машине
              под clang/gcc + linux все работает корректно
              - нужна эквивалентная реализация
