Форматы хранения контента с использованием ASN.1 нотации
--------------------------------------------------------

Для локального хранения данных и, при необходимости, передачи данных по каналам связи
в библиотеке поддерживается единый формат хранения контента, основанный на применении ASN.1 нотации для кодирования
данных. Используемый в библиотеке `libakrypt` формат основан на ГОСТ Р ИСО/МЭК 8824-1-2001,
ITU X.509, RFC 5280, отечественнных рекомендациях по стандартизации:

 - Р 50.1.111-2016 "Парольная защита ключевой информации",
 - Р 1323565.1.023-2018 "Использование алгоритмов ГОСТ Р 34.10-2012, ГОСТ Р 34.11-2012 в сертификате,
   списке аннулированных сертификатов (CRL) и запросе на сертификат PKCS #10 инфраструктуры открытых ключей X.509",

а также содержит ряд описываемых далее оригинальных форматов хранения ключевой информации.

Описание элементарных типов ASN.1
=================================

К базовым типам ASN.1, определенным ГОСТ Р ИСО/МЭК 8824-1-2001, относятся

    BOOLEAN
    INTEGER
    BIT_STRING
    OCTET_STRING
    NULL
    OBJECT_IDENTIFIER
    OBJECT_DESCRIPTOR
    EXTERNAL
    REAL
    ENUMERATED
    UTF8_STRING
    SEQUENCE
    SET
    NUMERIC_STRING
    PRINTABLE_STRING
    T61_STRING
    VIDEOTEX_STRING
    IA5_STRING
    UTCTIME
    GENERALIZED_TIME
    GRAPHIC_STRING
    VISIBLE_STRING
    GENERAL_STRING
    UNIVERSAL_STRING
    CHARACTER_STRING
    BMP_STRING

В библиотеке `libakrypt` реализована поддержка указанных типов в объеме, достаточном
для реализации механизмов экспорта/импорта ключевой информации в соответствии с национальными
стандартами и рекомендациями по стандартизации.
Все остальные используемые библиотекой типы данных строятся из базовых типов.

Также в библиотеке реализовано некоторое множество базовых составных типов, которые неоднократно
используются при экспорте и импорте разных типов ключевых данных.
Большая часть приведенных далее типов определяется согласно RFC 5280.

### Тип Time
Тип `Time`, согласно x509, описывает значение времени.

    Time ::= CHOICE {
      utcTime UTCTime,
      generalTime generalizedTime
    }

### Тип Validity

Тип `Validity` содержит в себе временной интервал действия
ключа и определяется стандартным для x509 образом.

    Validity ::= SEQUENCE {
      notBefore Time,
      notAfter Time
    }

### Тип Resource

Тип `KeyParameters` предназначен для хранения
ресурсов (ограничений) использования ключевой информации и определяется следующим образом.

    KeyParameters ::= SEQUENCE {
       resourceType INTEGER, -- тип ресурса секретного ключа
       resource INTEGER,     -- значение ресурса
       validity Validity     -- временной интервал использования ключа
    }

Тип ресурса секретного ключа должен принимать значения,
определямые константами реализованного в библиотеке перечисления \ref counter_resource_t

### Тип Name

Тип `Name` -- глобальное или обобщенное имя представляет собой
иерархический список типизированных имен, состоящих их пары тип-имя.
Каждая пара может описывать различные характеристики обощенного имени, например, страну, графическое положение,
имя, прозвище, место работы, подразделение и т.п.

    Name ::= CHOICE {
               rdnSequence RDNSequence  -- сейчас поддерживается только один вариант
    }

    RDNSequence ::= SEQUENCE OF RelativeDistinguishedName

    RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue

    AttributeTypeAndValue ::= SEQUENCE {
       type   AttributeType,  -- тип пары, определяющий смысловую нагрузку строки
       value  AttributeValue  -- символьная строка с информацией
    }

    AttributeType ::= OBJECT IDENTIFIER

    AttributeValue ::= ANY DEFINED BY AttributeType

Как правило, строка данных определяется одним из следующих строковых типов

    DirectoryString ::= CHOICE {
       teletexString TeletexString (SIZE (1..MAX)),
       printableString PrintableString (SIZE (1..MAX)),
       universalString UniversalString (SIZE (1..MAX)),
       utf8String UTF8String (SIZE (1..MAX)),
       bmpString BMPString (SIZE (1..MAX))
    }

Пример декодирования обощенного имени, взятый из корневого сертифката тестового УЦ,
выглядит следующим образом.

    ├SEQUENCE┐
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 1.2.643.100.1 (ОГРН)
             │            └NUMERIC STRING 1234567890123
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 1.2.643.3.131.1.1 (ИНН)
             │            └NUMERIC STRING 001234567890
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 2.5.4.9 (Street Address)
             │            └UTF8 STRING ул. Сущёвский вал д. 18
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 2.5.4.6 (Country Name)
             │            └PRINTABLE STRING RU
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 2.5.4.8 (State Or Province Name)
             │            └UTF8 STRING г. Москва
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 2.5.4.7 (Locality Name)
             │            └UTF8 STRING Москва
             ├SET┐
             │   └SEQUENCE┐
             │            ├OBJECT IDENTIFIER 2.5.4.10 (Organization)
             │            └UTF8 STRING ООО "КРИПТО-ПРО"
             └SET┐
                 └SEQUENCE┐
                          ├OBJECT IDENTIFIER 2.5.4.3 (Common Name)
                          └UTF8 STRING Тестовый УЦ ООО "КРИПТО-ПРО"


Поддерживаемые типы контента и криптографические механизмы его защиты
=====================================================================


Формат общего контейнера для хранения данных
============================================


Форматы хранения открытых ключей
================================


### Тип CertificationRequest

### Тип Certificate


    Certificate  ::=  SEQUENCE  {
         tbsCertificate       TBSCertificate,
         signatureAlgorithm   AlgorithmIdentifier,
         signature            BIT STRING  }


### Используемые расширения сертификата открытого ключа

Расширения добавляются в сертификат открытого ключа начиная с третьей версии.
Общая структура расширения имеет следующий вид.

    Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension

    Extension  ::=  SEQUENCE  {
       extnID      OBJECT IDENTIFIER,
       critical    BOOLEAN DEFAULT FALSE,
       extnValue   OCTET STRING
                   -- contains the DER encoding of an ASN.1 value
                   -- corresponding to the extension type identified
                   -- by extnID
    }

Поле `extnID` определяет идентификатор расширения по которому оно может
быть опознано и декодировано.

Полк `critical` определяет, является ли оно критическим или нет.
Не критические расширения могут не обрабатываться при декодировании сертификата.

Поле `extnValue` содержит значение расширения,
закодированное в виде der-строки. Далее мы опишем типы сообщений,
поддерживаемых библиотекой `libakrypt`.


#### Расширение `SubjectKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.14 }

    SubjectKeyIdentifier ::= OCTET STRING


Расширение `SubjectKeyIdentifier`
представляет механизм идентификации сертификата, содержащего данный открытый ключ.

Стандарт RFC 5280 рекомендует брать
в качестве `SubjectKeyIdentifier` значение функции хеширования от поля `SubjectPublicKey'
(см. выше `tbsCertificate`), содержащего значение открытого ключа.


В библиотеке `libakrypt` в качестве данного идентификатора выступает номер
открытого ключа, формируемый при его создании, т.е.

    ak_verifykey public_key;
    public_key->number;  /* это SubjectKeyIdentifier */


Чтобы облегчить построение пути сертификации, расширение `SubjectKeyIdentifier` ДОЛЖНО
появляться во всех соответствующих сертификатах центра сертификации,
то есть во всех сертификатах, включая содержащие расширение `BasicConstraints`
со значением `cA` равным истине.

Ценр сертификации ДОЛЖЕН помечать это расширение как некритическое.
Вместе с тем, во всех доступных реализациях метка некритичности не
ставится, и расширение состоит только из OID и OCTET STRING.


#### Расширение `AuthorityKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.35 }

    AuthorityKeyIdentifier ::= SEQUENCE {
      keyIdentifier             [0] KeyIdentifier           OPTIONAL,
      authorityCertIssuer       [1] GeneralNames            OPTIONAL,
      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }

    KeyIdentifier ::= OCTET STRING

Расширение `AuthorityKeyIdentifier` обеспечивает средство
идентификации открытого ключа, соответствующего закрытому ключу,
использованному для подписи сертификата.
Другими словами,  расширение `AuthorityKeyIdentifier` позволяет идентифицировать открытый ключ,
с помощью которого можно проверить корректность электронной подписи под данным сертификатом.
Идентификация может быть основана на

 - идентификаторе ключа субъекта (`KeyIdentifier`),
   (это значение помещается в расширение `SubjectKeyIdentifier`
    сертификата верхнего уровня)

 - названии или обобщенном имени эмитента (`authorityCertIssuer`),

 - серийном номере сертификата (`authorityCertSerialNumber`) открытого ключа,
   который должен использоваться для проверки электронной подписи.
   (используется значение `SerialNumber` из `TBSCertificate` сертификата верхнего уровня)

Поле `keyIdentifier` расширения `authorithyKeyIdentifier` ДОЛЖНО
быть включено во все сертификаты, генерируемые соответствующими центрами сертификации,
чтобы облегчить путь поиска цепочки соотвествия.
Для самоподписанного сертификата может быть сделано исключение и
идентификатор ключа авторизации МОЖЕТ быть опущен (поскольку сертификат уже содержит
ключ, с помощью которого можно проверить электронную подпись).

Центр сертификации ДОЛЖЕН помечать это расширение как некритическое.

Пример декодирования расширения `AuthorityKeyIdentifier` выглядит следующим образом.


    └SEQUENCE┐
             ├[0] 5a7bfec75e2dfbc6e4972ebb1c098018c8f2d720
             ├[1]┐
             │   └[4]┐
             │       └SEQUENCE┐
             │                └SET┐
             │                    └SEQUENCE┐
             │                             ├OBJECT IDENTIFIER 2.5.4.3 (CommonName)
             │                             └UTF8 STRING Example
             └[2] 00ce4ccdd344d62dec


#### Расширение `KeyUsage`

Расширение `KeyUsage`, согласно рекомендациям Р 1323565.1.023-2018,
является опциональным полем (расширением) структуры TBSCertificate.
Для ключей, соответствующих алгоритму подписи ГОСТ Р 34.10-2012, данное расширение может
иметь следующие флаги:


    KeyUsage ::= BIT STRING {
       digitalSignature  (0),
       contentCommitment (1),
       keyEncipherment   (2),
       dataEncipherment  (3),
       keyAgreement      (4),
       keyCertSign       (5),
       cRLSign           (6),
       encipherOnly      (7),
       decipherOnly      (8)
    }


\note Отметим, что флаги `keyEncipherment` (2) и `dataEncipherment` (3) из
Р 1323565.1.023-2018 исключены.

Расширение `KeyUsage` определяет цель (например, шифрование, подпись, подпись сертификата)
использования ключа, содержащегося в сертификате.
Центр сертификации ДОЛЖЕН включать это расширение в сертификаты, которые
содержат открытые ключи, используемые для проверки цифровых подписей под другими сертификатами
или списками отозванных сертификатов.

Биты в типе `KeyUsage` используются следующим образом:

 - Бит `digitalSignature` устанавливается, когда открытый ключ субъекта
 используется для проверки цифровых подписей, кроме проверки подписей под сертификатами
 (установлен бит 5) и списками отозванных сертификатов CRL (установлен бит 6).
 Примером такого использования может служить подпись данных, использование
 в службах аутентификации объектов, источников данных и/или сервисах целостности.
 Для сертификатов, используемых при аутентификации участников протоколов выработки общего ключа,
 данный бит не устанавливается.


 - Бит `contentCommitment` устанавливается, когда открытый ключ субъекта
 используется для проверки цифровых подписей, кроме проверки подписей под сертификатами
 (установлен бит 5) и списками отозванных сертификатов CRL (установлен бит 6),
 используемых для предоставления службой аннулирования сертификатов.


 - Бит `keyEncipherment` устанавливается, когда открытый ключ субъекта
 используется для шифрования закрытых или секретных ключей, т. е.
 выступает в роли транспортного ключа.
 В библиотеке `libakrypt` данные сертификаты используются для
 открытых ключей, используемых в гибридной схеме шифрования.


 - Бит `dataEncipherment` устанавливается, когда субъектный открытый ключ
 используется для непосредственного шифрования необработанных пользовательских данных без использования
 промежуточного симметричного шифра.
 В библиотеке `libakrypt` сертификаты с даным установленным битом не используются.


 - Бит `keyAgreement` устанавливается, когда открытый ключ субъекта
 используется для аутентификации сторон в протоколах выработки общего ключа.
 Обязательное наличие этого бита предполагается Р 1323565.1.023-2018.


 - Бит `keyCertSign` устанавливается, когда открытый ключ субъекта
 используется для проверки подписей под сертификатами открытых ключей.
 Для корневого сертификата данный бит ДОЛЖЕН быть установлен.


 - Бит `cRLSign` устанавливается при использовании открытого ключа
 для проверки подписей в списках отозванных сертификатов.


 - Значение бита `encipherOnly` не определено при
 не установленном бите `keyAgreement`. Когда оба бита установлены открытый ключ
 может быть использован для шифрования данных при выполнении протокола выработки общих ключей.


 - Значение бита `decipherOnly` не определено при
 не установленном бите `ketAgreement`. Когда оба бита установлены открытый ключ
 может быть использован для расшифрования данных при выполнении протокола выработки общих ключей.


Флаги `encipherOnly` и `decipherOnly` могут присутствовать опционально.
При этом флаги `encipherOnly` и `decipherOnly` не могут присутствовать в расширении `KeyUsage` одновременно.

Пример декодирования расширения `keyUsage`
может выглядеть слеующим образом


    └SEQUENCE┐
             ├OBJECT IDENTIFIER 2.5.29.15 (Key Usage)
             └OCTET STRING
                03 02 00 84
                ├ encoded (4 octets)
                └BIT STRING
                   84


#### Расширение `Basic Constraints`

Расширение определено в RFC 5280 следующим образом.

    id-ce-basicConstraints OBJECT IDENTIFIER ::=  { 2.5.29.19 }

    BasicConstraints ::= SEQUENCE {
        cA                      BOOLEAN DEFAULT FALSE,
        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }


Расширение `Basic Constraints` определяет, является ли данный сертификат самоподписанным,
а также определяет максимальную глубину цепочки сертификации, которая может порождаться
данным сертификатом.

Булева переменная `cA` указывает, можно ли с помощью данного сертификата порождать
цепочки сертификации.

Значение `false` означает, что данный самоподписанный
сертификат открытого ключа не должен использоваться для проверки подписи.
Также, если значение `cA` ложно (`false`), то в расширении `KeyUsage`, если такое присутствует,
не должен бит устанавливаться бит `keyCertSign`.

Поле pathLenConstraint имеет смысл, только если логическое значение cA истинно.
В этом случае поле задает максимальное возможное количество сертификатов  (длину цепочки),
между самоподписанным сертификатом и последним элементом цепочки.
Поле pathLenConstraint, равное нулю, указывает, что
промежуточных сертификатов нет и цепочка
содержит только один сертификат низлежащего уровня.
Если поле не определено, то ограничений нет.

Центр сертификации ДОЛЖЕН включать это расширение во все самоподписанные сертификаты
и ДОЛЖЕН пометить расширение как критическое.
Это расширение МОЖЕТ появиться как критическое или не
критическое расширение в сертификатах центра сертификации,
которые содержат открытые ключи исключительно для целей, отличных от проверки цифровых подписей
под сертификатами.

Пример декодирования расширения `Basic Constraints` может выглядеть следующим образом.


    ├OBJECT IDENTIFIER 2.5.29.19 (Basic Constraints)
    ├BOOLEAN TRUE
    └OCTET STRING
       30 03 01 01 FF
        ├ encoded (5 octets)
        └SEQUENCE┐
                 └BOOLEAN TRUE


#### Расширение ` ... Policies`

