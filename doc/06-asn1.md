Форматы хранения контента с использованием ASN.1 нотации
--------------------------------------------------------

Для локального хранения данных и, при необходимости, передачи данных по каналам связи
в библиотеке поддерживается единый формат хранения контента, основанный на применении ASN.1 нотации для кодирования
данных. Используемый в библиотеке `libakrypt` формат основан на ГОСТ Р ИСО/МЭК 8824-1-2001,
ITU X.509, рекомендациях по стандартизации:

 - Р 50.1.111-2016 "Парольная защита ключевой информации",
 - Р 1323565.1.023-2018 "Использование алгоритмов ГОСТ Р 34.10-2012, ГОСТ Р 34.11-2012 в сертификате,
   списке аннулированных сертификатов (CRL) и запросе на сертификат PKCS #10 инфраструктуры открытых ключей X.509",

а также содержит ряд описываемых далее оригинальных форматов хранения ключевой информации.

Описание элементарных типов ASN.1
=================================

К базовым типам ASN.1, определенным ГОСТ Р ИСО/МЭК 8824-1-2001, относятся

    BOOLEAN
    INTEGER
    BIT_STRING
    OCTET_STRING
    NULL
    OBJECT_IDENTIFIER
    OBJECT_DESCRIPTOR
    EXTERNAL
    REAL
    ENUMERATED
    UTF8_STRING
    SEQUENCE
    SET
    NUMERIC_STRING
    PRINTABLE_STRING
    T61_STRING
    VIDEOTEX_STRING
    IA5_STRING
    UTCTIME
    GENERALIZED_TIME
    GRAPHIC_STRING
    VISIBLE_STRING
    GENERAL_STRING
    UNIVERSAL_STRING
    CHARACTER_STRING
    BMP_STRING

В библиотеке `libakrypt` реализована поддержка указанных типов в объеме, достаточном
для реализации механизмов экспорта/импорта ключевой информации в соответствии с национальными
стандартами и рекомендациями по стандартизации.
Все остальные используемые библиотекой типы данных строятся из базовых типов.

Также в библиотеке реализовано небольшое множество элементарных типов, которые неоднократно
используются при экспорте и импорте разных типов данных.

### Тип Time
Тип `Time`, согласно x509, описывает значение времени.

    Time ::= CHOICE {
      utcTime UTCTime,
      generalTime generalizedTime
    }

### Тип Validity

Тип `Validity` содержит в себе временной интервал действия
ключа и определяется стандартным для x509 образом.

    Validity ::= SEQUENCE {
      notBefore Time,
      notAfter Time
    }

### Тип Resource

Тип `KeyParameters` предназначен для хранения
ресурсов (ограничений) использования ключевой информации и определяется следующим образом.

    KeyParameters ::= SEQUENCE {
       resourceType INTEGER, -- тип ресурса секретного ключа
       resource INTEGER,     -- значение ресурса
       validity Validity     -- временной интервал использования ключа
    }

Тип ресурса секретного ключа должен принимать значения,
определямые константами реализованного в библиотеке перечисления \ref counter_resource_t


Форматы хранения открытых ключей
================================

### Тип AttributeTypeAndValue
### Тип Name

### Тип CertificationRequest

### Тип Certificate


    Certificate  ::=  SEQUENCE  {
         tbsCertificate       TBSCertificate,
         signatureAlgorithm   AlgorithmIdentifier,
         signature            BIT STRING  }


### Используемые расширения сертификата открытого ключа

Расширения добавляются в сертификат открытого ключа начиная с третьей версии.
Общая структура расширения имеет следующий вид.

    Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension

    Extension  ::=  SEQUENCE  {
       extnID      OBJECT IDENTIFIER,
       critical    BOOLEAN DEFAULT FALSE,
       extnValue   OCTET STRING
                   -- contains the DER encoding of an ASN.1 value
                   -- corresponding to the extension type identified
                   -- by extnID
    }

Поле `extnID` определяет идентификатор расширения по которому оно может
быть опознано и декодировано.

Полк `critical` определяет, является ли оно критическим или нет.
Не критические расширения могут не обрабатываться при декодировании сертификата.

Поле `extnValue` содержит значение расширения,
закодированное в виде der-строки. Далее мы опишем типы сообщений,
поддерживаемых библиотекой `libakrypt`.


#### Расширение `SubjectKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.14 }

    SubjectKeyIdentifier ::= OCTET STRING


Расширение `SubjectKeyIdentifier`
представляет механизм идентификации сертификата, содержащего данный открытый ключ.

Стандарт RFC 5280 рекомендует брать
в качестве `SubjectKeyIdentifier` значение функции хеширования от поля `SubjectPublicKey'
(см. выше `tbsCertificate`), содержащего значение открытого ключа.


В библиотеке `libakrypt` в качестве данного идентификатора выступает номер
открытого ключа, формируемый при его создании, т.е.

    ak_verifykey public_key;
    public_key->number;  /* это SubjectKeyIdentifier */


Чтобы облегчить построение пути сертификации, расширение `SubjectKeyIdentifier` ДОЛЖНО
появляются во всех соответствующих сертификатах центра сертификации,
то есть во всех сертификатах, включая содержащие расширение `BasicConstraints`
со значением `cA` равным истине.

Ценр сертификации ДОЛЖЕН помечать это расширение как некритическое.


#### Расширение `AuthorityKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.35 }

    AuthorityKeyIdentifier ::= SEQUENCE {
      keyIdentifier             [0] KeyIdentifier           OPTIONAL,
      authorityCertIssuer       [1] GeneralNames            OPTIONAL,
      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }

    KeyIdentifier ::= OCTET STRING

Расширение `AuthorityKeyIdentifier` обеспечивает средство
идентификации открытого ключа, соответствующего закрытому ключу,
использованному для подписи сертификата.
Другими словами,  расширение `AuthorityKeyIdentifier` позволяет идентифицировать открытый ключ,
с помощью которого можно проверить корректность электронной подписи под данным сертификатом.
Идентификация может быть основана на

 - идентификаторе ключа субъекта (`KeyIdentifier`),
   (это значение помещается в расширение `SubjectKeyIdentifier`
    сертификата верхнего уровня)

 - названии или обобщенном имени эмитента (`authorityCertIssuer`),

 - серийном номере сертификата (`authorityCertSerialNumber`) открытого ключа,
   который должен использоваться для проверки электронной подписи.
   (используется значение `SerialNumber` из `TBSCertificate` сертификата верхнего уровня)

Поле `keyIdentifier` расширения `authorithyKeyIdentifier` ДОЛЖНО
быть включено во все сертификаты, генерируемые соответствующими центрами сертификации,
чтобы облегчить путь поиска цепочки соотвествия.
Для самоподписанного сертификата может быть сделано исключение и
идентификатор ключа авторизации МОЖЕТ быть опущен (поскольку сертификат уже содержит
ключ, с помощью которого можно проверить электронную подпись).

Центр сертификации ДОЛЖЕН помечать это расширение как некритическое.

Пример декодирования расширения `AuthorityKeyIdentifier` выглядит следующим образом.


    └SEQUENCE┐
             ├[0] 5a7bfec75e2dfbc6e4972ebb1c098018c8f2d720
             ├[1]┐
             │   └[4]┐
             │       └SEQUENCE┐
             │                └SET┐
             │                    └SEQUENCE┐
             │                             ├OBJECT IDENTIFIER 2.5.4.3 (CommonName)
             │                             └UTF8 STRING Example
             └[2] 00ce4ccdd344d62dec


#### Расширение `KeyUsage`


#### Расширение `Basic Constraints`

Расширение определено в RFC 5280 следующим образом.

    id-ce-basicConstraints OBJECT IDENTIFIER ::=  { 2.5.29.19 }

    BasicConstraints ::= SEQUENCE {
        cA                      BOOLEAN DEFAULT FALSE,
        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }


Расширение `Basic Constraints` определяет, является ли данный сертификат самоподписанным,
а также определяет максимальную глубину цепочки сертификации, которая может порождаться
данным сертификатом.

Булева переменная `cA` указывает, можно ли с помощью данного сертификата порождать
цепочки сертификации.

Значение `false` означает, что данный самоподписанный
сертификат открытого ключа не должен использоваться для проверки подписи.
Также, если значение `cA` ложно (`false`), то в расширении `KeyUsage`, если такое присутствует,
не должен бит устанавливаться бит `keyCertSign`.

Поле pathLenConstraint имеет смысл, только если логическое значение cA истинно.
В этом случае поле задает максимальное возможное количество сертификатов  (длину цепочки),
между самоподписанным сертификатом и последним элементом цепочки.
Поле pathLenConstraint, равное нулю, указывает, что
промежуточных сертификатов нет и цепочка
содержит только один сертификат низлежащего уровня.
Если поле не определено, то ограничений нет.

Центр сертификации ДОЛЖЕН включать это расширение во все самоподписанные сертификаты
и ДОЛЖЕН пометить расширение как критическое.
Это расширение МОЖЕТ появиться как критическое или не
критическое расширение в сертификатах центра сертификации,
которые содержат открытые ключи исключительно для целей, отличных от проверки цифровых подписей
под сертификатами.

Пример декодирования расширения `Basic Constraints` может выглядеть следующим образом.


    ├OBJECT IDENTIFIER 2.5.29.19 (Basic Constraints)
    ├BOOLEAN TRUE
    └OCTET STRING
       30 03 01 01 FF
        ├ encoded (5 octets)
        └SEQUENCE┐
                 └BOOLEAN TRUE


#### Расширение ` ... Policies`


Формат общего контейнера для хранения данных
============================================
