/* ----------------------------------------------------------------------------------------------- */
/*! \mainpage Аннотация

Библиотека `libakrypt` представляет собой модуль, реализующий криптографические
преобразования для отечественного СКЗИ проекта [OpenSKZI](http://openskzi.ru). Цель данного проекта заключается
в создании СКЗИ с открытым исходным кодом, удовлетворяющего отечественным принципам
разработки и модернизации шифровальных (криптографических) средств защиты информации по классу КС3
(более детально см. [здесь](http://www.tc26.ru/standard/draft/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B_14.11.2016.pdf) ).

Библиотека написана на языке C и реализует механизмы генерации, хранения, экспорта и импорта ключей, а также
основные отечественные криптографические механизмы, регламентированные государственными стандартами
или рекомендациями ТК26 "Криптографическая защита информации", включая:

\li Бесключевые функции хеширования.
    -# Функция хеширования, регламентируемая отечественным стандартом ГОСТ Р 34.11-94
       (в настоящее время стандарт отменен, функция реализована для возможности разбора
       сертификатов открытых ключей).
    -# Функции хеширования Стрибог-256 и Стрибог-512, регламентируемые
       отечественным стандартом ГОСТ Р 34.11-2012.

\li Алгоритмы блочного шифрования данных.
    -# Алгоритм блочного шифрования ГОСТ 28147-89 с длиной блока 64 бита и поддержкой
       различных таблиц замен (в настоящее время, согласно ГОСТ Р 34.12-2015, этот алгоритм
       с фиксированными таблицами замен носит название Магма).
    -# Алгоритм блочного шифрования Кузнечик с длиной блока 128 бит (согласно ГОСТ Р 34.12-2015).

\li Алгоритмы зашифрования/расшифрования сообщений c помощью алгоритмов блочного шифрования
    в следующих режимах (согласно ГОСТ Р 34.13-2015).
    -# Режим простой замены (electronic codebook mode, ЕСВ),
    -# Режим гаммирования (counter mode, CTR),
    -# Режим гаммирования с обратной связью по выходу (output feedback mode, OFB),
    -# Режим простой замены с зацеплением (cipher block chaining mode, СВС),
    -# Режим гаммирования с обратной связью по шифртексту (cipher feedback mode, CFB).

\li Алгоритмы выработки имитовставки (кода аутентичности сообщения)
    -# Алгоритм выработки имитовставки HMAC, использующий отечественные функции
    хеширования Стрибог-256 и Стрибог-512.
    -# Алгоритм выработки имитовставки, регламентированный ГОСТ Р 34.13-2015.

\li Программные и биологические генераторы псевдо-случайных чисел.
    -# Линейный конгруэнтный генератор,
    -# Интерфейс, использующий чтение из произвольных файлов, в частности,
       файловых устройств /dev/random и /dev/urandom.
    -# Интерфейс к системному генератору псевдо-случайных значений в Windows.

Работоспособность библиотеки протестирована на следующих платформа:
\li x86, x64,
\li amd64,
\li armv7,
\li ppc32.

Работоспособность библиотеки протестирована под управлением следующих операционных систем:
\li OC семейства Linux,
\li ОС семейства Windows (от Windows XP и старше)
\li ReactOS.

Библиотека может быть собрана при помощи следующих компиляторов:
\li gcc (в частности mingw под Windows),
\li clang,
\li Microsoft Visual Studio (начиная с версии MSVC10),
\li TinyCC.

\b Внимание: в настоящее время библиотека находится в статусе разработки и не рекомендуется для
реальной защиты обрабатываемой пользователем информации.

*/

/* ----------------------------------------------------------------------------------------------- */
/*! \page compile Инструкция по сборке и установке

\section compile_source_codes Получение исходных текстов библиотеки

Посленяя версия
исходных кодов библиотеки может быть получена из git-репозитория на сайте github.com.
Команда для клонирования репозитория.

\code
 git clone https://github.com/axelkenzo/libakrypt-0.x
\endcode

\section compile_dependence Зависимости библиотеки

Для корректной сборки и выполнения библиотеки Libakrypt необходимо
удовлетворить ряд внешних зависимостей.

\subsection compile_dependence_cmake CMake

Системой сборки для библиотеки Libakrypt является [cmake](https://cmake.org").
Необходимый набор программ и утилит может быть скачан с официального сайта программы.

\subsection compile_dependence_pthreads Pthreads

Библиотека Libakrypt использует многопоточное выполнение некоторых своих
функций, поэтому ей необходим базовый набор функций для работы с потоками.
Библиотека использует стандартный набор функций, определяемый POSIX Threads.

В операционной системе Linux эта функциональность входит в состав библиотеки `libc`.

В операционной системе Windows многопоточность
может быть реализована различными способами, при этом
способ реализации определяется используемым для сборки библиотеки компилятором.

В случае, если для сборки библиотеки используется компилятор `gcc`, входящий в состав набора библиотек и программ `MinGW`,
то доступ к многопоточной функциональности предоставляется средствами `MinGW`.

В случае, если для сборки библиотеки используется компилятор Microsoft Visual C (или любой другой,
в состав которого не входят библиотеки, реализующие многопоточную функциональность),
то необходимо использование разделяемой
библиотеки pthreads-w32 (POSIX Threads Library for Win32).
Перед сборкой библиотеки Libakrypt Вам необходимо вручную установить заголовочные и библиотечные файлы
(`pthreadVC.lib` и `pthreadVC.dll`, а также заголовочные файлы `pthread.h`, `semaphore.h` и `sched.h`).
Более подробно смотри в документации по [pthreads-w32](http://sources.redhat.com/pthreads-win32).


\section compile_make_unix Сборка в Linux

Linux является основной средой разработки библиотеки Libakrypt,
в связи с этим сборка в Linux является максимально простой процедурой.
Скачайте архив с исходными текстами библиотеки вида libakrypt-0.x.tar.bz2 и
сохраните его.
Перейдите в консоли в каталог с сохраненной библиотекой и для разархивации архива с исходными кодами
выполните следующую команду.
\code
tar -xjvf libakrypt-0.x.tar.bz2
\endcode

После ее выполнения должен появиться каталог libakrypt-0.x, где x это
номер текущей версии библиотеки (такой же каталог должен появиться после клонирования
исходных текстов библиотеки из git-репозитория).
Далее, для сборки библиотеки выполните следующую последовательность команд.

\code
mkdir build
cd build
cmake ../libakrypt-0.x
make
\endcode

В результате сборки, по-умолчанию, будет собрана
статическая версия библиотеки --- `libakrypt-static.a`,
а также тестовые примеры, использованные нами в разделе \ref libex.

Для сборки не только статической, но и динамической версии библиотеки --- `libakrypt-shared.so`,
необходимо выполнить команду `cmake` с дополнительными параметрами.

\code
cmake -D LIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
\endcode



\subsection compile_make_compilers Сборка различными компиляторами

Приведенная нами выше последовательность команд использует для сборки библиотеки
компилятор по-умолчанию, то есть `gcc`. Если Вы хотите использовать другой компилятор,
то Вам необходимо передать в вызов `cmake` дополнительные опции.
Так, следующий вызов позволит произвести сборку библиотеки с помощью компилятора `clang`.
\code
cmake -D CMAKE_C_COMPILER=clang ../libakrypt-0.x
\endcode

В приведенной команде для передачи имени компилятора
используется определяемый `cmake` флаг `CMAKE_C_COMPILER`.

Аналогично, следующий вызов позволит произвести сборку библиотеки с помощью
компилятора `tcc` (Tiny C Compiler)
\code
cmake -D CMAKE_C_COMPILER=tcc ../libakrypt-0.x
\endcode

Отметим, что через опцию `CMAKE_C_COMPILER` можно указывать только те компиляторы, которые установлены в Вашей
системе и поддерживаются `cmake`.
Перечень поддерживаемых компиляторов можно найти в документации по `cmake`
(см. раздел cmake-compile-features, supported compilers).

\subsection compile_make_ellcc Сборка под другие платформы

Помимо традиционной сборки, когда библиотека компилируется и выполняется
на одной и той же платформе, можно реализовать процесс сборки, при которой эти платформы различаются.

Мы рассмотрим случай в котором платформой сборки (host system)
является Linux, а платформой выполнения (target system) --- любая другая
операционная система, например, Windows или Linux на ARM Cortex.
Для такой сборки наиболее удобным является компилятор `clang`,
или более точно, его сборка из проекта [ellcc](http://ellcc.org).
В данном проекте компилятору `clang` присвоено имя `ecc`.

Обязательным параметром, который должен передаваться компилятору `ecc`
является платформа (target system), на которой будет выполняться компилируемая программа.
Например, для сборки библиотеки под 64-x битную версию Windows (на архитектуре x64),
можно выполнить следующую команду.

\code
cmake -D CMAKE_C_COMPILER=ecc -D CMAKE_C_FLAGS="-target x86_64-w64-mingw32" -D LIBAKRYPT_EXT=".exe" -D LIBAKRYPT_CONF="C:/Users/Default/AppData/Roaming/libakrypt" ../../libakrypt-0.x
\endcode

Прокомментируем приведенные выше параметры команды `cmake`.

Как и ранее, имя компилятора передается через переменную `CMAKE_C_COMPILER` (в нашем примере это `ecc`),
платформа сборки передаается в `cmake` через переменную `CMAKE_C_FLAGS` (-target x86_64-w64-mingw32).
Параметр `LIBAKRYPT_EXT` (.exe) указывает расширение для исполняемых файлов (это актуально только для Windows),
а параметр `LIBAKRYPT_CONF` - каталог, в котором будет находиться файл с эксплуатационными характеристиками
библиотеки (см. также раздел \ref compile_flags).

\subsection compile_make_install Инсталляция библиотеки

По умолчанию предполагается, что библиотека будет установлена в каталог `/usr/local`.
Для изменения этого каталога
можно передать в `cmake` путь установки в явном виде. Например, следующий вызов позволяет
установить библиотеку в католог `/usr`.
\code
cmake -DCMAKE_INSTALL_PREFIX=/usr ../libakrypt-0.x
\endcode

Для инсталляции библиотеки достаточно выполнить команду

\code
make install
\endcode

\b Внимание. Команда инсталляции библиотеки должна выполняться с правами суперпользователя.

\subsection compile_doc_linux Сборка документации в Linux

В операционной системе Linux Вы можете воспользоваться
готовыми средствами для создания документации к библиотеке Libakrypt.

Если у Вас установлен пакет [Doxygen](http://www.doxygen.org/index.html),
а также установлена система подготовки документации LaTex,
то сборка документации может быть выполнена следующей простой командой.

\code
make doc
\endcode

Данная команда должна выполняться в том же каталоге,
в котором происходила сборка библиотеки. После выполнения команды,
в каталоге сборки должны появиться

- файл `libakrypt-doc-0.x.pdf`, содержащий документацию в формате PDF (файл формируется с помощью системы подготовки
  документации LaTeX),
- файл `libakrypt-0.x.qch`, содержащий документацию в формате QCH (удобно интегрируется в среду разработки QtCreator),
- архив `libakrypt-html-0.x.tar.bz2`, содержащий в архивированном виде
  документацию к библиотеке в формате HTML.


\section compile_make_windows Сборка в Windows

Ранее мы описали способ сборки библиотеки с
использованием компилятора `clang` из проекта `ellcc` (см. раздел \ref compile_make_ellcc).
Этот способ позволяет собирать статические исполняемые файлы,
но не позволяет собрать динамическую библиотеку.

Вместе с тем, библиотека Libakrypt может быть напрямую собрана в операционной системе Windows.
Далее мы приведем описание процесса сборки.


\subsection compile_make_windows_msvc Сборка с использованием компилятора Miscrosoft Visual C
На настоящий момент протестирована успешная
сборка библиотеки с помощью компилятора MSVC версий 10 и старше.

Для сборки библиотеки и тестовых примеров необходимо запустить командную строку Visual Studio и
создать каталог для сборки, например, выполнив команду
\code
mkdir build-msvc
\endcode

Далее, необходимо перейти в созданный каталог и запустить `cmake` для конфигурации сборки.

\code
cmake -G "NMake Makefiles" path
\endcode
где `path` это путь к каталогу, в котором находятся исходные коды библиотеки, например, `../libakrypt-0.x`.
Далее сборка библиотеки и тестовых примеров выполняется следующей командой
\code
nmake
\endcode

Указанный выше пример повзолит создать статическую (.lib) библиотеку и тестовые примеры. Для сборки
динамической (.dll) версии библиотеки необходимо
дополнительно указать соответствующий флаг при вызове `cmake`.

\code
cmake -G "NMake Makefiles" -D LIBAKRYPT_SHARED_LIB=ON path
\endcode

Для запуска тестовых примеров,
собранных с поддержкой динамических библиотек,
необходимо, чтобы созданном Вами каталоге build находился файл pthreadVC2.dll.

\subsection compile_make_windows_mingw Сборка с использованием MinGW
Для сборки компилятором `gcc` Вам необходимо установить набор программ из проекта MinGW.
Далее, в командной строке выполнить следующую последовательность команд.

\code
mkdir build
cd build
cmake -G "MinGW Makefiles" ../libakrypt-0.x
mingw32-make.exe
\endcode

Аналогично сказанному выше, для сборки
динамической библиотеки и тестовых примеров, соранных с поддержкой динамических библиотек,
необходимо выполнить следующую последовательность команд.

\code
mkdir build
cd build
cmake -G "MinGW Makefiles" -D LIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
mingw32-make.exe
\endcode

\section compile_make_hands Сборка своими руками

Иногда может возникнуть ситуация, при которой
использование `cmake` для сборки библиотеки может оказаться невозможным.
Как правило такая ситуация возникает
в случае, когда инсталляция `cmake` невозможна, либо используется незнакомый для `cmake` компилятор языка C.
В таких случаях сборка библиотеки, а также сборка тестовых примеров, возможна из командной строки.

Общая схема командной строки для сборки тестовых примеров проста:

- компилятор
- параметры сборки
- имена файлов
- имя результирующей программы.

Следующий простой вызов из командной строки в Linux
позволяет собрать один из тестовых примеров (в корневом каталоге библиотеки).

\code
gcc -Isource -O3 -DLIBAKRYPT_CONF=\"/etc\" source/*.c examples/example-intro.c -o intro
\endcode

Как мы говорили выше, параметр LIBAKRYPT_CONF пределяет каталог в котором библиотека
будет искать файл с настройками (подробнее смотри в разделе \ref options).
Если данный параметр не указан, то месторасположение файла с настройками будет
выбрано библиотекой самостоятельно.

\section compile_flags Полные перечни флагов сборки библиотеки

\subsection compile_flags_cmake Флаги cmake

Приведем перечень флагов, которые могут передаваться в `cmake` для настройки и уточнения значений
параметров сборки.

\li `LIBAKRYPT_CONF = path` (устанавливает каталог поиска файла libakrypt.conf, содержащего точные
значения технических характеристик библиотеки)

\li `LIBAKRYPT_EXT = extension` (устанавливает расширение для скомпилированных контрольных примеров, используется, как правило,
для установки расширения `.exe` в операционной системе Windows)

\li `LIBAKRYPT_GMP_TESTS = { ON, OFF }` (устанавливает надо или нет собирать тестовые примеры, использующие
вызовы функций библиотеки libgmp; данная функциональность нужна только для тестирования корректности реализации
арифметических операций с вычетами кольца больших целых чисел)

\li `LIBAKRYPT_SHARED_LIB = { ON, OFF }` (устанавливает надо или нет собирать динамическую версию библиотеки, по умолчанию,
флаг равен `OFF`)

\li `LIBAKRYPT_STATIC_LIB = { ON, OFF }` (устанавливает надо или нет собирать статическую версию библиотеки, по умолчанию,
флаг равен `ON`)

\li `LIBAKRYPT_BIG_ENDIAN = { ON, OFF }` (в случае, когда флаг равен ON, используются фрагметны исходного кода для 
выполнения на big-endian архитектуре; по умолчанию, флаг равен `OFF`)

\subsection compile_flags_source Флаги исходных кодов

Приведем полный перечень флагов компиляции, передаваемых при сборке исходных кодов библиотеки и примеров
с помощью директивы `-D`.
В большинстве случаев, поиск и установка флагов выполняется программой cmake.

\li `LIBAKRYPT_OPTIONS_PATH = path` (устанавливает каталог для поиска файла libakrypt.conf, содержащего точные
значения технических характеристик библиотеки)
\li `LIBAKRYPT_VERSION = version` (устанавливает номер библиотеки)
\li `LIBAKRYPT_HAVE_SYSLOG_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `syslog.h`)
\li `LIBAKRYPT_HAVE_UNISTD_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `unistd.h`)
\li `LIBAKRYPT_HAVE_FCNTL_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `fcntl.h`)
\li `LIBAKRYPT_HAVE_LIMITS_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `limits.h`)
\li `LIBAKRYPT_HAVE_GETOPT_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `getopt.h`)
\li `LIBAKRYPT_HAVE_SYSMMAN_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `sys/mman.h`)
\li `LIBAKRYPT_HAVE_SYSSTAT_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `sys/stat.h`)
\li `LIBAKRYPT_BIG_ENDIAN` (указывает на то, что при компиляции необходимо использовать фрагменты кода для
выполнения на big-endian архитектуре)

*/

/* ----------------------------------------------------------------------------------------------- */
/*! \page libex Правила использования библиотеки

В настоящей главе мы приводим рекомендации по использованию и встраиванию библиотеки libakrypt
в программные средства. Рекомендации оформлены в виде примеров,
иллюстрирующих основные функциональные особенности библиотеки.

Перечень экспортируемых библиотекой констант, типов данных и функций содержится в заголовочном
файле `libakrypt.h`. Для встраивания библиотеки должны использоваться только экспортируемые функции.
Вызов не экспортируемых функций библиотеки считается недопустимым и не должен применяться при
использовании библиотеки.

\section tinit Инициализация и настройка библиотеки

\subsection tinit_libex1 Пример инициализации библиотеки

Перед тем, как вызывать какие-либо функции библиотеки, необходимо провести ее инициализацию.
Для этого предназначена функция ak_libakrypt_create() - она выполняет проверку корректности работы
криптографических механизмов и инициализирует внутренние переменные библиотеки.

Простейшая программа (\ref example-intro.c), использующая библиотеку,
должна выглядеть следующим образом.

\include examples/example-intro.c

Используемая нами для инициализации библиотеки функция ak_libakrypt_create() принимает один параметр,
а именно, указатель на функцию, которая используется для вывода сообщений о работе или ошибках библиотеки.
В заголовочном файле `libakrypt.h` содержится перечень из нескольких заранее предопределенных функций,
предназначенных для вывода сообщений.

\code
 int ak_function_log_stderr( const char * );
#ifdef __linux__
 int ak_function_log_syslog( const char * );
#endif
\endcode

Функция ak_function_log_stderr() использует для вывода сообщений стандартный поток вывода ошибок операционной системы.
Реализация данной функции доступна для всех операционных систем.

Функция ak_function_log_syslog() использует для вывода сообщений демон операционной системы Linux,
предназначенный для журналирования событий в системе. Реализация данной функции доступна только
в операционной системе Linux.

Пользователь может самостоятельно определить и использовать свою собственную функцию
вывода сообщений об ошибках. Для этого он должен реализовать функцию, удовлетворяющую следующему определению

\code
// Функция аудита
 typedef int ( ak_function_log )( const char * );
\endcode

Принципы, на которых основан отбор выводимых сообщений, мы опишем позднее в разделе \ref construction_audit.

Завершение работы с функциями библиотеки должно производиться
при помощи вызова функции ak_libakrypt_destroy(). Данная функция останавливает внутренние механизмы
и освобождает используемую библиотекой память.

\subsection tinit_libex2 Пример установки пользовательской функции аудита
Пользователь библиотеки libakrypt может настроить вывод сообщений библиотеки
удобным для него способом. Далее мы приведем простой пример (\ref example-log.c)
в котором используется функция ak_log_set_function(). Эта функция
устанавливает пользовательскую функцию аудита.

\include examples/example-log.c

Обратим внимание на то, что
вывод сообщений производится с помощью функции ak_log_set_message().

\section trandom Генерация псевдо-случайных чисел

\section thash Хэширование информации

\section tencrypt Шифрование информации

\section tsignature Выработка и проверка электронной подписи

\section toid Идентификаторы криптографических механизмов

Идентификатор (Object IDentifier, OID) это уникальная последовательность чисел, разделенных точками.
OID'ы могут быть присвоены любому криптографическому механизму (алгоритму,
схеме, протоколу), а также параметрам этих механизмов.
Использование идентификаторов позволяет однозначно определять тип криптографического механизма или
значения его параметров на этапе выполнения программы, а также
однозначно связывать данные или функции с криптографическими алгоритмами.

Значения OID реализуются с помощью класса \ref oid,
конкретная реализация которого скрыта от пользователя библиотеки и может меняться от версии к версии.
Каждый объект класса \ref oid  содержит в себе:
\li читаемое (пользователем библиотеки) имя OID,
\li идентификатор OID (последовательность чисел, разделенных точками),
\li тип криптографического механизма (тип \ref ak_oid_engine),
    в качестве которого может выступать алгоритм или параметры алгоритма,
\li режим использования криптографического алгоритма (тип \ref ak_oid_mode).

Для пользователя библиотеки механизм OID'ов позволяет унифицировать вызов криптографических механизмов,
определяя факт существования того или иного алгоритма на этапе выполнения программы (см., например, \ref example-hash-oid.c).
Кроме того OID'ы активно используются при передаче данных с использованием форматов сообщений, определяемых ASN.1 нотацией,
например, в сертификатах открытых ключей.

Пользователю библиотеки доступ к OID'ам библиотеки возможен только через механизм дескрипторов.
Приведем несколько примеров использования этого механизма.

\subsection toid_ex1 Получение перечня всех доступных идентификаторов библиотеки

Нижеследующая программа (\ref example-oid.c) позволяет вывести список всех
существующих OID'ов библиотеки.

\include examples/example-oid.c

Поясним, что для поиска всех однотипных криптографических механизмов,
например, алгоритмов блочного шифрования,
используется следующая простая конструкция.

\code
 ak_oid_engine engine = block_cipher; // будем искать только блочные шифры
 ak_handle handle = ak_oid_find_by_engine( engine );

   while( handle != ak_error_wrong_hadle ) {
     handle = ak_oid_findnext_by_engine( handle, engine );
   }
\endcode

В приведенном ранее тексте программы \ref example-oid.c
для поиска используется значение `engine = undefined_engine`. Такое значение
позволяет получить значения всех существующих в библиотеке OID криптографических механизмов.

Переменная `handle` является десткриптором найденного значения OID
и может быть использована для получения информации. Текущая версия библиотеки
предоставляет пользователю ряд интерфейсных функций, в частности, следующие.

\li  ak_oid_get_name() - функция возвращает пользователю имя OID (строку символов, содержащую
понятное человеку название на английском языке), как правило, имя соответствует распространенному названию алгоритма
или содержит номер стандарта, которым данный алгоритм регламентируется.
\li ak_oid_get_id() - функция возвращает пользователю идентификатор (строку, состоящую из чисел, разделенных точками),
точное значение идентификатора определяется либо регламентирующими документами ТК 26 "Криптографическая защита информации",
либо предлагаются разработчиками СКЗИ в своих средствах.

\li ak_oid_get_engine() - функция возвращает тип криптографического механизма, содержащийся в OID.
\li ak_oid_get_mode() - функция возвращает режим использования криптографического механизма,
например, режим шифрования для блочного шифра.

Отметим, что полный перечень доступных типов криптографических механизмов (класс \ref ak_oid_engine),
режимов их использования (класс \ref ak_oid_mode) и функций для работы с OID содержится в файле `libakrypt.h`.


\subsection toid_ex2 Добавление новых идентификаторов в библиотеку

*/


/* ----------------------------------------------------------------------------------------------- */
/*! \page construction Принципы и механизмы реализации библиотеки

В этой главе мы опишем основные принципы, которые были использованы при создании исходных текстов библиотеки,
а также приведем описание способов их реализации. Мы начнем с некоторого формализма и
дадим определения используемых нами терминов.

\section construction_glossary Терминология

- \b Класс (class) - структура, определенная через typedef и содержащая в себе данные и указатели на функции,
обрабатывающие данные, хранящиеся в структуре. Один класс может соотвествовать нескольким однотипным
криптографическим механизмам, допускающим схожую программную реализацию.

- \b Объект (object) - область памяти (экземпляр класса), однозначно связанная с конкретным
криптографическим механизмом.

- \b Контекст (context) - указатель на объект заданного класса, однозначно с ним связанный.
Контекст может быть определен только в случае, когда существует связанный с ним объект.
В противном случае контекст обязан принимать значение NULL.

- \b Дескриптор (handle) - натуральное число, являющееся идентификатором конкретного объекта и
обеспечивающее доступ к объекту по его контексту.

- \b Производящая \b функция - реализованная в библиотеке функция, создающая объекты заданного класса.

\section construction_names Принципы наименования функций библиотеки.

Для всех функций библиотеки принят единый принцип наименования.
Имя функции строится следующим образом

\code
  ak_класс_действие
  ak_класс_действие_объект
  ak_класс_действие_предлог_действие2
\endcode

где

\li `ak`        - префикс библиотеки,
\li `класс`     - класс, над объектами которого производятся заданные действия,
\li `действие`  - основное действие над объектом,
\li `действие2` - следующее действие над объектом,
\li `предлог`   - направление действия,
\li `объект`    - объект, на который направлено действие, либо объект,
                являющийся параметром действия.

\subsection construction_names_rules Основные действия

При выборе имен функций использовались следующие основные действия.

\li  `create`    - определить поля существующего объекта заданного класса
                 (по сути, это действие реализует конструктор объекта, под который уже
                 выделена память - статическая или динамическая)
\li  `new`       - создать указатель на объект и определить его поля
                 (функция, которая сначала выделяет динамическую память под объект,
                  а потом вызывает для этой области памяти конструктор - действие create)
\li  `destroy`   - очитить поля существующего объекта (функция реализует деструктор для
                 объекта размещенного в памяти - динамической или статической)
\li  `delete`    - уничтожить указатель на объект и очистить его поля
                 (функция вызывает деструктор для заданного указателя на объект, а после освобождает выделенную память)
\li  `set`       - присвоить объекту некоторое значение
\li  `get`       - получить характеристику объекта (значение некоторого поля) без ее изменения,
                 как правило данное действие возвращает копию значения, хранящегося в объекте.

\subsection construction_names_to Предлоги

\li `to`        - действие направлено от объекта к объекту2 (в большинстве случаем использование предлога to
                означает процедуру преобразования объекта, в результате которой создается новый объект,
                удаление которого, как правило, возлагается на пользователя биьлиотеки).
\li `from`      - действие направлено к объекту от объекта2 (в большинстве случаев
                функция реализует операцию присвоения нового значения объекту)
\li `and`       - предлог для связи нескольких действий над объектом

\subsection construction_names_order Порядок следования аргументов функции

\li  `арг1`      - первый аргумент это объект, с которым выполняется указанное действие
                 (во всех арифметических функциях - являющийся результатом действия)
\li  `арг2`, ... - объекты, участвующие в действии

\section construction_principles Принципы создания исходных текстов библиотеки.

Для максимального обеспечения безопасности исполняемого кода при выполнении функций библиотеки
нами использовался приводимый далее набор принципов. Данные принципы должны соблюдаться при модификации библиотеки и
расширении ее функциональных возможностей.

- Следование стандарту С99 и максимальная кросс-платформенность. Исходные тексты, включаемые в состав библиотеки,
должны быть успешно скомпилированы и корректно исполнены для максимально возможного
числа компиляторов языка С и операционных систем.

- Минимально возможное использование внешних зависимостей и библиотек.

- Минимальное включение кода, то есть исключение из тела библиотеки фрагментов исходных текстов, которые реально
не используются или предоставляют мало востребованный пользовательский интерфейс.

- Создание объекта конкретного класса возможно только с помощью производящей функции.
Любой другой механизм создания объектов считается недопустимым.

- Описание конкретной реализации класса (полей структуры, типов, используемых при описании ее данных,
перечень функций обработки данных) не экспортируется и не должно быть использовано за
пределами исходных текстов библиотеки.

- В случае, если некоторая функциональность не может быть реализована без использования
неэкспортируемых типов данных и функций, то данная функциональность должна быть включена в состав библиотеки
в соответствии с данными принципами.

- Механизмы работы с контекстами (указателями на созданные в ходе выполнения кода библиотеки объекты)
не экспортируются.

- Для доступа к объектам, создаваемым библиотекой, используется механизм дескрипторов,
которые однозначно связываются с конкретными объектами.

- Значение дескриптора не должно нести в себе какой-либо информации о типе или каких-либо других характеристиках
объекта с которым связан дескриптор. Данная информация должна предоставляться пользователю
с помощью интерфейсных функций.

- При старте библиотеки должен производиться контроль ее работоспособности для всех реализованных
криптографических механизмов.

- При завершении работы библиотека должна самостоятельно контролировать очистку оперативной памяти,
выделенной в процессе ее работы.

- Библиотека должна вести аудит (документирование) возникающих в ходе ее выполнения ошибок исполнения программы.

- Максимальное документирование исходных текстов, включая не только описание аргументов
функций и возвращаемых значений, а также описание принципов реализации конкретных криптографических алгоритмов.
В документацию также должны включаться рекомендации по расширению функциональных возможностей библиотеки.

\section construction_classes Принципы создания классов

В начале мы создаем функции create, destroy и delete (последняя использует free) ---
общие для всех потомков (например ak_randon

- потом для конкретного класса (наследника, например, ak_random_lcg )
  функция create (ak_random_create_lcg)

- потом интерфейсные функции
  (ak_random_new_handle -> ak_random_new_lcg (winrtl, file, oid ) - создаем
  ak_random_ptr - реализуем функционал

\section construction_generators Датчики случайных чисел

 Три типа ПДСЧ, биологические и физические

 в библиотеке: реализация ПДСЧ
   интерфейсы к биологическим датчикам
   интерфейсы к физическим в настоящее время не реализованы

\section construction_hash Функции хэширования

\section construction_keys Ключевая иерархия и менеджмент ключей

\section construction_block_cipers Блочные шифры

\section construction_mac Алгоритмы выработки имитовставки

\section construction_update Механизм итерационного сжатия

\section construction_context Реализация дескрипторов и механизма работы с контекстами

Механизм декскрипторов позволяет реализовать
несколько важных требований к средству криптографической защиты информации, в частности,
следующие.

\li Реализация СКЗИ должна предусматривать защиту от возможных непреднамеренных действий пользователя,
не предусмотренных правилами и приводящих к возможности нарушения работы СКЗИ.

\li В СКЗИ долна быть реализована система защиты от несанкционированного доступа к ключевой и криптографически
опасной информации.

Таким образом, использование дескрипторов - обезличенных значений,
не содержащих ни какой информации о тех объектах, с которыми они связаны,
позволяет оградить пользователя от соблазна осознанно или по неопытности
изменить информацию, которая содержится в объектах, с которыми он работает,
в первую очередь, ключевую информацию.

\subsection construction_context_manager Менеджер контекстов

Дескриптор определяется как объект класса \ref ak_handle (в текущей реализации это 64-х битное число).
Реализация механизма дескрипторов выглядит следующим образом.

В библиотеке содержится класс \ref context_manager (структура управления контекстами),
который представляет из себя массив указателей на контексты библиотеки.
В данный массив может быть помещен любой контекст, для которого определено действие
delete (см. раздел \ref construction_names).
Создаваемый в ходе выполнения функции ak_libakrypt_create()
объект класса \ref context_manager используется для хранения всех объектов библиотеки.

В структуре управления контекстами вместе с контекстом хранится его символьное описание,
тип криптографического механизма и флаги,
позволяющие определить факт изменения содержимого контекста.
Технически это означает, что массив содержит указатели на объекты
класса \ref context_node, которые, в свою очередь, содержат указатели на созданные
контексты, а также на их параметры (символьное описание, тип контекста и т.п.).
При этом, структура управления контекстами предоставляет пользователю
интерфейс для получения указанных параметров.

Следующий простой пример иллюстрирует механизм создания
объектов класса \ref context_node и их удаление.

\include examples/example-context-manager-node.c

Поскольку контексты могут создаваться только производящими функциями,
то создание контекста происходит с его одновременным помещением в структуру
управления контекстами и возвращением пользователю
значения дескриптора, однозначно связанного с созданным контекстом.

Связь контекста с его дескриптором происходит следующим образом. В начале созданный контекст
помещается в массив указателей. При помещении ищется наименьший индекс массива, равный `NULL`,
в который и помещается созданный контекст. В случае, если массив полон,
с помощью вызова функции ak_context_manager_morealloc() производится выделение
дополнительной памяти.

После нахождения индекса, контекст записывается по данному адресу,
а сам адрес зашифровывается с помощью блочного алгоритма шифрования Магма
в режиме простой замены. Значение шифртекста и является значением дескриптора.

Функциями, реализующими процедуры преобразования индекса в дескриптор и обратно являются ak_context_manager_idx_to_handle()
и ak_context_manager_handle_to_idx().

Отметим, что при шифровании используется случайный ключ шифрования, создаваемый в момент вызова
функции ak_context_manager_create().

Следующий пример иллюстрирует создание структуры управления контекстами,
отличной от используемой библиотекой по-умолчанию,
а также процедуры помещения и удаления объектов класса \ref buffer,
создаваемых пользователем.

\include examples/example-context-manager.c

Важной особенностью структуры управления контекстами
является то, что она при своем уничтожении (вызове действия destroy)
самостоятельно удаляет хранящиеся в ней контексты. Это позволяет
обеспечить контроль за освобождением созданной памяти,
а также, например, за необходимостью сохранения изменившейся ключевой информации
или выполнения другой необходимой функциональности, которая забыта пользователем.


\section construction_audit Аудит

В библиотеке libakrypt реализован механизм аудита - вывода сообщений
о выполняемых библиотекой действиях. В настоящее время реализовано три уровня аудита.

\li минимальный (\ref ak_log_none),
\li стандартный (\ref ak_log_standard),
\li максимальный (\ref ak_log_maximum).

На минимальном уровне выводятся сообщения об ошибках, возникающих в процессе выполнения функций
библиотеки. Коды (численные значения) возможных ошибок могут быть найдены в файле \ref libakrypt.h.
Помимо сообщений об ошибках на минимальном уровне выводится сообщение о корректном
тестировании и завершении работы всех криптографических механизмов, реализуемых библиотекой
(тестирование происходит в процессе выполнения функций ak_libakrypt_create() и ak_libakrypt_destroy()).

На стандартном уровне аудита выводятся все сообщения, которые выводятся на минимальном уровне,
а также сообщения о фактах использования ключевой информации. К таким фактам относятся

\li факты создания секретных ключей,
\li факты удаления секретных ключей,
\li ввод секретных ключей с внешних носителей,
\li запись секретных ключей на внешние носители и т.п.

На максимальном уровне аудита выводятся все сообщения, которые выводятся на стандартном уровне,
а также отладочные сообщения, позволяющие понять логику работы ряда функций.
Так, выводятся сообщения о процессе тестирования, с кратким описанием тестов и
результатами их выполнения, а также сообщения об изменении эксплуатационных
характеристик библиотеки или о самостоятельном выборе криптографических преобразований.

\subsection construction_audit_use Использование аудита при написании исходных текстов библиотеки

Подробный пример определения функции, реализующей вывод сообщений о выполняемых библиотекой действиях, приводится
в разделе \ref tinit_libex1.

В ходе выполнения программы, использующей библиотеку libakrypt,
пользователь может узнать установленный для него уровень аудита. Для этого библиотекой
экспортируется функция ak_log_get_level(), возвращающая одно из трех указанных выше значений.

Установка уровня аудита из программ, использующих библиотеку libakrypt, запрещена.
Уровень аудита относится к контролируемым характеристикам СКЗИ.
Его значение содержится в файле `libakrypt.conf` и считывается перед началом тестирования
криптографических механизмов. За уровень аудита в файле `libakrypt.conf` отвечает
переменная log_level, которая может принимать значения \ref ak_log_none,
\ref ak_log_standard или \ref ak_log_maximum.

Вместе с тем, исходные коды библиотеки libakrypt содержат неэкспортируемую функцию
ak_log_set_level(), которая позволяет изменять текущий уровень аудита. Использование
данной функции возможно только внутри исходных текстов библиотеки.

Более подробно о контролируемых характеристиках СКЗИ рассказывается в следующем
разделе \ref construction_options.

\section construction_options Технические характеристики

Согласно отечественным требованиям к СКЗИ, для средств криптографической защиты информации класса КС3
необходима роль администратора, устанавливающего различные эксплуатационные и технические характеристики СКЗИ.
Перечень таких характеристик содержится в инсталлируемом вместе с библиотекой файле `libakrypt.conf`.

В процессе тестирования криптографических механизмов функция ak_libakrypt_create() проверяет
наличие файла `libakrypt.conf` и, в случае его отсутствия, прекращает работу библиотеки.

При инсталляции файла `libakrypt.conf` ему присваиваются права,
позволяющие считывать хранящиеся в нем значения всем пользователям. При этом запись в файл
и изменение хранящихся в нем значений разрешается только администратору (суперпользователю).

\subsection construction_options_list Перечень технических характеристик

В настоящее время в файле `libakrypt.conf` содержатся следующие технические характеристики.

\li `log_level` - константа, определяющая уровень аудита библиотеки. Данная константа может принимать
значения, перечисляемые константами \ref ak_log_none, \ref ak_log_standard, \ref ak_log_maximum.
Более подробно об аудите библиотеки libakrypt изложено в разделе \ref construction_audit.

После выполнения функции ak_libakrypt_create() значение данной константы  хранится в поле `log_level`
неэкспортируемого статического объекта \ref libakrypt_options. Получить это значение можно с помощью
вызова неэкспортируемой  функции ak_log_get_level().


\subsection construction_options_conf Месторасположение файла libakrypt.conf

Месторасположение файла `libakrypt.conf` может устанавливаться при сборке исходных текстов библиотеки libakrypt -
в этот момент можно задать каталог расположения файла в явном виде, указав его значение
с помощью переменной LIBAKRYPT_CONF. Например, следующий фрагмент кода
позволяет поместить файл `libakrypt.conf` в каталог /opt.

\code
cmake -DLIBAKRYPT_CONF=/opt ../libakrypt-0.x
\endcode

По умолчанию, значение переменной `LIBAKRYPT_CONF` определяется в зависимости
от используемой операционной системы.

В операционной системе Linux
программа `cmake` устанавливает значение переменной `LIBAKRYPT_CONF` равным `\etc`.
При этом флагами сборки данное значение может быть изменено (см. также раздел \ref compile_flags).

*/
/* ----------------------------------------------------------------------------------------------- */
