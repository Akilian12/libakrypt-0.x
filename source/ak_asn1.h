/* ----------------------------------------------------------------------------------------------- */
// ITU-T X.690 TELECOMMUNICATION (07/2002) STANDARDIZATION SECTOR OF ITU
// ISO/IEC 8825-1:2003 (E)
// ГОСТ Р ИСО/МЭК 8825-1:2003
/* ----------------------------------------------------------------------------------------------- */

#ifndef __AK_ASN1_H__
#define __AK_ASN1_H__

/* ----------------------------------------------------------------------------------------------- */
 #include <libakrypt.h>
 #include <ak_mpzn.h>

/* ----------------------------------------------------------------------------------------------- */
#ifdef LIBAKRYPT_HAVE_STDIO_H
 #include <stdio.h>
#else
 #error Library cannot be compiled without string.h header
#endif

/* ----------------------------------------------------------------------------------------------- */
/* Флаги, определяющие класс данных ASN.1. */
 #define UNIVERSAL           0x00u
 #define APPLICATION         0x40u
 #define CONTEXT_SPECIFIC    0x80u
 #define PRIVATE             0xC0u

/* ----------------------------------------------------------------------------------------------- */
/* Флаг, определяющий структуру блока данных ASN.1. */
 #define PRIMITIVE           0x00u
 #define CONSTRUCTED         0x20u

/* ----------------------------------------------------------------------------------------------- */
/* Номера стандартных тегов ASN.1. */
 #define TEOC                0x00u
 #define TBOOLEAN            0x01u
 #define TINTEGER            0x02u
 #define TBIT_STRING         0x03u
 #define TOCTET_STRING       0x04u
 #define TNULL               0x05u
 #define TOBJECT_IDENTIFIER  0x06u
 #define TOBJECT_DESCRIPTOR  0x07u
 #define TEXTERNAL           0x08u
 #define TREAL               0x09u
 #define TENUMERATED         0x0Au
 #define TUTF8_STRING        0x0Cu
 #define TSEQUENCE           0x10u
 #define TSET                0x11u
 #define TNUMERIC_STRING     0x12u
 #define TPRINTABLE_STRING   0x13u
 #define TT61_STRING         0x14u
 #define TVIDEOTEX_STRING    0x15u
 #define TIA5_STRING         0x16u
 #define TUTCTIME            0x17u
 #define TGENERALIZED_TIME   0x18u
 #define TGRAPHIC_STRING     0x19u
 #define TVISIBLE_STRING     0x1Au
 #define TGENERAL_STRING     0x1Bu
 #define TUNIVERSAL_STRING   0x1Cu
 #define TCHARACTER_STRING   0x1Du
 #define TBMP_STRING         0x1Eu

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Биты, определяющие класс данных */
 #define DATA_CLASS(x)     ((x) & 0xC0)
/*! \brief Бит, определяющий структуру данных */
 #define DATA_STRUCTURE(x) ((x) & 0x20)
/*! \brief Биты, определяющие номер тега */
 #define TAG_NUMBER(x)     ((x) & 0x1F)

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Длина тега (текущая реализация поддерживает кодирование
 *         и декодирование тегов, представленных одним байтом) */
 #define TAG_LEN 1

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Указатель на примитивный элемент дерева ASN1 нотации */
 typedef struct tlv *ak_tlv;
/*! \brief Указатель на один уровень дерева ASN1 нотации */
 typedef struct asn1 *ak_asn1;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Класс, реализующий двусвязный список указателей                                         */
 typedef struct asn1 {
   /*! \brief указатель на текущий узел списка */
    ak_tlv current;
   /*! \brief количество содержащихся узлов в списке (одного уровня) */
    size_t count;
 } *ak_asn1;

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Структура, определяющая элемент дерева ASN1 нотации
    \details ASN1 дерево представляется в памяти двусвязным списком узлов (tlv структур), образующих
    один уровень. При этом, каждый узел может быть:
     - примитивным, содержащим данные, для которых определены стандартные процедуры кодирования и
       декодирования,
     - составным, представляющим собой двусвязный список узлов следующего уровня;
       составные узлы позволяют образовывать произвольные типы данных, отличные от стандартных;
       процедуры кодирования/декодирования составных узлов сводятся к последовательному применению
       процедур для стандартных типов.                                                             */
/* ----------------------------------------------------------------------------------------------- */
 struct tlv
{
 /*! \brief тег, идентифицирующий данные. */
  ak_uint8 tag;
 /*! \brief длинна данных. */
  ak_uint32 len;
 /*! \brief объединение, определяющее способ представления данных (примитивный или составной), а также сами данные
     \details примитивные данные это не имеющий потомков  элемент дерева, для которого определены функции
     кодирования и декодирования, такие данные не содержат в себе длину и тип. */
  union {
   /*! \brief указатель на примитивные, закодированые по правилам ASN.1 данные */
    ak_uint8* primitive;
   /*! \brief указатель на составные данные, представляющие собой двусвязный список следующего уровня */
    ak_asn1 constructed;
  } data;
 /*! \brief флаг, определяющий, должен ли объект освобождать память из под данных, которыми управляет */
  bool_t free;

 /*! \brief указатель на предыдущий элемент списка. */
  ak_tlv prev;
 /*! \brief указатель на следующий элемент списка. */
  ak_tlv next;
};

/* ----------------------------------------------------------------------------------------------- */
/*! Определение количества байт, необходимых для кодирования длины элемента ASN1 дерева. */
 ak_uint8 ak_asn1_get_length_size( const size_t );
/*! Получение символьного (человекочитаемого) описания типа примитивного элемента ASN1 дерева. */
 const char* ak_asn1_get_tag_description( ak_uint8 tag );
/*! \brief Получение из DER-последовательности тега для текущего узла ASN1 дерева. */
 int ak_asn1_get_tag_from_der( ak_uint8** , ak_uint8 *p_tag );
/*! \brief Получение из DER-последовательности длины текущего узла ASN1 дерева. */
 int ak_asn1_get_length_from_der( ak_uint8** , size_t * );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Создание примитивного узла ASN1 дерева. */
 int ak_tlv_context_create_primitive( ak_tlv , ak_uint8 , size_t , ak_pointer , bool_t );
/*! \brief Создание составного узла ASN1 дерева. */
 int ak_tlv_context_create_constructed( ak_tlv , ak_uint8 , ak_asn1 );
/*! \brief Уничтожение примитивного узла ASN1 дерева. */
 int ak_tlv_context_destroy( ak_tlv );
/*! \brief Уничтожение примитивного узла ASN1 дерева и освобождение памяти. */
 ak_pointer ak_tlv_context_delete( ak_pointer );
/*! \brief Вывод информации о заданном узле ASN1 дерева. */
 int ak_tlv_context_print( ak_tlv , FILE * );
/*! \brief Вывод информации о примитивном узле ASN1 дерева. */
 int ak_tlv_context_print_primitive( ak_tlv, FILE * );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Получение булевого значения, хранящегося в заданном узле ASN1 дерева. */
 int ak_tlv_context_get_bool( ak_tlv , bool_t * );
/*! \brief Получение беззнакового, 32-х битного значения, хранящегося в заданном узле ASN1 дерева. */
 int ak_tlv_context_get_uint32( ak_tlv , ak_uint32 * );
/*! \brief Получение указателя на последовательность октетов, хранящуюся в заданном узле ASN1 дерева. */
 int ak_tlv_context_get_octet_string( ak_tlv , ak_pointer *, size_t * );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Создание одного уровня ASN1 дерева. */
 int ak_asn1_context_create( ak_asn1 );
/*! \brief Перемещение к следующему узлу текущего уровня ASN1 дерева. */
 bool_t ak_asn1_context_next( ak_asn1 );
/*! \brief Перемещение к предыдущему узлу текущего уровня ASN1 дерева. */
 bool_t ak_asn1_context_prev( ak_asn1 );
/*! \brief Перемещение к последнему узлу текущего уровня ASN1 дерева. */
 bool_t ak_asn1_context_last( ak_asn1 );
/*! \brief Перемещение к первому узлу текущего уровня ASN1 дерева. */
 bool_t ak_asn1_context_first( ak_asn1 );
/*! \brief Уничтожение текущего узла с текущего уровня ASN1 дерева. */
 bool_t ak_asn1_context_remove( ak_asn1 );
/*! \brief Уничтожение текущего уровня ASN1 дерева. */
 int ak_asn1_context_destroy( ak_asn1 );
/*! \brief Уничтожение текущего уровня ASN1 дерева и освобождение памяти. */
 ak_pointer ak_asn1_context_delete( ak_pointer );

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Добавление нового узла к текущему уровню ASN1 дерева. */
 int ak_asn1_context_add_tlv( ak_asn1 , ak_tlv );
/*! \brief Добавление к текущему уровню уровню ASN1 дерева булева значения. */
 int ak_asn1_context_add_bool( ak_asn1 , const bool_t );
/*! \brief Добавление к текущему уровню уровню ASN1 дерева целого числа, представимого в виде
    беззнакового 32-х битного значения. */
 int ak_asn1_context_add_uint32( ak_asn1 , const ak_uint32 );
/*! \brief Добавление к текущему уровню уровню ASN1 дерева большого целого числа, представимого
    в виде объекта класса \ref ak_mpzn */
 int ak_asn1_context_add_mpzn( ak_asn1 , const ak_uint64 * , const size_t );
/*! \brief Добавление к текущему уровню уровню ASN1 дерева узла, содержащего произвольную
    последовательность октетов */
 int ak_asn1_context_add_octet_string( ak_asn1 , const ak_pointer , const size_t );

/*! \brief Добавление к текущему уровню уровню ASN1 дерева низлежащего уровня */
 int ak_asn1_context_add_asn1( ak_asn1 , ak_uint8 , ak_asn1 );
/*! \brief Вывод информации о текущем уровне ASN1 дерева. */
 int ak_asn1_context_print( ak_asn1 , FILE * );
/*! \brief Декодирование ASN1 дерева из заданной DER-последовательности октетов. */
 int ak_asn1_context_decode( ak_asn1 , const ak_pointer , const size_t );

#endif
/* ----------------------------------------------------------------------------------------------- */
/*                                                                                      ak_asn1.h  */
/* ----------------------------------------------------------------------------------------------- */
