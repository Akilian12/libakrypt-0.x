# Принципы реализации

В настоящей главе мы опишем принципы и механизмы реализации мер по защите информации,
использованные при создании исходных текстов библиотеки `libakrypt`.
При рассмотрении возможной модели поведения нарушителя,
то есть субъекта от которого  обеспечивается защита,
мы выбрали возможности, изложенные в методических рекомендациях
Р 1323565.1.012-2017
«Информационная технология. Криптографическая защита информации.
Принципы разработки и модернизации шифровальных (криптографических) средств защиты информации».

Это привело к необходимости обеспечить защиту по следующим направлениям:

* перехват информации, передаваемой по открытым каналам связи или хранимой в открытом доступе;
это приводит к необходимости шифровать сетевой трафик и зашифровывать хранящиеся и передаваемые по сети файлы;

* защита от непредсказуемых ошибок аппаратного обеспечения; это приводит к необходимости
контролировать целостность информации в процессе ее обработки, а также реализовывать меры
по маскированию криптографически опасной информации на случай незапланированного нарушения эксплуатации
аппаратных средств
и сброса ключевой информации на диск в незашифрованном виде;

* защита от перехвата излучений и сигналов, вырабатываемых программными и аппаратными средствами,
на которых выполняется защита информации; это приводит к необходимости реализации мер защиты как от временных атак
на исполняемый код, так и защите от побочных излучений по электро-магнитным каналам утечки информации (ПЭМИН);

* защита от преднамеренных действий пользователя, направленных на
искажение обрабатываемой информации, определение используемой ключевой информации или
нарушение логики работы функций библиотеки;

* ведение аудита выполненных библиотекой криптографических преобразоований и защита файлов аудита от
преднамеренных или непреднамеренных искажений.


Для обеспечения защиты по указанным направлениям и обеспечения
безопасности защищаемой информации
и исполняемого кода, мы сформулировали и реализовали
ряд технических и организационных принципов разработки исходных текстов.
Данные принципы должны соблюдаться при модификации библиотеки и
расширении ее функциональных возможностей.

### Состав исходных текстов библиотеки

1. Следование стандарту С11 и максимальная кросс-платформенность. Исходные тексты, включаемые в состав библиотеки,
должны быть успешно скомпилированы и корректно исполнены для максимально возможного
числа компиляторов языка С и операционных систем.

2. Минимально возможное использование внешних зависимостей и библиотек.

3. Минимальное включение кода, то есть исключение из тела библиотеки фрагментов исходных текстов, которые реально
не используются или предоставляют мало востребованный пользовательский интерфейс.
Функции пользовательского интерфейса, не используемые при выполнении криптографических преобразований,
также должны быть выведены из состава библиотеки.

4. В случае, если некоторая функциональность не может быть реализована без использования
неэкспортируемых типов данных и функций, то данная функциональность должна быть включена в состав библиотеки
в соответствии с данными принципами. Это привело к тому, что в библиотеку были включены собственная
реализация операций с большими целыми числами, собственные функции разбора сообщений в формате ASN1 и т.д.

5. Максимальное документирование исходных текстов, включая не только описание аргументов
функций и возвращаемых значений, а также описание принципов реализации конкретных криптографических алгоритмов.
В документацию также должны включаться рекомендации по расширению функциональных возможностей библиотеки.

### Средства ограничения доступа к данным и ключевой информации

1. Каждому криптографическому преобразованию должен соответствовать уникальный
класс (совокупность данных и методов их обработки), объекты которого могут разделять совместно
только методы обработки данных, но не сами данные.
Примером такого подхода к реализации является класс секретного ключа произвольного блочного
алгоритма шифрования (см. struct \ref bckey). Каждый объект класса представляет собой ключ алгоритма шифрования,
уникальный для каждого объекта. При этом методы - функции зашифрования и расширования -
для всех ключей одного конкретного алгоритма шифрования могут совпадать.


2. Каждый класс должен иметь единооборазный набор конструкторов и деструкторов,
что позволяет организовать единообразный доступ к объектам, в частности, удаление объектов из памяти.

3. Создание объекта конкретного класса возможно только с помощью производящей функции.
Любой другой механизм создания объектов считается недопустимым.


4. Описание конкретной реализации класса (полей структуры, типов, используемых при описании ее данных,
перечень функций обработки данных) не экспортируется и не должно быть использовано за
пределами исходных текстов библиотеки.

5. Механизмы работы с контекстами (указателями на созданные в ходе выполнения кода библиотеки объекты)
не экспортируются. Указатели на созданные объекты не экспортируются.

6. Для доступа пользователя к объектам, создаваемым библиотекой, реализован механизм дескрипторов,
которые однозначно связываются с конкретными объектами.

7. Значение дескриптора не должно нести в себе какой-либо информации о типе или каких-либо других характеристиках
объекта с которым связан дескриптор. Данная информация должна предоставляться пользователю
с помощью интерфейсных функций.

### Регламенитируемая последовательность действий

1. При старте библиотеки должен производиться контроль ее работоспособности для всех реализованных
криптографических механизмов.

2. При завершении работы библиотека должна самостоятельно контролировать очистку оперативной памяти,
выделенной в процессе ее работы.

3. Библиотека должна вести аудит (документирование) возникающих в ходе ее выполнения ошибок исполнения программы.


Вссе перечисленные принципы
привели к тому, что библиотека содержит два типа интерфейсов. Первый - экспортируемые интерфейсы,
которые могут быть найдены в файле `libakrypt.h`. Данные функции
не позволяют пользователю оперировать с данными напрямую,
предоставляя для работы интерфейс, основанный на применении дескрипторов.

Внутренний интерфейс составляют неэкспортируемые функции. Данные функции могут
напрямую иметь доступ к полям и данным структур с которыми они оперируют,
но при этом они вызываются только в строго предсмотренных случаях
и со строго определенныи аргументами.

Для обеспечения связи между внешним (экспортируемым) интрефейсом
и функциями внутреннего интерфейса в библиотеке реализован менеджер контекстов.
Данный менеджер предназначен для хранения объектов создаваемых классов, связывания
объектов с дескрипторами, доступными пользователю,
и перенаправления запросов пользователя к функциям внутреннего интерфейса.

\section doc_construction_classes Принципы создания классов

В соответствии с высказанными выше принципами,
каждому криптографическому преобразованию соответствует уникальный класс.
Класс реализуется в виде структуры, полями которой являются  данные и указатели на функции. 

Такой вид структуры позволяет реализовывать в рамках одной структуры целое семейство 
однотипных криптографических механизмов, например, бесключевых функций хеширования или алгоритмов блочного шифрования. 
Для задания конкретного криптографического механизма
необходимо инициализировать структуру, то есть присвоить указателям на функции 
и полям класса некоторые значения таким образом, 
чтобы однозначно определить криптографический алгоритм или преобразование. 

Поскольку неконтролируемое присвоение полям структур произвольных значений может привести к полному коллапсу,
инициализация структур данных производится с помощью производящих функций,
присваивающих заранее определенные значения.

Результатом применения производящей функции
является объект класса. Для ряда криптографических механизмов, например, для функций бесключевого хеширования,
этого может оказаться достаточным для использования. Для других криптографических механизмов
может потребоваться присвоение созданному объекту некоторого значения, например, секретного ключа.

Таким образом, полный процесс создания объекта может состоять из двух шагов. На первом шаге производится
инициализация криптографического алгоритма, а на втором шаге - присвоение объекту конкретного значения.
При этом присвоение конкретного значения может быть реализовано с помощью нескольких функций.


Реализация сформулированной идеологии выглядит следющим образом.
В начале определяется некоторый класс, например, `foo`.


    typedef int ( some_function_type )( const char * );

    typedef struct foo {
       int data; /* данные класса */
       some_function_type *function; /* указатель на функцию обработки данных */
 
    } *ak_foo;

В указанном определении классом является `struct foo`, а `ak_foo` является определением 
указателя на данную структуру данных.
Если указатель типа `ak_foo` указывает на конкретную структуру в статической или динамической памяти, то такой указатель 
называют контекстом.

Далее, определяются и реализуются следующие три функции: 

* `ak_foo_create()` - функция инициализации объекта класса `foo`; данная функция не должна вызываться напрямую,
ее задача провести однотипные действия по инициалиации объекта класса свойственные всем алгоритмам 
семейства криптографических преобразований; функция, как правило, вызывается из производящей функции.

* `ak_foo_destroy()` - функция деструктор, которая реализует действия по освобождению памяти,
занимаемой внутренними полям класса `foo`; предполагается, что данная функция вызывается после
производящих функций и функций присвоения конкретного значения объекту класса, поэтому,
она должна корректно уничтожать последствия всех указанных инициализаций объекта;  

* `ak_foo_delete()` - функция, которая должна применяться для удаления объекта,
размещенного в динамической памяти; ее реализация достаточно однотипна, сводится к
вызову функции `ak_foo_destroy()` и может выглядеть следующим образом.


     ak_pointer ak_foo_delete( ak_pointer foo )
    {
     if( foo != NULL ) {
       ak_foo_destroy( buff );
       free( foo );
     } else ak_error_message( ak_error_null_pointer, __func__, "use a null pointer to foo" );
     return NULL;
    }


Основное предназначение функции `ak_foo_delete()` заключается в уничтожении объекта, помещенного в 
менеджер контекстов. Указатель на данную функцию помещается в менеджер контекстов вместе с контекстом,
что позволяет удалять объекты в необходимые моменты времени, например, при завершении работы, 
без вмешательства со стороны пользователя. 


После реализации указанных функций
необходимо реализовать производящие функции для каждого конкретного криптографического алгоритма. Например,
если класс `foo` позволяет реализовывать два конкретных криптографических алгоритма, например, `mouse` и `penguin`,
то создаются две производящие функции с именами

* `ak_foo_create_mouse( ak_foo foo, ... )`,

* `ak_foo_create_penguin( ak_foo foo, ... )`.

Обратите внимание, что первыми аргументами указанных функций являются 
указатели на инициализируемые объекты класса `foo`. Использование
указателей позволяет инициализщировать с помощью производящих функций 
объекты размещенные как в статической, так и в динамической памяти.  
Таким образом приводимый ниже код рассматривается как вполне корректный.


    struct foo fobject; /* определяем объект */
    ak_foo_create_mouse( &fobject); /* инициализируем объект с помощью производящей функции */
    /*
       .... здесь выполняются некоторые действия .... 
                                                      */
    ak_foo_destroy( &fobject );  /* уничтожаем объект */


В заключение, если это предусматривается криптографичсеким механизмом, необходимо реализовать функции
присвоения объекту класса некоторого значения. Как правило, это функции вида

* `ak_foo_set_ptr( ak_foo foo, ak_pointer ptr, ... )` - функция присвоения константного значения,
на которое указывает указатель `ptr`;

* `ak_foo_set_random( ak_foo foo, ak_random generator, ... )` - функция присвоения псевдо-случайного значения,
которое вырабатывается с помощью некоторого генератора `generator`.


Помимо перечисленных функций, реализующих интерфейсы инициализации, уничтожения,
а также присвоения заданных значений, могут реализовываться функции,
выполняющие конкретные криптографические преобразования. Например,
режим работы блочного шифра не зависит от строения конкретного блочного шифра
и может быть реализован независимо. Более детальное описание создаваемых функций 
будет дано нами далее при рассмотрении криптографических преобразований, 
а также может быть найдено в разделе, содержащем описание реализации конкретного класса. 

\section doc_buffer Буфферы хранения данных

Библиотека реализует буфферы для хранения данных в динамической памяти программы.
Класс, содержащий реализацию буфферов, называется struct \ref buffer.

Класс \ref buffer является единственным исключением из всего множества классов библиотеки,
поскольку ряд функций для работы с буфферами экспортируется
и доступен для пользователя. К таким функциям относятся

 - функции создания,
 - функции удаления,
 - функции доступа к значению,
позволяющие пользователю полноценно обрабатывать данные, возвращаемые
функциями внутреннего интерфейса.

Вместе с тем, внутренний инфтерфейс класса содержит механизмы
контроля за выделением и освобождением динамической памяти, в которой находятся данные.
Это существенно используется при
реализации механизмов хранения секретных данных.

Кроме того, буфет может предоставлять доступ к данным, при этом не владея ими.
Это означает, что при удалении буффера, не владеющего данными,
данные не будут удалены. Такой способ организации позволяет единообразно помещать в буффера как динамические,
так и статические данные.

Реализация класса \ref buffer скрыта от пользователя,
он может работать с контекстами - указателями на структуры,
созданные при помощи производящих функций. Производящими функциями, как правило,
являются функции, возвращающие результаты криптографических преобразований.

Поскольку пользователь работает
с контекстами буфферов напрямую, без использования механизма дескрипторов,
то контроль за освобождением памяти также ложится на плечи пользователя.


\section doc_context_manager Менеджер контекстов

\section doc_audit Аудит
В библиотеке реализован механизм аудита - вывода сообщений
о выполняемых библиотекой действиях. В настоящее время реализовано три уровня аудита.

* минимальный (\ref ak_log_none),
* стандартный (\ref ak_log_standard),
* максимальный (\ref ak_log_maximum).

На минимальном уровне выводятся сообщения об ошибках, возникающих к процессе выполнения функций
библиотеки. Коды (численные значения) возможных ошибок могут быть найдены в файле \ref `libakrypt.h`.
Помимо сообщений об ошибках на минимальном уровне выводится сообщение о корректном
тестировании работы всех криптографических механизмов, реализуемых библиотекой
(тестирование происходит в процессе выполнения функции `ak_libakrypt_create()` ).

На стандартном уровне аудита выводятся все сообщения, которые выводятся на минимальном уровне,
а также сообщения о фактах использования ключевой информации. К таким фактам относятся

* факты создания секретных ключей,
* факты удаления секретных ключей,
* ввод секретных ключей с внешних носителей,
* запись секретных ключей на внешние носители и т.п.

На максимальном уровне аудита выводятся все сообщения, которые выводятся на стандартном уровне,
а также отладочные сообщения, позволяющие понять логику работы ряда функций.
Так, выводятся сообщения о процессе тестирования, с кратким описанием тестов и
результатами их выполнения, а также сообщения об изменении эксплуатационных
характеристик библиотеки.

Пример определения функции, реализующей вывод сообщений о выполняемых библиотекой действиях, приводится
нами ранее в разделе \ref tinit_libex2.

В ходе выполнения программы, использующей библиотеку `libakrypt`,
пользователь может узнать установленный для него уровень аудита. Для этого библиотекой
экспортируется функция `ak_log_get_level()`.

Установка уровня аудита из программ, использующих библиотеку `libakrypt`, не допускается.
Уровень аудита относится к контролируемым характеристикам СКЗИ, поэтому
его значение содержится в файле `libakrypt.conf` и считывается перед началом тестирования
криптографических механизмов.
Более подробно о контролируемых характеристиках СКЗИ рассказывается в разделе \ref options.


\section doc_options Опции библиотеки

Точечная настройка работы библиотеки производится с помощью опций
(технических характеристик в терминологии Р 1323565.1.012-2017),
значения которых
влияют как на защищенность обрабатываемых данных, так и на скорость работы ряда функций библиотеки.
Данный значения могут быть настроены как системным администратором в соответствии с действующими требованиями
по безопасности, так и пользователем самостоятельно.

При старте библиотеки значения опций считываются из конфигурационного файла `libakrypt.conf`,
который может располагаться

* в общесистемном каталоге, например, `/etc`; установленный по-умолчанию общесистемный каталог
может быть изменен при настройке библиотеки в вызове команды `cmake`, например,


    cmake -DLIBAKRYPT_CONF=/etc ../libakrypt-0.x

* в домашнем каталоге пользователя, в подкаталоге `.config/libakrypt`.

При старте библиотеки файл с настройками ищется вначале в домашнем каталоге пользователя,
потом в общесистемном каталоге. Если в обоих каталогах файл `libakrypt.conf` не найден,
то библиотека создает этот файл в домашнем каталоге пользователя,
используя при этом значения опций, установленные по умоланию. Реализация этих действий
содержится в функции `ak_libakrypt_load_options()`, вызываемой в обязательном порядке
в самом начале выполнения функции `ak_libakrypt_create()`.

\subsection doc_options_details Реализация и доступ к опциям библиотеки

В файле `ak_tools.h` опция определяется как структура struct \ref option,
содержащая два поля - константную строку с именем опции, а также знаковое 32-х битное целое,
задающее значение опции.


    typedef struct option {
      /* Человекочитаемое имя опции, используется для поиска и установки значения */
      const char *name;
      /*! Численное значение опции (31 значащий бит + знак) */
      ak_int32 value;
    } *ak_option;

В этом же файле определен статический массив options, элементами которого являются структуры \ref option,
содержащие в себе значения всех опций библиотеки по-умолчанию.


    struct option options[] = {
      { "big_endian_architecture", ak_false },
      { "log_level", ak_log_standard },
         ...
      { NULL, 0 } /* завершающая константа, должна всегда принимать нулевые значения */
    };

Считываемые из файла `libakrypt.conf` при старте библиотеки значения
помещаются в данный статический массив и могут быть использованы и модифицированы в ходе работы программы.
При этом, функции для доступа к значениям опций являются экспортируемыми,
а функции для модификации значений опций - не экспорируемыми.

Для доступа к значениям опций могут быть использованы следующие функции,
экспортируемые через заголовочный файл `libakrypt.h`.

* `ak_libakrypt_options_count()` - функция возвращает количество опций,
содержащихся в статическом массиве;

* `ak_libakrypt_get_option_name()` - функция возвращает имя опции с заданным индексом,
значение индекса должно принадлежать интервалу от 0 до значения,
возвращаемого функцией `ak_libakrypt_options_count()` без единицы; при указании неверного индекса возвращается указатель
на null-строку;

* `ak_libakrypt_get_option_value()` - - функция возвращает значение опции с заданным индексом,
значение индекса должно принадлежать интервалу от 0 до значения,
возвращаемого функцией `ak_libakrypt_options_count()` без единицы;
при указании неверного индекса возвращается отрицательное значение,
определяемое константой \ref `ak_error_wrong_option`.

Указанные функции позволяют
организовать достаточно простой способ получения значений всех возможных опций,
например, с помощью следующего цикла.


    for( i = 0; i < ak_libakrypt_options_count()-1; i++ )
      printf("option %s has value %d\n",
         ak_libakrypt_get_option_name(i), ak_libakrypt_get_option_value(i));

Доступ на чтение и запись к опциям библиотеки может быть организован с помощью
неэкспортируемых функций, заголовки которых содержатся в файле `ak_tools.h`.

* `ak_libakrypt_get_option()` - функция возвращает значение опции по ее имени;

* `ak_libakrypt_set_option()` - для опции с заданным именем функция устанавливает ее значение.

С помощью неэкспортируемых функций можно менять текущие значения опций,
например, с помощью следующего кода.


    if( ak_libakrypt_get_option( "some option" ) < 120 )
      ak_libakrypt_set_option( "some option", 120 );


\subsection doc_options_values Описание опций библиотеки

В текущей версии библиотеки реализованы следующие опции.

\subsubsection doc_options_values_log_level Уровень аудита

Опция `log_level` устанавливает уровень аудита библиотеки и может принимать следующие значения: 

* 0 - для режима аудита \ref ak_log_none,
* 1 - для режима аудита \ref ak_log_standard,
* 2 - для режима аудита \ref ak_log_maximum.

Опция активно используется в функциях, вызываемых в теле функции `ak_libakrypt_create()`.
Более подробно о принципах вывода сообщений аудита см. в разделе \ref doc_audit.

\subsubsection doc_options_values_context_manager_size Минимальная вместимость менеджера контекстов

Опция `context_manager_size` устанавливает минимальное число контекстов, которые могут одновременно
находиться в менеджере контекстов. Значение опции определяет минимальный объем выделяемой памяти
под контексты, которые будут создаваться в ходе функционирования библиотеки, и используется в теле функции
`ak_context_manager_create()` при создании менеджера контекстов.
Подробнее о работе менеджера контекстов смотри в разделе \ref doc_context_manager.

Опция `context_manager_size` должна принимать значения в интервале от 32 до 65536.
Проверка и, в случае необходимости, коррекция значения опции происходит при считывании файла `libakrypt.conf`
в теле функции `ak_libakrypt_load_options_from_file()`.


\subsubsection doc_options_values_context_manager_max_size Максимальная вместимость менеджера контекстов

Опция `context_manager_max_size` устанавливает максимально возможное число контекстов,
которые могут одновременно находиться в менеджере контекстов. Значение опции определяет максимально допустимый
объем выделяемой памяти под контексты, которые будут создаваться в ходе функционирования библиотеки.
Значение данной опции используется в теле функции `ak_context_manager_morealloc()`.
Подробнее о работе менеджера контекстов смотри в разделе \ref doc_context_manager.

Опция `context_manager_max_size` должна принимать значения в интервале от 4096 до 2147483647.
Проверка и, в случае необходимости, коррекция значения опции происходит при считывании файла `libakrypt.conf`
в теле функции `ak_libakrypt_load_options_from_file()`.

\subsubsection doc_options_values_key_number_length Длина номеров ключей

Опция `key_number_length` определяет длину номеров ключей, формируемых библиотекой, то есть
задает количество байт, запись которых в шестнадцатеричном виде образует номер ключа.
Номер ключа должен быть уникальным, а его длина должна принимать значения в интервале от 16 до 32.
По-умолчанию значение данной опции равно 16.

\subsubsection doc_options_values_pdkdf2_iteration_count Количество циклов в алгоритме выработки ключа из пароля PBKDF2

Опция `pdkdf2_iteration_count` определяет количество циклов в
алгоритме выработки ключа из пароля PBKDF2, определяемого рекомендациями по стандартизации Р 50.1.111-2016.
При этом, чем больше данное значение, тем медленнее
происходит генерация ключа и тем сложнее реализуется перебор пароля.
Значение опции должно быть не менее 1000, и не более 32768.
По-умолчанию значение данной опции равно 2000.

\subsubsection doc_options_values_hmac_key_count_resource Ресурс ключа для алгоритма выработки имитовставки HMAC

\subsubsection doc_options_values_magma_cipher_resource Ресурс ключа для алгоритма блочного шифрования Магма

\subsubsection doc_options_values_kuznechik_cipher_resource Ресурс ключа для алгоритма блочного шифрования Кузнечик



\section doc_names Приложение A. Принципы наименования функций библиотеки

Для всех функций библиотеки принят единый принцип наименования.
Имя функции строится следующим образом


    ak_класс_действие
    ak_класс_действие_объект
    ak_класс_действие_предлог_действие2

где

* `ak`        - префикс библиотеки,
* `класс`     - класс, над объектами которого производятся заданные действия,
* `действие`  - основное действие над объектом,
* `действие2` - следующее действие над объектом,
* `предлог`   - направление действия,
* `объект`    - объект, на который направлено действие, либо объект,
                являющийся параметром действия.

\subsection doc_names_rules Основные действия

При выборе имен функций использовались следующие основные действия.

* `create`    - действие, которое реализует конструктор (инициализацию) объекта, под который уже
                выделена память - статическая или динамическая.
* `new`       - действие, которое выделяет динамическую память под объект, а после его
                инициализирует с помощью действия `create`;
                фактически, это конструктор, возвращающий указатель на созданный объект.

* `destroy`   - действие, которое уничтожает поля существующего объекта;
                память, выделенная под объект, не освобождается.
* `delete`    - действие, которое позволяет сначала уничтожить поля существующего объекта
                (с помощью действия `destroy`), а потом и выделенную под объект память.
*  `set`       - присвоить объекту некоторое значение.
*  `get`       - получить характеристику объекта (значение некоторого поля) без ее изменения,
                 как правило данное действие возвращает копию значения, хранящегося в объекте.
*  `load`      - считать значение объекта из заданного файла.
*  `save`      - сохранить значение объекта в заданном файле, как правило, применяется для сохранение ключевой информации.



\subsection doc_names_to Предлоги

* `to`        - действие направлено от объекта к объекту2 (в большинстве случаем использование предлога to
                означает процедуру преобразования объекта, в результате которой создается новый объект,
                удаление которого, как правило, возлагается на пользователя биьлиотеки).
* `from`      - действие направлено к объекту от объекта2 (в большинстве случаев
                функция реализует операцию присвоения нового значения объекту)
* `and`       - предлог для связи нескольких действий над объектом

\subsection doc_names_order Порядок следования аргументов функции

*  `арг1`      - первый аргумент это объект, с которым выполняется указанное действие
                 (во всех арифметических функциях - являющийся результатом действия)
*  `арг2`, ... - объекты, участвующие в действии


