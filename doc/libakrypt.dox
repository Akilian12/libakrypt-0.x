/*!
\mainpage Аннотация

Библиотека libakrypt представляет собой модуль, реализующий криптографические
преобразования для отечественного СКЗИ проекта OpenSKZI. Цель данного проекта заключается
в создании СКЗИ с открытым исходным кодом, удовлетворяющего отечественным требованиям
к шифровальным (криптографическим) средствам по классу КС3.

Библиотека libakrypt написана на языке C и реализует механизмы генерации, хранения, экспорта и импорта ключей, а также
основные криптографические механизмы,
включая алгоритмы шифрования/расшифрования данных, алгоритмы хеширования,
алгоритмы вычисления и проверки имитовставки и электронной подписи.

\page intro Введение в библиотеку libakrypt

\section intro_features Основные возможности

В текущей версии библиотеки реализованы следующие криптографические механизмы:

\li Бесключевые функции хеширования.
    -# Функция хеширования, регламентируемая отечественным стандартом ГОСТ Р 34.11-94
       (в настоящее время стандарт отменен).
    -# Функции хеширования Стрибог-256 и Стрибог-512, регламентируемые
       отечественным стандартом ГОСТ Р 34.11-2012.
    -# Функции хеширования SHA2-256 и SHA2-512, регламентируемые американским
       стандартом FISP 180-3
       (в настоящее время принята третья настоящего стандарта FIPS 180-4).

\li Алгоритмы блочного шифрования данных.
    -# Алгоритм блочного шифрования ГОСТ 28147-89 с длиной блока 64 бита и поддержкой
       различных таблиц замен (в настоящее время, согласно ГОСТ Р 34.12-2015, этот алгоритм
       с фиксированными таблицами замен носит название Магма).
    -# Алгоритм блочного шифрования Кузнечик с длиной блока 128 бит (согласно ГОСТ Р 34.12-2015).

\li Алгоритмы зашифрования/расшифрования сообщений c помощью алгоритмов блочного шифрования
    в следующих режимах (согласно ГОСТ Р 34.13-2015).
    -# Режим простой замены (electronic codebook mode, ЕСВ),
    -# Режим гаммирования (counter mode, CTR),
    -# Режим гаммирования с обратной связью по выходу (output feedback mode, OFB),
    -# Режим простой замены с зацеплением (cipher block chaining mode, СВС),
    -# Режим гаммирования с обратной связью по шифртексту (cipher feedback mode, CFB),
    -# Режим выработки имитовставки (message authentication code mode).

\li Программные генераторы псевдо случайных чисел (ПДСЧ).
    -# Линейный конгруэнтный генератор,
    -# Генератор, использующий чтение из произвольных файлов, в частности,
       файловых устройств /dev/random и /dev/urandom.

\section intro_compilers Среда выполнения библиотеки

Корректность работы текущей версии библиотеки была протестирована на следующих комбинациях
компиляторов языка С, операционных систем и аппаратных платформ.

\htmlonly
<table BORDER=1  CELLPADDING=7 CELLSPACING=1  WIDTH=80%>
<tr><td>Архитектура</td><td>Разрядность</td><td>ОС</td><td>Компилятор</td></tr>
<tr><td>x86</td><td>32</td><td>Windows</td><td>gcc 4.9.2 (в составе MinGW)</td></tr>
<tr><td>x86</td><td>32</td><td>Windows</td><td>gcc 3.3.4 (в составе MSYS)</td></tr>
<tr><td>x86</td><td>32</td><td>Windows</td><td>MSVC 10, MSVC 14</td></tr>
<tr><td>x86</td><td>64</td><td>Linux</td><td>gcc 5.4.0</td></tr>
<tr><td>x86</td><td>64</td><td>Linux</td><td>clang 3.6.2</td></tr>
<tr><td>x86</td><td>64</td><td>Linux</td><td>tcc 0.9.26</td></tr>
</table>
\endhtmlonly

\latexonly
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Архитектура & Разрядность &  ОС & Компилятор \\ \hline
x86 & 32 &  Windows & gcc 4.9.2 (в составе MinGW) \\ \hline
x86 & 32 &  Windows & gcc 3.4.4 (в составе MSYS) \\ \hline
x86 & 32 &  Windows & MSVC 10, MSVC 14 \\ \hline
x86 & 64 &  Linux & gcc 5.4.0 \\ \hline
x86 & 64 &  Linux & clang 3.6.2 \\ \hline
x86 & 64 &  Linux & tcc 0.9.26 \\ \hline
\end{tabular}
\end{center}
\endlatexonly

\section intro_dependence Зависимости библиотеки

Для корректной сборки и выполнения библиотеки libakrypt необходимо
удовлетворить ряд внешних зависимостей.

\subsection intro_dependence_cmake CMake

Системой сборки для библиотеки libakrypt является <a href="https://cmake.org">CMake</a>.
Набор программ и утилит CMake может быть скачан с официального сайта программы.

В операционной системе Linux Debian (либо в любой другой сборке Linuх с той же
системой управления пакетами) установка CMake может быть выполнена следующим вызовом.

\code
apt-get install cmake
\endcode

\subsection intro_dependence_pthreads PThreads

Для корректной сборки и работы библиотеке libakrypt достаточно
стандартной библиотеки libc языка C или любой другой библиотеки с аналогичной функциональностью.

Библиотека libakrypt использует многопоточное выполнение некоторых своих
функций, поэтому ей необходим базовый набор функций для работы с потоками.
В операционной системе Linux эта функциональность также входит в состав библиотеки libc.

В операционной системе Windows при сборке и выполнении функций библиотеки libakrypt
необходимо использование разделяемой библиотеки pthreads-w32 (POSIX Threads Library for Win32),
доступной для скачивания по адресу http://sources.redhat.com/pthreads-win32.
Перед сборкой библиотеки libakrypt Вам необходимо вручную настроить
библиотеку pthreads-w32.


\section intro_make Сборка библиотеки из исходных кодов, инсталляция и настройка

Далее мы опишем процесс сборки библиотеки libakrypt из исходных текстов.

\subsection intro_make_unix Сборка в Linux

Скачайте архив с исходными текстами библиотеки вида libakrypt-0.x.tar.bz2 и
сохраните его в некоторый каталог.
Перейдите в консоли в этот каталог и для разархивации архива с исходными кодами
выполните следующую команду.
\code
tar -xjvf libakrypt-0.x.tar.bz2
\endcode

После ее выполнения должен появиться каталог libakrypt-0.x, где x это
номер текущей версии библиотеки.
Далее, для сборки библиотеки выполните следующую последовательность команд.

\code
mkdir build
cd build
cmake ../libakrypt-0.x
make
\endcode

Данная последовательность команд использует для сборки библиотеки
компилятор по-умолчанию, то есть \b gcc. Если Вы хотите использовать другой компилятор,
то Вам необходимо передать в вызов \b cmake дополнительные опции.
Так, следующий вызов позволит произвести сборку библиотеки с помощью компилятора clang.
\code
cmake -DCMAKE_C_COMPILER=clang ../libakrypt-0.x
\endcode

Аналогично, следующий вызов позволит произвести сборку библиотеки с помощью
компилятора tcc (Tiny C Compiler)
\code
cmake -DCMAKE_C_COMPILER=tcc ../libakrypt-0.x
\endcode

По умолчанию предполагается, что библиотека будет установлена в каталог \b /usr/local.
Для изменения этого каталога
можно передать в \b cmake путь установки в явном виде. Например, следующий вызов позволяет
установить библиотеку в католог \b /usr.
\code
cmake -DCMAKE_INSTALL_PREFIX=/usr ../libakrypt-0.x
\endcode

Для инсталляции библиотеки достаточно выполнить команду

\code
make install
\endcode

\b Внимание. Команда инсталляции библиотеки должна выполняться с правами суперпользователя.

\subsection intro_doc_linux Сборка документации в Linux

В операционной системе Linux Вы можете воспользоваться
готовыми средствами для создания документации к библиотеке libakrypt.

Если у Вас установлен пакет <a href="http://www.doxygen.org/index.html">Doxygen</a>,
а также установлена система подготовки документации LaTex,
то сборка документации может быть выполнена следующей простой командой.

\code
make doc
\endcode

Данная команда должна выполняться в том же каталоге,
в котором происходила сборка библиотеки. После выполнения команды,
в каталоге сборки должны появиться

- файл libakrypt-doc-0.x.pdf, содержащий документацию в формате PDF (файл формируется с помощью системы подготовки документации LaTeX),
- файл libakrypt-0.x.qch, содержащий документацию в формате QCH (удобно интегрируется в среду разработки QtCreator),
- архив libakrypt-html-0.x.tar.bz2, содержащий в архивированном виде
  документацию к библиотеке в формате HTML.

\subsection intro_make_windows Сборка в Windows
В операционной системе Windows сборка библиотеки и тестовых примеров
возможна с помощью компиляторов gcc, tcc и MSVC.

\subsubsection intro_make_windows_msvc
В настоящее время протестирована сборка библиотеки
с помощью компиляторов MSVC версий 10 и старше.

Для сборки библиотеки и тестовых примеров с помощью компилятора MSVC
необходимо запустить командную строку Visual Studio и
создать каталог для сборки, например, выполнив команду
\code
mkdir build
\endcode

Далее, необходимо перейти в созданный каталог и запустить cmake
для конфигурации сборки.

\code
cmake -G "NMake Makefiles" path
\endcode
где path это путь к каталогу, в котором находятся исходные коды библиотеки, например, ../libakrypt-0.x.
Далее сборка библиотеки и тестовых примеров выполняется следующей командой
\code
nmake
\endcode

Для запуска собранных тестовых примеров необходимо, чтобы созданном Вами каталоге build
находился файл pthreadVC2.dll.

\subsubsection intro_make_windows_mingw
Для сборки компилятором gcc
Вам необходимо установить набор программ из проекта MinGW.
Далее, в командной строке

\code
cd build
cmake -G "MinGW Makefiles" ../libakrypt-0.x
mingw32-make.exe
\endcode

\subsection intro_make_hands Сборка своими руками
В ряде случаев возникают ситуации в которых сборка библиотеки libakrypt
не может быть произведена с помощью системы сборки cmake. Как правило такая ситуация возникает
 в случае, когда инсталляция cmake невозможна, либо используется не знакомый cmake компилятор.
В таких случаях из командной строки возможна сборка библиотеки, а также тестовых примеров.

Общая схема командной строки для сборки тестовых примеров проста:

- компилятор
- параметры сборки
- имена файлов
- имя результирующей программы.

Следующий простой вызов из командной строки в Linux
позволяет собрать один из тестовых примеров (в корневом каталоге библиотеки).

\code
gcc -Isource -O3 -DLIBAKRYPT_OPTIONS_PATH=\"/etc\" source/*.c examples/example-intro.c -o intro
\endcode

При этом, параметр LIBAKRYPT_OPTIONS_PATH пределяет каталог в котором библиотека
будет искать файл с настройками (подронее смотри в разделе \ref options).
Если данный параметр не указан, то месторасположением файла с настройками будет
являться каталог $HOME$/.config/libakrypt,
где $HOME$ это домашний каталог пользователя.

Для сборки тестовых примеров в Windows можно использовать
следующий простой bat-файл.

\include examples/runcl.bat

Именно этот файл позволил нам в консоли собрать тестовые примеры,
используя в качестве компилятора Visual Studio Community 2015.

 
Файл принимает два параметра - первый, это каталог с исходными кодами библиотеки,
а второй это имя примера (без example). Например, вызов
\code
cl.bat ..\libakrypt-0.x intro
\endcode
позволяет собрать тестовый пример example-intro.c


\section intro_internet_resources Интернет ресурсы

<a href="http://www.openskzi.ru">Проект OpenSKZI</a>

\section intro_steps Этапы разработки и нумерация версий

При разработке библиотеки нами были приняты следующая последовательность разработки
и принцип нумерации версий библиотеки.

\li Версия 0.3.х - реализация бесключевых функций хеширования
                   (последняя версия в этой ветке 0.3.28)

\li Версия 0.4.х - реализация алгоритмов блочного шифрования и режимов их использования
                   в соответствии с ГОСТ Р 34.12-2015 и ГОСТ Р 34.13-2015.

\li Версия 0.5.х - реализация механизмов выработки кодов аутентичности (HMAC и AEAD)

\li Версия 0.6.х - реализация ключевого хранилища

\li Версия 0.7a.х - реализация вычислений с эллиптическими кривыми и алгоритмов выработки и проверки электронной подписи в соответствии ГОСТ Р 34.10-2012.

\li Версия 0.7b.х - разборка/создание ASN1 контейнеров

\li Версия 0.7с.х - сертификаты открытых ключей

\li Версия 0.8.x - реализация гибридных алгоритмов шифрования

\li Версия 0.9.x - реализация механизмов хранения ключевой информации в памяти
                  (данная функциональность не зависит от предыдущих версий)

\li Версия 0.10.x -

\li Версия 0.11.x -


\page libex Правила использования библиотеки

В настоящей главе мы приводим рекомендации по встраиванию библиотеки libakrypt
в программные средства. Рекомендации оформлены в виде примеров,
иллюстрирующих основные функциональные особенности библиотеки.

Перечень экспортируемых библиотекой констант, типов данных и функций содержится в заголовочном
файле \ref libakrypt.h. Для встаривания библиотек должны использоваться только объекты,
определенные в этом файле.
Вызов не экспортируемых функций библиотеки считается недопустимым и
не должен применяться при ее использовании.

Далее, мы приведем несколько примеров использования библиотеки,
иллюстрирующих ее возможности.

\section tinit Инициализация и настройка библиотеки

\subsection tinit_libex1 Пример инициализации библиотеки

Перед тем, как вызывать какие-либо функции библиотеки, необходимо провести ее инициализацию.
Для этого предназначена функция ak_libakrypt_create() - она выполняет проверку корректности работы
криптографических механизмов и инициализирует внутренние переменные библиотеки.

Простейшая программа, использующая библиотеку, должна выглядеть следующим образом.

\include examples/example-intro.c

Используемая нами для инициализации библиотеки функция ak_libakrypt_create() принимает один параметр,
а именно, указатель на функцию, которая используется для вывода сообщений о работе или ошибках библиотеки.
В заголовочном файле \ref libakrypt.h содержится перечень из нескольких заранее предопределенных функций,
предназначенных для вывода сообщений.

\code
 int ak_function_log_stderr( const char * );
#ifdef __linux__
 int ak_function_log_syslog( const char * );
#endif
\endcode

Функция ak_function_log_stderr() использует для вывода сообщений стандартный поток вывода ошибок операционной системы.
Реализация данной функции доступна для всех операционных систем.

Функция ak_function_log_syslog() использует для вывода сообщений демон операционной системы Linux,
предназначенный для журналирования событий в системе. Реализация данной функции доступна только
в операционной системе Linux.

Пользователь может самостоятельно определить и использовать свою собственную функцию
вывода сообщений об ошибках Для этого он должен реализовать функцию, удовлетворяющую следующему определению.

\code
// Функция аудита
 typedef int ( ak_function_log )( const char * );
\endcode

Более подробно о принципах, на которых основан отбор выводимых сообщений,
можно узнать в разделе \ref audit.

В заключение добавим, что завершение работы с функциями библиотеки должно производиться
при помощи вызова функции ak_libakrypt_destroy(). Данная функция останавливает внутренние механизмы
и освобождает используемую библиотекой память.

\subsection tinit_libex2 Пример установки пользовательской функции аудита
Пользователь библиотеки linakrypt может настроить вывод сообщений библиотеки (аудит)
удобным для него способом. Далее мы приведем простой пример (\ref example-log.c)
в котором используется функция ak_log_set_function(). Эта функция
устанавливает пользовательскую функцию аудита.

\include examples/example-log.c

Обратим внимание на то, что
вывод сообщений производится с помощью функции ak_log_set_message().


\section toid Идентификаторы криптографических механизмов (OID)

OID (Object IDentifier) это уникальная последовательность чисел, разделенных точками.

OID'ы могут быть присвоены любому криптографическому механизму (алгоритму,
схеме, протоколу), а также параметрам этих механизмов.
Использование OID'в позволяет однозначно определять тип криптографического механизма или
значения его параметров на этапе выполнения программы, а также
однозначно связывать данные (как правило ключевые) с алгоритмами, в которых эти данные
используются.

Конкретные значения OID реализуются с помощью контекстов класса \ref oid,
каждый объект которого содержит в себе
\li читаемое (пользователем библиотеки) имя OID,
\li идентификатор OID (последовательность чисел, разделенных точками),
\li тип криптографического механизма (engine), в качестве которого может выступать алгоритм
    или параметры алгоритма,
\li режим использования криптографического алгоритма.

Ниже мы приведем несколько примеров использования OID'ов библиотеки.

\subsection toid_ex1 Получение перечня всех доступных идентификаторов библиотеки

Нижеследующая программа позвроляет вывести список всех
существующих OID'ов библиотеки. Для вывода используется перебор в цикле
всех возможных значений.

\include examples/example-oid.c

Отметим, что количество существующих OID'ов может быть получено с помощью вызова
функции ak_oids_get_count(). После чего,
конкретный контекст OID может быть получен с помощью вызова функции ak_oids_get_oid(),
аргументом которой является индекс OID'a во внутреннем массиве (целое число, принимающее значения от
нуля и меньшее, чем значение, возвращаемое функцией ak_oids_get_count()).

OID также может быть найден во внутреннем массиве по имени или по его идентификатору.
Для этого предназначены функции ak_oids_find_by_name() и ak_oids_find_by_id().

Функции поиска OID'ов могут быть использованы при переборе всех однотипных
криптографических механизмов, например, функций хеширования. Пример такого использования
мы приводим в разделе \ref thash_ex3.

\subsection toid_ex2 Добавление новых идентификаторов в библиотеку

В ряде случаев может возникнуть ситуация, когда необходимо использовать параметры алгоритмов,
не определенные в библиотеке в явном виде. В первую очередь это относится к
таблицам замен для алгоритма блочного шифрования ГОСТ 28147-89 (Магма), а также к параметрам
эллиптических кривых, используемых при выработке электронной подписи.

В такой ситуации библиотека представляет ряд интерфейсов для добавления пользовательских
параметров. Так, для добавления таблиц замен алгоритма ГОСТ 28147-89 (Магма) может быть использована
функция ak_oids_add_magma_tables(). Пример использования этой функции приводится ниже.

\include examples/example-oid-magma.c

Отметим, что в приведенном примере общее число OID выводится до добавления нового значения.

\section thash Хеширование данных

Бесключевые функции хеширования очень активно используются в криптографических приложениях,
например, для контроля целостности данных (файлов) или при выработке электронной подписи.
Библиотека реализует контекст \ref hash, который обеспечивает реализацию
бесключевых функций хеширования и позволяет вычислить значение хеш-кода данных.
Перечень реализованных функций хеширования был приведен нами ранее
в разделе \ref intro_features.

\subsection thash_ex1 Пример хеширования данных

Для вычисления хеш-кода данных Вам необходимо выполнить последовательность из трех шагов
\li создать контекст с помощью производящей функции,
\li вычислить значение хеш-кода,
\li удалить контекст.

Приведем пример, иллюстрирующий описанную последовательность действий.

\include examples/example-hash.c

В приведенном примере вычисления производятся с помощью функции ak_hash_data(),
а результат вычислений (хеш-код) помещается в новый буффер,
реализуемый классом \ref buffer. Данный буффер должен потом удаляться пользователем самостоятельно.

В случае, когда пользователь не хочет (или не может)
размещать хеш-код в оперативной памяти, он может передать в функцию
ak_hash_data() в качестве четвертого аргумента указатель на область памяти,
в которую будет помещен результат. Размер области памяти модет быть вычислен заранее
с помощью функции ak_hash_get_code_size().

Добавим, что производящие функции, позволяющие создать контекст функции хеширования,
носят однообразные названия, например
\li ak_hash_new_streebog256(),
\li ak_hash_new_streebog512(),
\li ak_hash_new_sha256(),
\li ak_hash_new_sha512(),
\li ak_hash_new_gosthash94().

Последняя функция принимает один аргумент, а именно, контекст OID,
определяющий таблицу замен согласно стандарту ГОСТ Р 34.11-94.

Аналогично хешированию данных, пользователь
может выполнить хеширование файлов, хранящихся на жестких дисках. Для
этого пользователю необходимо воспользоваться функцией ak_hash_file().
Пример хеширования файлов мы приведем далее в разделе \ref thash_ex3.

\subsection thash_ex2 Пример хеширования фрагментированных данных

В предыдущем примере до вызова функции ak_hash_data() нам был известен
размер хешируемых данных. Вместе с тем, на практике
возникают ситуации, когда хеширование должно начинаться до
того момента, как станет известе общий размер хешируемых данных. Такая ситуация возникает при
вычислении хеш-кода от информации, получаемой из сети (потоковых данных),
например видео-файлов, аудио инофрмации или просто файлов большого размера.

В этом случае, алгоритм хеширования допускает
возможность начать вычисления до окончания приема данных. Общая последовательность
такой реализации алгоритма хеширования выглядит следующим образом

\li создать контекст с помощью производящей функции,
\li для каждого нового фрагмента обрабатываемой последовательности обновить
    внутренние состояния контекста,
\li после окончания приема данных закрыть контекст и получить значение хеш-кода,
\li удалить контекст.

Отметим, что для оптимизации операций чтения с диска,
подобная схема реализована в библиотеке при хешировании файлов в функции ak_hash_file().

Описанная выше последовательность действий может быть проиллюстрирована следующим примером.

\include examples/example-hash-parts.c

В приведенном примере данные для хеширования разбиваются на parts фрагментов, при этом,
длина каждого фрагмента равна значению, которое возвращается функцией ak_hash_get_block_size().
На практике можно использовать фрагменты, кратные этой веоличине.

Далее, каждый фрагмент обрабатывается с помощью функции ak_hash_update(), а завершается
преобразование данных вызовом функции ak_hash_final(). Результат
вычислений можно получить с помощью вызова функции ak_hash_get_code().

\subsection thash_ex3 Пример выбора функции хеширования по ее OID

Для создания контекста функции хеширования также может быть использован OID алгоритма.
Необходимость создания контекста функции хеширвоания по ее OID возникает
в приложениях, в которых пользователь самостоятельно выбирает алгоритм хеширования.

Следующий пример иллюстрирует этот подход. Мы находим все алгоритмы бесключевого хеширования,
предоставляемые библиотекой и для каждого из них вычисляем хеш-код одного и того же файла.
Помомо иллюстрации хеширования файлов и возможности создания контекста функции хеширования
по OID алгоритма, мы сравниваем быстродействие реализованных в библиотеке алгоритмов.

\include examples/example-hash-oids.c

Также как и в примере \ref toid_ex1, мы перебираем все доступные OID библиотеки.
Для каждого найденного OID проверяем, является ли он бесключевой функцией хеширования.
Для это необходимо, чтобы engine (который мы получаем с помощью вызова функции ak_oid_get_engine())
был равен \ref hash_function, а режим использования
(который мы получаем с помощью вызова функции ak_oid_get_mode()) был равен \ref algorithm.

Далее, найденный OID используется для создания контекста функции хеширования
с помощью функции ak_hash_new_oid(). Заданный заранее файл хешируется с помощью вызова функции
ak_hash_file(), а результат помещается во временный буффер.

\section trand Генерация псевдо-случайных чисел

Для генерации псевдо-случайных чисел в библиотеке реализован класс \ref random,
который предоставляет унифицированный интерфейс для инициализации, удаления генераторов,
а также для выработки пседвдо случайных чисел.

Перечень реализованных генераторов был приведен нами ранее
в разделе \ref intro_features.
Ниже мы приведем два примера использования генераторов.

\subsection trand_lcg Пример использования линейного конгруэнтного генератора

Простейшим псевдо случайным генератором, который может быть использован для генерации
псевдослучайных последовательностей является линейный конгруэнтный генератор
(linear congruence generator). Этот генератор вырабатывает последовательность внутренних состояний,
удовлетворяющую линейному сравнению \f$ x_{n+1} \equiv a\cdot x_n + c \pmod{2^{64}}, \f$
в котором константы a и c удовлетворяют равенствам
\f$ a = 125643267795740073 \f$ и \f$ b = 506098983240188723 \f$.

Далее, последовательность внутренних состояний преобразуется в последовательность
байт по следующему правилу
\f$ \gamma_n = \displaystyle\frac{x_n - \hat x_n}{2^{24}} \pmod{256}, \f$
где \f$\hat x_n \equiv x_n \pmod{2^{24}} \f$
(приведенные формулы означают, что если мы рассмотрим \f$ x_n \f$ как восьмибайтный вектор,
то \f$ \gamma_n \f$ есть четвертый младший байт).

Ниже мы приводим простейший пример использования данного генератора.

\include examples/example-random.c

В начале мы создаем контекст генератора при помощи
производящей функции ak_random_new_lcg(). Данная функция
инициализирует начальное состояние генератора, используя для этого
вызов функции ak_random_value().

Далее мы используем вызовы функций ak_random_uint64() и ak_random_ptr()
для генерации псевдослучайных значений. Вызов функции ak_random_randomize_uint64()
позволяет установить новое начальное значение генератора.
Отметим, что установки начального значения также может быть использована функция
ak_random_randomize_ptr().

\subsection trand_file Пример использования файлового устройства /dev/random

Операционная система Linux предоставляет пользователям
файловое устройство /dev/random, которое может быть использовано
для получения псевдо случайных значений.
В библиотеке реализован специальный генератор \ref random_file,
который позволяет считывать значения из произвольных файлов и, в частности,
из /dev/random.

Пример использования такого генератора приводится ниже.

\include examples/example-dev-random.c

В начале мы создаем генератор с помощью производящей функции ak_random_new_file(),
аргументом которой является имя файла из которого считываются псевдо случайные значения.
Далее, мы получаем данные используя вызовы функций ak_random_uint8() и ak_random_ptr().

Отметим, что генератор производит считывание из файла циклически:
после того, как будет достигнут конец файла, чтение начинается с начала.
При этом, для файловых устройств типа /dev/random конец файла достигнуть быть не может.

\section encrypt Шифрование информации

Теперь мы опишем действия,
которые необходимы для зашифрования и расшифрования информации.

\subsection encrypt_ex1 Пример шифрования массивов данных

В качестве простейшей иллюстрации приведем пример шифрования произвольного массива данных.

\include examples/example-encrypt-ecb.c

Данный пример не является функционально полезным, но он иллюстрирует последовательность действий,
которую необходимо выполнить:

\li создать ключ шифрования,
\li преобразовать (зашифровать/расшифровать) данные.

В приведенном примере вырабатывается случайный ключ блочного алгоритма шифрования Магма.
Для выработки ключа используется производящая функция ak_key_new_magma(),
единственным аргументом которой является строка символов с произвольным (понятным пользователю)
описанием ключа.

В библиотеке реализованы другие производящие функции, позволяющие создавать
ключи других алгоритмов блочного шифрования
\li ak_key_new_magma_oid() - функция создает ключ алгоритма блочного шифрования ГОСТ 28147-89,
аргументами функции являются OID таблицы замен, используемой в алгоритме, а также описание ключа.
\li ak_key_new_kuznetchik() - функция создает ключ алгоритма блочного
шифрования Кузнечик (ГОСТ Р 34.12-2015).

Стоит также обратить внимание на тот факт, что внутренние механизмы контроля
за секретными ключами самостоятельно уничтожают и очищают выделенную под ключи память.
Данные операции выполняются в теле функции ak_libakrypt_destroy().

Пользователь может получить некоторые сведения о созданном ключе. Для этого
предназначены следующие функции.

\li ak_key_get_number() - функция возвращает константный указатель на строку, содержащую
последовательность шестнадцатеричных символов (hexstr) с уникальным номером, присвоенным
ключу при его создании.
\li ak_key_get_description() - функция возвращает константный указатель на строку, содержащую
(понятное пользователю) описание ключа.
\li ak_key_get_resource() - функция возвращает количество блоков информации,
которое может быть уммарно зашифровано/расшифровано с использованием данного ключа. Данное значение
ограничивает объем информации, обрабатываемой на данном ключе
(о ключевых ресурсах смотри также в разделе \ref options).

В приведенном примере зашифрование и, соответсвенно, расшифрование данных производятся с
помощью функций ak_key_encrypt_ecb() и ak_key_decrypt_ecb(). Для преобразования
исходного массива данных используется режим простой замены (ГОСТ Р 34.13-2015).
В реальных приложениях данный режим использовать нецелесообразно.

\page construction Внутреннее строение библиотеки


\section principles Принципы построения

\li минимальная зависимость от внешних библиотек
\li максимальнаяч переносимость
\li минимизация кода (только то, что имеет смысл) и минимизация пользовательского интерфейса

\li работа с контекстами (указателями на структуры) и идентификаторами
\li использование производящих функций для создания контекстов
\li



\section names Принципы наименования функций библиотеки

Для всех функций библиотеки принят единый принцип наименования.
Имя функции строится следующим образом

\code
  ak_класс_действие
  ak_класс_действие_объект
  ak_класс_действие_предлог_действие2
\endcode

где

\li ak        - префикс библиотеки
\li класс     - класс, над объектами которого производятся действия
\li действие  - основное действие над объектом
\li действие2 - следующее действие над объектом
\li предлог   - направление действия
\li объект    - объект, на который направлено действие, либо объект,
                являющийся параметром действия

\subsection names_rules Основные действия

При выборе имен функций использовались следующие основные действия.

\li  create    - определить поля существующего указателя на объект (конструктор по-умолчанию)
\li  new       - создать указатель на объект и определить его поля
\li  destroy   - очитить поля существующего указателя на объект (деструктор)
\li  delete    - очистить поля существующего указателя и удалить сам указатель
\li  set       - присвоить объекту некоторое значение
\li  get       - преобразовать объект к некорому другому классу

\subsection names_to Предлоги

\li to        - действие направлено от объекта к объекту2 (константная функция)
\li from      - действие направлено к объекту от объекта2 (функция присвоения нового значения)
\li and       - предлог для связи нескольких действий над объектом

\subsection names_order Порядок следования аргументов функции

\li  арг1      - объект являющийся результатом действия
\li  арг2, ... - объекты, участвующие в действии

\section audit Аудит
В библиотеке libakrypt реализован механизм аудита - вывода сообщений
о выполняемых библиотекой действиях. В настоящее время реализовано три уровня аудита.

\li минимальный (ak_log_none),
\li стандартный (ak_log_standard),
\li максимальный (ak_log_maximum).

На минимальном уровне выводятся сообщения об ошибках, возникающих к процессе выполнения функций
библиотеки. Коды (численные значения) возможных ошибок могут быть найдены в файле \ref libakrypt.h.
Помимо сообщений об ошибках на минимальном уровне выводится сообщение о корректном
тестировании работы всех криптографических механизмов, реализуемых библиотекой
(тестирование происходит в процессе выполнения функции ak_libakrypt_create() ).

На стандартном уровне аудита выводятся все сообщения, которые выводятся на минимальном уровне,
а также сообщения о фактах использования ключевой информации. К таким фактам относятся

\li факты создания секретных ключей,
\li факты удаления секретных ключей,
\li ввод секретных ключей с внешних носителей,
\li запись секретных ключей на внешние носители и т.п.

На максимальном уровне аудита выводятся все сообщения, которые выводятся на стандартном уровне,
а также отладочные сообщения, позволяющие понять логику работы ряда функций.
Так, выводятся сообщения о процессе тестирования, с кратким описанием тестов и
результатами их выполнения, а также сообщения об изменении эксплуатационных
характеристик библиотеки.

Пример определения функции,
реализующей вывод сообщений о выполняемых библиотекой действиях, приводится
в разделе \ref tinit_libex1.

В ходе выполнения программы, использующей библиотеку libakrypt,
пользователь может узнать установленный для него уровень аудита. Для этого библиотекой
экспортируется функция ak_log_get_level().

Установка уровня аудита из программ, использующих библиотеку libakrypt, запрещена.
Уровень аудита относится к контролируемым характеристикам СКЗИ.
Его значение содержится в файле \b libakrypt.conf и считывается перед началом тестирования
криптографических механизмов. За уровень аудита в файле \b libakrypt.conf отвечает
переменная log_level, которая может принимать значения 0 (\b ak_log_none),
1 (\b ak_log_standard) или 2 (\b ak_log_maximum).
Более подробно о контролируемых характеристиках СКЗИ рассказывается в разделе \ref options.

\section options Настройка и эксплуатационные характеристики

Согласно отечественным требованиям к СКЗИ, для СКЗИ класса КС3 необходима роль администратора,
устанавливающего различные эксплуатационные характеристики. Перечень таких характеристик
содержится в инсталлируемом вместе с библиотекой файле \b libakrypt.conf.
В процессе тестирования криптографических механизмов,
функция ak_libakrypt_create() проверяет наличие этого файла и, в случае его отсутствия,
прекращает работу библиотеки.

При инсталляции файла \b libakrypt.conf ему присваиваются права,
позволяющие считывать хранящиеся в нем значения всем пользователям. При этом запись в файл
и изменение хранящихся в нем значений разрешается только администратору (суперпользователю).

В настоящее время в файле \b libakrypt.conf содержатся следующие эксплуатационные характеристики.

\li \b log_level - константа, определяющая уровень аудита библиотеки. Данная константа может принимать
значения от нуля до двух. Более подробно об аудите библиотеки libakrypt изложено в разделе \ref audit.

\li \b magma_block_resource - константа, определяющая количество блоков текста, которые могут быть
зашифрованы/расшифрованы на одном ключе блочного алгоритма шифрования ГОСТ 28147-89 (Магма).
После зашифрования/расшифрования заданного количества блоков работа с секретным ключом блокируется.

\li \b kuznetchik_block_resource - константа, определяющая количество блоков текста, которые могут быть
зашифрованы/расшифрованы на одном ключе блочного алгоритма шифрования ГОСТ Р 34.12-2015 (Кузнечик).
После зашифрования/расшифрования заданного количества блоков работа с секретным ключом блокируется.

Месторасположение файла \b libakrypt.conf может контролироваться при сборке библиотеки libakrypt -
в этот момент можно задать каталог расположения файла в явном виде, указав его значение
с помощью переменной LIBAKRYPT_CONF. Например, следующий фрагмент кода
позволяет поместить файл \b libakrypt.conf в каталог /etc.

\code
cmake -DLIBAKRYPT_CONF=/etc ../libakrypt-0.x
\endcode

По умолчанию, значение переменной LIBAKRYPT_CONF определяется в зависимости
от используемой операционной системы.

В операционной системе Linux месторасположение файла \b libakrypt.conf
определяется следующим образом. В каталоге инсталляции библиотеки
создается подкаталог \b /share/libakrypt, в который помещается конфигурационный файл.
Каталог инсталляции библиотеки может быть изменен с помощью переменной CMAKE_INSTALL_PREFIX.
Более подробно об этом смотри в разделе \ref intro_make_unix, а также в
документации на CMake.

*/

