/* ----------------------------------------------------------------------------------------------- */
/*! \mainpage Аннотация

Библиотека `libakrypt` представляет собой модуль, реализующий криптографические
преобразования для отечественного СКЗИ проекта [OpenSKZI](http://openskzi.ru).
Цель данного проекта заключается в создании СКЗИ с открытым исходным кодом, удовлетворяющего
методическим рекомендациям Р 1323565.1.012-2017
«Информационная технология. Криптографическая защита информации.
Принципы разработки и модернизации шифровальных (криптографических) средств защиты информации»
по классу КС3
(более детально см. [здесь](https://tc26.ru/standarts/rekomendatsii-po-standartizatsii/r-1323565-1-012-2017-informatsionnaya-tekhnologiya-kriptograficheskaya-zashchita-informatsii-printsipy-razrabotki-i-modernizatsii-shifrovalnykh-kriptograficheskikh-sredstv-zashchity-informatsii.html)).

Библиотека `libakrypt` написана на языке C и реализует механизмы генерации, хранения, экспорта и импорта ключей, а также
основные отечественные криптографические механизмы, регламентированные государственными стандартами
и методическими рекомендациями, включая:

\li Бесключевые функции хеширования.
    -# Функция хеширования, регламентируемая отечественным стандартом ГОСТ Р 34.11-94
       (в настоящее время стандарт отменен, функция реализована для возможности разбора
       сертификатов открытых ключей);
    -# Функции хеширования «Стрибог-256» и «Стрибог-512», регламентируемые
       отечественным стандартом ГОСТ Р 34.11-2012.

\li Алгоритмы блочного шифрования данных.
    -# Алгоритм блочного шифрования «Магма» с длиной блока 64 бита, согласно ГОСТ Р 34.12-2015
      (данный алгоритм с произвольными таблицами замен регламентируется ГОСТ 28147-89);
    -# Алгоритм блочного шифрования «Кузнечик» с длиной блока 128 бит, согласно ГОСТ Р 34.12-2015.

\li Методы зашифрования/расшифрования данных c помощью алгоритмов блочного шифрования
    в следующих режимах (согласно ГОСТ Р 34.13-2015).
    -# Режим простой замены (electronic codebook mode, ЕСВ);
    -# Режим гаммирования (counter mode, CTR);
    -# Режим гаммирования с обратной связью по выходу (output feedback mode, OFB);
    -# Режим простой замены с зацеплением (cipher block chaining mode, СВС);
    -# Режим гаммирования с обратной связью по шифртексту (cipher feedback mode, CFB).

\li Алгоритмы выработки имитовставки (кода аутентичности сообщения)
    -# Алгоритм выработки имитовставки HMAC, регламентированный Р 50.1.113-2016 и
    основанный на применении функций хеширования «Стрибог-256» и «Стрибог-512»;
    -# Алгоритм выработки имитовставки, регламентированный ГОСТ Р 34.13-2015.

\li Алгоритм развертки ключа из пароля, регламентированный Р 50.1.111-2016.

\li Программные и биологические генераторы псевдо-случайных чисел.
    -# Линейный конгруэнтный генератор,
    -# Генератор-интерфейс, использующий чтение из произвольных файлов, в частности,
       файловых устройств /dev/random и /dev/urandom;
    -# Генератор-интерфейс к системному генератору псевдо-случайных значений, реализованному в ОС Windows.


Возможность сборки библиотеки `libakrypt` протестирована на следующих
аппаратных платформах: x86, x64, armv7 (все little endian). Библиотека
может быть использована под управлением следующих операционных систем:
\li OC семейства Linux,
\li FreeBSD,
\li ОС семейства Windows (от Windows XP и старше)
\li ReactOS,
\li MacOS.

Библиотека может быть собрана при помощи следующих компиляторов:
\li gcc (в частности mingw под Windows),
\li clang,
\li Microsoft Visual Studio (начиная с версии MSVC10),
\li TinyCC.

\b Внимание: в настоящее время библиотека находится в статусе разработки и не рекомендуется для
реальной защиты обрабатываемой пользователем информации.
*/

/* ----------------------------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------------------------------- */
/*! \page compile Сборка и установка библиотеки

\section compile_source_codes Получение исходных текстов библиотеки

Последняя версия
исходных текстов библиотеки может быть получена из git-репозитория на сайте github.com.
Для клонирования репозитория необходимо выполнить из комндной строки следующую команду.

\code

 git clone https://github.com/axelkenzo/libakrypt-0.x

\endcode

Необходимая документация и описание процедуры установки распределенной
системы управления версиями git может быть найдено [здесь](http://git-scm.com).

\section compile_cmake Система сборки

Основной системой сборки для библиотеки `libakrypt` является [cmake](https://cmake.org").
Необходимый набор программ и утилит может быть скачан с официального сайта программы.

\section compile_dependence Зависимости библиотеки

Библиотека `libakrypt` использует многопоточное выполнение некоторых криптографических преобразований,
поэтому ей необходим базовый набор функций для работы с потоками.
Библиотека использует стандартный набор функций, определяемый `POSIX Threads`.

В операционных системах семейства `Linux`, а также в `FreeBSD`,
эта функциональность входит в состав библиотеки `libc`
и не требует дополнительных действий при установке.

В операционной системе `Windows` многопоточность может быть реализована различными способами, при этом
способ реализации определяется используемым для сборки библиотеки компилятором.

В случае, если для сборки библиотеки используется компилятор `gcc`, входящий в состав набора библиотек и программ `MinGW`,
то доступ к многопоточной функциональности предоставляется средствами `MinGW`.

В случае, если для сборки библиотеки используется компилятор `Microsoft Visual C` (или любой другой,
поставляемый без библиотек, реализующих многопоточную функциональность),
то необходимо использование разделяемой
библиотеки `pthreads-w32` (POSIX Threads Library for Win32).
Перед сборкой библиотеки `libakrypt` Вам необходимо вручную установить заголовочные и библиотечные файлы
(`pthreadVC.lib` и `pthreadVC.dll`, а также заголовочные файлы `pthread.h`, `semaphore.h` и `sched.h`).
Подробное описание установки `pthreads-w32` может быть найдено
в документации по [pthreads-w32](http://sources.redhat.com/pthreads-win32).


\section compile_make_unix Сборка в Unix

Основной средой разработки библиотеки `libakrypt` является Linux,
поэтому процесс сборки под Unix-like операционными системами является максимально простой процедурой.

\subsection compile_make_unix1 Сборка статической версии библиотеки

Процесс получения исходных кодов описан в разделе \ref compile_source_codes.
После получения исходных кодов для сборки библиотеки выполните в консоли
следующую последовательность команд.

\code
mkdir build
cd build
cmake ../libakrypt-0.x
make
\endcode

В результате сборки, по-умолчанию, будет собрана статическая версия библиотеки --- `libakrypt-static.a`,
а также ряд тестовых примеров, использованные нами в разделах \ref libex и \ref guide.

\subsection compile_make_unix2 Сборка динамической версии библиотеки

Для сборки динамической версии библиотеки --- `libakrypt-shared.so`,
необходимо выполнить команду `cmake` с дополнительным параметром,
указывающим факт сборки динамически исполняемой версии библиотеки.

\code
cmake -D LIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
\endcode

Таким образом последовательность команд для сборки принимает вид

\code
mkdir build
cd build
cmake -D LIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
make
\endcode


\subsection compile_make_compilers Сборка различными компиляторами

Приведенная нами выше последовательность команд использует для сборки библиотеки
найденный `cmake` компилятор по-умолчанию -- в Linux это компилятор `gcc`, во FreeBSD и MacOS это `clang`.
Если Вы хотите использовать другой компилятор, то Вам необходимо задать при вызове `cmake` опцию `CMAKE_C_COMPILER`,
в явном виде определяющую имя компилятора.

Так, следующий вызов позволит произвести сборку библиотеки с помощью компилятора `clang`.
\code
cmake -D CMAKE_C_COMPILER=clang ../libakrypt-0.x
\endcode

Аналогично, следующий вызов позволит произвести сборку библиотеки с помощью компилятора `tcc` (Tiny C Compiler)
\code
cmake -D CMAKE_C_COMPILER=tcc ../libakrypt-0.x
\endcode

Отметим, что через опцию `CMAKE_C_COMPILER` можно указывать только те компиляторы,
которые поддерживаются `cmake`.
Перечень поддерживаемых компиляторов можно найти в документации по `cmake`
(см. раздел cmake-compile-features, supported compilers).

\subsection compile_make_ellcc Сборка для исполнения под другими платформами

Помимо традиционной сборки, когда библиотека компилируется и выполняется
на одной и той же аппаратной платформе, можно реализовать процесс сборки, при которой эти платформы различаются.

Мы рассмотрим случай в котором платформой сборки (host system)
является Linux, а платформой выполнения (target system) --- любая другая
операционная система, например, Windows или Linux на ARM Cortex.
Для такой сборки наиболее удобным является компилятор `clang`,
или более точно, его сборка из проекта [ellcc](http://ellcc.org).
В данном проекте компилятору `clang` присвоено имя `ecc`.

Обязательным параметром, который должен передаваться компилятору `ecc`
является платформа (target system), на которой будет выполняться компилируемая программа.
Например, для сборки библиотеки под 64-x битную версию Windows (на архитектуре x64),
можно выполнить следующую команду.

\code
cmake -D CMAKE_C_COMPILER=ecc -D CMAKE_C_FLAGS="-target x86_64-w64-mingw32" -D LIBAKRYPT_EXT=".exe" -D LIBAKRYPT_CONF="C:/Users/Default/AppData/Roaming/libakrypt" ../../libakrypt-0.x
\endcode

Прокомментируем приведенные выше параметры команды `cmake`.

\li Как и ранее, имя компилятора передается через переменную `CMAKE_C_COMPILER` (в нашем примере это `ecc`);
\li Платформа сборки передается в `cmake` через переменную `CMAKE_C_FLAGS` (-target x86_64-w64-mingw32);
\li Параметр `LIBAKRYPT_EXT` (.exe) указывает расширение для исполняемых файлов (это актуально только для Windows);
\li Параметр `LIBAKRYPT_CONF` - каталог, в котором будет находиться файл с техническими характеристиками
библиотеки `libakrypt` (более подробная информация о содержимом файла с техническими
характеристиками находится в разделе \ref construction_options).


\section compile_make_windows Сборка в Windows

Выше в разделе \ref compile_make_ellcc мы описали способ сборки библиотеки с
использованием компилятора `clang` из проекта `ellcc` (см. раздел \ref compile_make_ellcc).
Этот способ позволяет собирать только статическую версию библиотеки.
Вместе с тем, как динамическая, так и статическая версии
библиотеки могут быть успешно собраны под операционными системами семейства `Windows`.

\subsection compile_make_windows_msvc Сборка с использованием компилятора Miscrosoft Visual C
На настоящий момент протестирована успешная сборка библиотеки с помощью компилятора MSVC версий 10 и старше.

Для сборки библиотеки и тестовых примеров необходимо запустить командную строку `Visual Studio` и
создать каталог для сборки, например, выполнив команду
\code
mkdir build-msvc
\endcode

Далее, необходимо перейти в созданный каталог и запустить `cmake` для конфигурации сборки.

\code
cmake -G "NMake Makefiles" path
\endcode
где `path` это путь к каталогу, в котором находятся исходные коды библиотеки, например, `../libakrypt-0.x`.
Далее сборка библиотеки и тестовых примеров выполняется следующей командой
\code
nmake
\endcode

Указанный выше пример позволит создать статическую (.lib) библиотеку и тестовые примеры. Для сборки
динамической (.dll) версии библиотеки необходимо
дополнительно указать соответствующий флаг при вызове `cmake`.

\code
cmake -G "NMake Makefiles" -D LIBAKRYPT_SHARED_LIB=ON path
\endcode

Для запуска тестовых примеров,
собранных с поддержкой динамических библиотек,
необходимо, чтобы созданном Вами каталоге `build` находился файл `pthreadVC2.dll`.

\subsection compile_make_windows_mingw Сборка с использованием компилятора GCC
Для сборки компилятором `gcc` Вам необходимо установить набор программ из проекта `MinGW`.
Далее, в командной строке выполнить следующую последовательность команд.

\code
mkdir build
cd build
cmake -G "MinGW Makefiles" ../libakrypt-0.x
mingw32-make.exe
\endcode

Аналогично сказанному выше, для сборки
динамической библиотеки и тестовых примеров, соранных с поддержкой динамических библиотек,
необходимо выполнить следующую последовательность команд.

\code
mkdir build
cd build
cmake -G "MinGW Makefiles" -D LIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
mingw32-make.exe
\endcode

\section compile_flags Полные перечни флагов для сборки библиотеки

\subsection compile_flags_cmake Флаги cmake

Приведем перечень флагов, которые могут передаваться в `cmake` для настройки и уточнения значений
параметров сборки.

\li `LIBAKRYPT_CONF = path` (устанавливает каталог поиска файла `libakrypt.conf`, содержащего точные
значения технических характеристик библиотеки)

\li `LIBAKRYPT_EXT = extension` (устанавливает расширение для скомпилированных контрольных примеров,
используется, как правило, для установки расширения `.exe` в операционной системе `Windows`)

\li `LIBAKRYPT_GMP_TESTS = { ON, OFF }` (устанавливает надо или нет собирать тестовые примеры, использующие
вызовы функций библиотеки `libgmp`; данная функциональность нужна только для тестирования корректности реализации
арифметических операций с вычетами кольца больших целых чисел)

\li `LIBAKRYPT_SHARED_LIB = { ON, OFF }` (устанавливает надо или нет собирать динамическую версию библиотеки, по умолчанию,
флаг равен `OFF`)

\li `LIBAKRYPT_STATIC_LIB = { ON, OFF }` (устанавливает надо или нет собирать статическую версию библиотеки, по умолчанию,
флаг равен `ON`)

\li `LIBAKRYPT_BIG_ENDIAN = { ON, OFF }` (в случае, когда флаг равен `ON`, используются фрагметны исходного кода для
выполнения на big-endian архитектуре; по умолчанию, флаг равен `OFF`)

\subsection compile_flags_source Флаги исходных кодов

Приведем полный перечень флагов компиляции, передаваемых при сборке исходных кодов библиотеки и примеров
с помощью директивы `-D`.
В штатном режиме сборки поиск файлов
и установка указанных флагов выполняется программой `cmake`.

\li `LIBAKRYPT_OPTIONS_PATH = path` (устанавливает каталог для поиска файла `libakrypt.conf`, содержащего точные
значения технических характеристик библиотеки)
\li `LIBAKRYPT_VERSION = version` (устанавливает номер библиотеки)

\li `LIBAKRYPT_HAVE_SYSLOG_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `syslog.h`)
\li `LIBAKRYPT_HAVE_UNISTD_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `unistd.h`)
\li `LIBAKRYPT_HAVE_FCNTL_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `fcntl.h`)
\li `LIBAKRYPT_HAVE_LIMITS_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `limits.h`)
\li `LIBAKRYPT_HAVE_GETOPT_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `getopt.h`)
\li `LIBAKRYPT_HAVE_SYSMMAN_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `sys/mman.h`)
\li `LIBAKRYPT_HAVE_SYSSTAT_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `sys/stat.h`)
\li `LIBAKRYPT_HAVE_TERMIOS_H` (указывает на то, что при компиляции необходимо использовать заголовочный файл `termios.h`)

\li `LIBAKRYPT_BIG_ENDIAN` (указывает на то, что при компиляции необходимо использовать фрагменты кода для
выполнения на big-endian архитектуре)

\section compile_install Инсталляция библиотеки

В текущей версии библиотеки поддерживается процесс
инсталляции библиотеки только под Unix-like операционными системами.

\subsection compile_install_unix Инсталляция в Unix

По умолчанию предполагается, что библиотека будет установлена в каталог `/usr/local`.
Для изменения этого каталога
можно передать в `cmake` путь установки в явном виде. Например, следующий вызов позволяет
установить библиотеку в католог `/usr`.
\code
cmake -DCMAKE_INSTALL_PREFIX=/usr ../libakrypt-0.x
\endcode

Для инсталляции библиотеки достаточно выполнить команду

\code
make install
\endcode

\b Внимание. Команда инсталляции библиотеки должна выполняться с правами суперпользователя.

\section compile_doc_linux Сборка документации

Для сборки документациии необходимо установить
программу [Doxygen](http://www.doxygen.org/index.html).
Данная программа позволяет создавать документацию в формате `html`.
Сборка документации может быть выполнена следующей простой командой.

\code
make doc
\endcode

Если у Вас  установлена система подготовки документации LaTex,
то указанный вызов также создаст документацию в формате `pdf`.

Команда `make doc` должна выполняться в том же каталоге,
в котором происходила сборка библиотеки. После выполнения команды,
в каталоге сборки должны появиться

\li файл `libakrypt-doc-0.x.pdf`, содержащий документацию в формате PDF (файл формируется с помощью системы подготовки
  документации LaTeX),
\li файл `libakrypt-0.x.qch`, содержащий документацию в формате QCH (удобно интегрируется в среду разработки QtCreator),
\li архив `libakrypt-html-0.x.tar.bz2`, содержащий в архивированном виде
  документацию к библиотеке в формате HTML.

*/



/* ----------------------------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------------------------------- */
/*! \page libex Инструкция по встраиванию

*/

/* ----------------------------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------------------------------- */
/*! \page guide Принципы реализации

Библиотека `libakrypt` реализует два уровня интерфейсов к криптографическим преобразованиям.
Первый уровень - внешний интерфейс, предоставляемый файлом \ref libakrypt.h,
был рассмотрен в главе \ref libex. Напомним, что именно
внешний интерфейс должен использоваться прикладным программным обеспечением для
доступа к криптографческим механизмам, реализуемым библиотекой.

В этой главе мы рассмотрим внутренний интерфейс библиотеки,
доступ к которому ограничен по соображениям безопасности.
Мы также опишем принципы реализации основных функциональных возможностей библиотеки
и приведем примеры использования и модификации функций библиотеки.

\section guide_hash Алгоритмы бесключевого хеширования

Для создания единообразного подхода к реализации алгоритмов бесключевого хеширования в библиотеке
определяется структура \ref hash.

\code
 #include <ak_hash.h>

 struct hash {
   size_t bsize; // размер обрабатываемого блока входных данных
   size_t hsize; //  размер выходного блока
   ak_pointer data; // указатель на внутренние данные контекста
   ak_oid oid;   // OID алгоритма хеширования

   ak_function_mac_clean *clean; // функция очистки контекста
   ak_function_mac_update *update; // функция обновления состояния контекста
   ak_function_mac_finalize *finalize; // функция получения конечного результата
 };
\endcode

Структура описывает данные, необходимые для корректной работы, а также
три указателя на функции.
После инициализации объекта данной структуры значения указателей
содержат ссылки на конкретный алгоритм бесключевого хеширования.

Объекты struct \ref hash должны инициализироваться с помощью производящих функций, см. \ref ak_hash.h,
в частности следующих
\li int ak_hash_create_gosthash94();
\li int ak_hash_create_gosthash94_csp();
\li int ak_hash_create_streebog256();
\li int ak_hash_create_streebog512();
\li int ak_hash_create_oid().

Каждая из указанных функций определяет значения полей объекта struct \ref hash в соответствии с тем алгоритмом,
который содержится в ее названии.
При этом инициализируются указатели на три определенные функции:
функцию очистки (`clean`), функцию обновления внутреннего состояния (`update`)
и функцию возврата результата вычислений (`finalize`).

При этом предполагается, что действие `update`
может обрабатывать только данные, длина которых в байтах кратна длине блока
обрабатываемых данных, см. поле `bsize` (данное значение жестко фиксируется при описании алгоритма).
Такое поведение в точности соответствует подходу, принятому при математическом описании алгоритмов бесключевого хеширования.
Вопросами обработки данных произвольной длины занимается класс \ref compress.

Более того, вызов функции `fimalize` не изменяет внутреннее состояние и производит вычисления с локальной
копией текущего состояния. Такой подход позволяет вычислять хеш-код не только для всей последовательности данных,
но и для ее фрагментов.

Внутреннее состояние алгоритма бесключевого хеширования \ref hash может описываться
произвольной структурой данных.
Данная структура должна определяться в конкретной реализации алгоритма хеширования,
создаваться в динамической памяти при вызове производящей функции, а указатель на структуру должен помещаться в поле `data`
(использование одной статически выделенной структуры для нескольких объектов может привести к неверным результатам).

В текущей реализации билиотеки используются следующие структуры, описывающие внутренние состояния
\li struct \ref gosthash94 (для алгоритма из ГОСТ Р 34.11-94),
\li struct \ref streebog (для двух алгоритмов из ГОСТ Р 34.11-2012).

Уничтожение созданного ранее объекта производится с помощью функции ak_hash_destroy(),
которая не только обнуляет все значения, но и освобождает память из под структуры с внутренним состоянием.

\subsection guide_hash_create Создание, использование и удаление объектов

Общая схема использования объектов struct \ref hash заключается в следующем.

-# Определить объект (переменную типа struct \ref hash) в статической или динамической
   памяти (с использованием функции malloc()).
-# Инициализировать объект класса путем вызова соответствующей производящей функции, список см. выше.
-# Выработать хеш-код (код целостности) от заданной области памяти или заданного файла.
-# Уничтожить объект класса путем вызова функции ak_hash_destroy(). Если объект был
   создан в динамической памяти,
    то для уничтожения необходимо использовать функцию ak_hash_delete().

Следующий пример (\ref example-internal-hash01.c) демонстрирует процесс создания,
удаления и использования объектов типа struct \ref hash.

\include examples/example-internal-hash01.c


\subsection guide_hash_data Хеширование данных

Существует два типа ситуаций, в которых требуется
вычисление значений функций бесключевого хеширования. В первой ситуации
размер данных, подлежащих хешированию, известен заранее.
В этом случае библиотека предоставляет две функции
внутреннего интерфеса, а именно,

\li ak_hash_context_ptr() - вычисление значения функции бесключевого хеширования
для данных с фиксированной длиной; алгоритм хеширования определяется указателем на объект struct \ref hash,
который передается в качестве первого аргумента функции;

\li ak_hash_context_file() - вычисление значения функции бесключевого хеширования для заданного файла.

Пример использования указанных функций приведен выше (см. файл \ref example-internal-hash01.c).

Во второй ситуации окончательная длина данных неизвестна,
поэтому обработка может вестись фрагментами, длина которых совпадает (или кратна) длине
блока обрабатываемых данных.
В этом случае, для каждого фрагмента данных должна вызываться функция `update`, изменяющая
внутреннее состояние объекта. При завершении вычислений должна вызываться
функция `finalize`, на вход которой также могут подаваться хешируемые данные.
При этом длина данных, подаваемых на вход функции `finalize` может быть равна нулю и
не должна превышать длины блока обрабатываемых данных.

Пример последовательного использования обеих подходов
приводится в следующем примере (см. файл \ref example-internal-hash02.c)

\include examples/example-internal-hash02.c

В случае, когда необходимо определить хеш-код данных,
которые поступают на обработку фрагментами произвольной длины,
необходимо воспользоваться методами класса \ref compress. Данный класс специально разработан для этой цели.

Еще один работающий пример,
иллюстрирующий множество различных подходов к вычислению кодов целостности для файлов,
может быть найден в файле \ref example-internal-hash03.c

\section guide_mac Алгоритмы выработки имитовставки

\section guide_compress Механизм итерационного сжатия информации

В случае, когда сжимаемая информация не может быть представлена в виде
фрагментов фиксированной длины, для ее обработки может использоваться класс,
определяемый структурой \ref compress.

\code
 #include <ak_compress.h>

 struct compress
{

  ak_uint8 *data; // массив, предназначенный для временного хранения обрабатываемых данных
  size_t bsize;   // длина блока обрабатываемых данных
  size_t hsize;   // длина хеш-кода (результата применения сжимающего отображения)
  size_t length;  // количество элементов, хранящихся в массиве data
  ak_pointer ctx; // указатель на контекст сжимающего преобразования
  ak_function_mac_clean *clean; // функция очистки контекста сжимающего
                                // преобразования
  ak_function_mac_update *update; // функция обработки данных, длина которых
                                  // кратна длине обрабатываемого блока
  ak_function_mac_finalize *finalize; // функция завершения сжимающего
                                      // преобразования
};
\endcode

Данная структура реализует буфер, в котором накапливаются данные перед тем,
как быть переданными на обработку.
Общая схема использования объектов класса \ref compress заключается в следующем.

-# Определить объект (переменную типа struct \ref compress) в статической или динамической
   памяти (с использованием функции malloc()).
-# Инициализировать объект класса путем вызова соответствующей производящей функции.
   В качестве производящих функций, на настоящий момент, реализованы следующие.

   \li функция int ak_compress_create_hash() для вычислений код целостности (бесключевых функций хеширования),
   \li функция int ak_compress_create_mac() для вычисления значений имитовставок.

-# В случае, если используется ключевое преобразование, установить секретный ключ.
-# Выработать результат сжимающего преобразования (код целостности или имитовставку)
   от последовательности фрагментов произвольной длины.
-# Уничтожить объект класса путем вызова функции ak_compress_destroy(). Если объект был
   создан в динамической памяти, то для его уничтожения необходимо использовать функцию ak_compress_delete().

Коротко рассмотрим способы применения объектов класса \ref compress
для вычисления различных сжимающих преобразований.

\subsection guide_compress_hash Хеширование данных

Для хеширования данных необходимо
сначала создать и инициализировать объект класса \ref hash. После этого,
инициализировать объект класса \ref compress и провести вычисления.
Пример такого подхода иллюстрирует следующий тестовый пример (см. файл \ref example-internal-compress01.c)

\include examples/example-internal-compress01.c



\section guide_glossary Приложение А. Терминология и принятые обозначения

- \b Класс (class) - структура, определенная через определитель typedef и содержащая в себе как данные,
так и указатели на функции, обрабатывающие данные, хранящиеся в структуре.
Один класс может соответствовать как одному, так и нескольким однотипным криптографическим механизмам,
допускающим схожую программную реализацию.

- \b Объект (object) - экземпляр класса, однозначно связанный с конкретным
криптографическим механизмом.

- \b Контекст (context) - указатель на объект (экземпляр заданного класса).
Контекст может быть определен только в случае, когда существует связанный с ним объект.
В противном случае контекст обязан принимать значение NULL.

- \b Дескриптор (handle) - натуральное число, являющееся идентификатором конкретного объекта или его контекста,
и обеспечивающее доступ к объекту.

- \b Производящая \b функция - реализованная в библиотеке функция, создающая объекты заданного класса.

\section guide_names Приложение Б. Принципы наименования функций библиотеки.

Для всех функций библиотеки принят единый принцип наименования.
Имя функции строится следующим образом

\code
  ak_класс_действие
  ak_класс_действие_объект
  ak_класс_действие_предлог_действие2
\endcode

где

\li `ak`        - префикс библиотеки,
\li `класс`     - класс, над объектами которого производятся заданные действия,
\li `действие`  - основное действие над объектом,
\li `действие2` - следующее действие над объектом,
\li `предлог`   - направление действия,
\li `объект`    - объект, на который направлено действие, либо объект,
                являющийся параметром действия.

\subsection guide_names_rules Основные действия

При выборе имен функций использовались следующие основные действия.

\li  `create`    - действие, которое реализует конструктор (инициализацию) объекта, под который уже
                 выделена память - статическая или динамическая.
\li  `new`       - действие, которое выделяет динамическую память под объект, а после его
                 инициализирует с помощью действия `create`;
                 фактически, это конструктор, возвращающий указатель на созданный объект.

\li  `destroy`   - действие, которое уничтожает поля существующего объекта;
                 память, выделенная под объект, не освобождается.
\li  `delete`    - действие, которое позволяет сначала уничтожить поля существующего объекта
                (с помощью действия `destroy`), а потом и выделенную под объект память.
\li  `set`       - присвоить объекту некоторое значение.
\li  `get`       - получить характеристику объекта (значение некоторого поля) без ее изменения,
                 как правило данное действие возвращает копию значения, хранящегося в объекте.

\subsection guide_names_to Предлоги

\li `to`        - действие направлено от объекта к объекту2 (в большинстве случаем использование предлога to
                означает процедуру преобразования объекта, в результате которой создается новый объект,
                удаление которого, как правило, возлагается на пользователя биьлиотеки).
\li `from`      - действие направлено к объекту от объекта2 (в большинстве случаев
                функция реализует операцию присвоения нового значения объекту)
\li `and`       - предлог для связи нескольких действий над объектом

\subsection guide_names_order Порядок следования аргументов функции

\li  `арг1`      - первый аргумент это объект, с которым выполняется указанное действие
                 (во всех арифметических функциях - являющийся результатом действия)
\li  `арг2`, ... - объекты, участвующие в действии


*/

/* ----------------------------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------------------------------- */


/* ----------------------------------------------------------------------------------------------- */
/* ----------------------------------------------------------------------------------------------- */
