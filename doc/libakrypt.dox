/*!
\mainpage Аннотация

Библиотека libakrypt представляет собой модуль, реализующий криптографические
преобразования для отечественного СКЗИ проекта OpenSKZI. Цель данного проекта заключается
в создании СКЗИ с открытым исходным кодом, удовлетворяющего отечественным
"Принципам разработки и модернизации шифровальных (криптографических) средств защиты информации"
по классу КС3.

Библиотека написана на языке C и реализует механизмы генерации, хранения, экспорта и импорта ключей, а также
основные отечественные криптографические механизмы, включая алгоритмы шифрования/расшифрования данных, алгоритмы хеширования,
алгоритмы выработки и проверки электронной подписи и имитовставки.

Билиотека может исполняться на следующих архитектурах:
\li x86, x64
\li amd64
\li armv7

Библиотека может исполняться под управлением следующих операционных систем:
\li OC семейства Linux,
\li ОС семейства Windows (от Windows XP и старше)
\li ReactOS

Библиотека может быть собрана при помощи следующих компиляторов:
\li gcc (в частности mingw под Windows),
\li clang
\li Microsoft Visual Studio (начиная с версии MSVC10),
\li TinyCC.

\section principles Принципы построения

\li минимальная зависимость от внешних библиотек
\li максимальнаяч переносимость
\li минимизация кода (только то, что имеет смысл) и минимизация пользовательского интерфейса

\li работа с контекстами (указателями на структуры) и идентификаторами
\li использование производящих функций для создания контекстов
\li


\page intro Введение в библиотеку libakrypt

\section intro_features Основные возможности

В текущей версии библиотеки реализованы следующие криптографические механизмы:

\li Бесключевые функции хеширования.
    -# Функция хеширования, регламентируемая отечественным стандартом ГОСТ Р 34.11-94
       (в настоящее время стандарт отменен).
    -# Функции хеширования Стрибог-256 и Стрибог-512, регламентируемые
       отечественным стандартом ГОСТ Р 34.11-2012.
    -# Функции хеширования SHA2-256 и SHA2-512, регламентируемые американским
       стандартом FISP 180-3
       (в настоящее время принята третья настоящего стандарта FIPS 180-4).

\li Алгоритмы блочного шифрования данных.
    -# Алгоритм блочного шифрования ГОСТ 28147-89 с длиной блока 64 бита и поддержкой
       различных таблиц замен (в настоящее время, согласно ГОСТ Р 34.12-2015, этот алгоритм
       с фиксированными таблицами замен носит название Магма).
    -# Алгоритм блочного шифрования Кузнечик с длиной блока 128 бит (согласно ГОСТ Р 34.12-2015).

\li Алгоритмы зашифрования/расшифрования сообщений c помощью алгоритмов блочного шифрования
    в следующих режимах (согласно ГОСТ Р 34.13-2015).
    -# Режим простой замены (electronic codebook mode, ЕСВ),
    -# Режим гаммирования (counter mode, CTR),
    -# Режим гаммирования с обратной связью по выходу (output feedback mode, OFB),
    -# Режим простой замены с зацеплением (cipher block chaining mode, СВС),
    -# Режим гаммирования с обратной связью по шифртексту (cipher feedback mode, CFB),
    -# Режим выработки имитовставки (message authentication code mode).

\li Программные генераторы псевдо случайных чисел (ПДСЧ).
    -# Линейный конгруэнтный генератор,
    -# Генератор, использующий чтение из произвольных файлов, в частности,
       файловых устройств /dev/random и /dev/urandom.

\section intro_dependence Зависимости библиотеки

Для корректной сборки и выполнения библиотеки libakrypt необходимо
удовлетворить ряд внешних зависимостей.

\subsection intro_dependence_cmake CMake

Системой сборки для библиотеки libakrypt является <a href="https://cmake.org">CMake</a>.
Необходимый набор программ и утилит может быть скачан с официального сайта программы.

\subsection intro_dependence_pthreads PThreads

Для корректной сборки и работы библиотеке libakrypt необходима
стандартная библиотека libc языка C или любая другая библиотека с аналогичной функциональностью.

Библиотека libakrypt использует многопоточное выполнение некоторых своих
функций, поэтому ей необходим базовый набор функций для работы с потоками.
В операционной системе Linux эта функциональность также входит в состав библиотеки libc.

В операционной системе семейства Windows при сборке и выполнении функций библиотеки libakrypt
необходимо использование разделяемой
библиотеки <a href=http://sources.redhat.com/pthreads-win32>pthreads-w32</a> (POSIX Threads Library for Win32).
Перед сборкой библиотеки libakrypt Вам необходимо вручную установить
необходимые файлы pthreads-w32.

\section intro_make Сборка библиотеки из исходных кодов, инсталляция и настройка

Далее мы опишем процесс сборки библиотеки libakrypt из исходных текстов.

\subsection intro_make_unix Сборка в Linux

Linux является основной средой разработки библиотеки libakrypt,
в связи с этим сборка в Linux является максимально простой процедурой.
Скачайте архив с исходными текстами библиотеки вида libakrypt-0.x.tar.bz2 и
сохраните его.
Перейдите в консоли в каталог с сохраненной библиотекой и для разархивации архива с исходными кодами
выполните следующую команду.
\code
tar -xjvf libakrypt-0.x.tar.bz2
\endcode

После ее выполнения должен появиться каталог libakrypt-0.x, где x это
номер текущей версии библиотеки.
Далее, для сборки библиотеки выполните следующую последовательность команд.

\code
mkdir build
cd build
cmake ../libakrypt-0.x
make
\endcode

В результате сборки, по-умолчанию, будет собрана
статическая версия библиотеки --- libakrypt-static.a,
а также тестовые примеры, использованные нами в разделе \ref libex.

Для сборки не только статической, но и динамической версии библиотеки
необходимо выполнить команду cmake с дополнительными параметрами.

\code
cmake -DLIBAKRYPT_SHARED_LIB=ON ../libakrypt-0.x
\endcode

\subsubsection intro_make_compilers Сборка различными компиляторами

Приведенная нами выше последовательность команд использует для сборки библиотеки
компилятор по-умолчанию, то есть gcc. Если Вы хотите использовать другой компилятор,
то Вам необходимо передать в вызов cmake дополнительные опции.
Так, следующий вызов позволит произвести сборку библиотеки с помощью компилятора clang.
\code
cmake -DCMAKE_C_COMPILER=clang ../libakrypt-0.x
\endcode

Аналогично, следующий вызов позволит произвести сборку библиотеки с помощью
компилятора tcc (Tiny C Compiler)
\code
cmake -DCMAKE_C_COMPILER=tcc ../libakrypt-0.x
\endcode

Отметим, что через опцию CMAKE_C_COMPILER можно указывать только те компиляторы, которые установлены в Вашей
системе и поддерживаются cmake.
Перечень поддерживаемых компиляторов можно найти в документации по cmake (см. раздел cmake-compile-features, supported compilers).

\subsubsection intro_make_ellcc Сборка под другие платформы

Помимо традиционной сборки, когда библиотека компилируется и выполняется
на одной и той же платформе, моно использовать
сборку, при которой эти платформы различаются.

Мы рассмотрим случай в котором платформой сборки (host system)
является Linux, а платформой выполнения (target system) --- любая другая
операционная система, например, Windows или Linux на ARM Cortex.
Для такой сборки наиболее удобным является компилятор clang,
или более точно, его сборка из проекта <a href=http://ellcc.org>ellcc</a>.
В данном проекте компилятору clang присвоено имя ecc.

Обязательным параметром, который должен передаваться компилятору ecc
является платформа (target system), на которой будет выполняться компилируемая программа.
Например, для сборки библиотеки под 64-x битную версию Windows (на архитектуре x64),
можно выполнить следующую команду.

\code
cmake -DCMAKE_C_COMPILER=ecc -DCMAKE_C_FLAGS="-target x86_64-w64-mingw32" -DLIBAKRYPT_EXT=".exe" -DLIBAKRYPT_CONF="C:/Users/Alex/AppData/Roaming/libakrypt" ../libakrypt-0.x
\endcode

Прокомментируем приведенные выше параметры команды cmake.

Как и ранее, имя компилятора передается через переменную CMAKE_C_COMPILER (в нашем примере это ecc),
платформа сборки передаается в cmake через переменную CMAKE_C_FLAGS (-target x86_64-w64-mingw32).
Параметр LIBAKRYPT_EXT (.exe) указывает расширение для исполняемых файлов (это актуально только для Windows),
а параметр LIBAKRYPT_CONF - каталог, в котором будет находиться файл с эксплуатационными характеристиками
библиотеки. Более подробно об указанных характеристиках изложено в разделе \ref options.

\subsubsection intro_make_install Инсталляция библиотеки

По умолчанию предполагается, что библиотека будет установлена в каталог /usr/local.
Для изменения этого каталога
можно передать в cmake путь установки в явном виде. Например, следующий вызов позволяет
установить библиотеку в католог /usr.
\code
cmake -DCMAKE_INSTALL_PREFIX=/usr ../libakrypt-0.x
\endcode

Для инсталляции библиотеки достаточно выполнить команду

\code
make install
\endcode

\b Внимание. Команда инсталляции библиотеки должна выполняться с правами суперпользователя.

\subsubsection intro_doc_linux Сборка документации в Linux

В операционной системе Linux Вы можете воспользоваться
готовыми средствами для создания документации к библиотеке libakrypt.

Если у Вас установлен пакет <a href="http://www.doxygen.org/index.html">Doxygen</a>,
а также установлена система подготовки документации LaTex,
то сборка документации может быть выполнена следующей простой командой.

\code
make doc
\endcode

Данная команда должна выполняться в том же каталоге,
в котором происходила сборка библиотеки. После выполнения команды,
в каталоге сборки должны появиться

- файл libakrypt-doc-0.x.pdf, содержащий документацию в формате PDF (файл формируется с помощью системы подготовки документации LaTeX),
- файл libakrypt-0.x.qch, содержащий документацию в формате QCH (удобно интегрируется в среду разработки QtCreator),
- архив libakrypt-html-0.x.tar.bz2, содержащий в архивированном виде
  документацию к библиотеке в формате HTML.

\subsection intro_make_windows Сборка в Windows

Выше мы описали способ сборки библиотеки с использованием компилятора clang из проекта ellcc (см. раздел \ref intro_make_ellcc).
Этот способ позволяет собирать исполняемые файлы,
однако он не позволяет корректно собрать динамическую библиотеку.

Вместе с тем, библиотека libakrypt может быть напрямую собрана в операционной системе Windows.
Далее мы приведем описание процесса сборки.

\subsubsection intro_make_windows_msvc Сборка с использованием компилятора Miscrosoft C
В настоящее время протестирована сборка библиотеки
с помощью компиляторов MSVC версий 10 и старше.

Для сборки библиотеки и тестовых примеров с помощью компилятора MSVC
необходимо запустить командную строку Visual Studio и
создать каталог для сборки, например, выполнив команду
\code
mkdir build-msvc
\endcode

Далее, необходимо перейти в созданный каталог и запустить cmake
для конфигурации сборки.

\code
cmake -G"NMake Makefiles" path
\endcode
где path это путь к каталогу, в котором находятся исходные коды библиотеки, например, ../libakrypt-0.x.
Далее сборка библиотеки и тестовых примеров выполняется следующей командой
\code
nmake
\endcode

Для запуска собранных тестовых примеров необходимо, чтобы созданном Вами каталоге build
находился файл pthreadVC2.dll.

\subsubsection intro_make_windows_mingw Сборка с использованием MinGW
Для сборки компилятором gcc
Вам необходимо установить набор программ из проекта MinGW.
Далее, в командной строке

\code
cd build
cmake -G "MinGW Makefiles" ../libakrypt-0.x
mingw32-make.exe
\endcode

\subsection intro_make_hands Сборка своими руками
В ряде случаев возникают ситуации в которых сборка библиотеки libakrypt
не может быть произведена с помощью системы сборки cmake. Как правило такая ситуация возникает
в случае, когда инсталляция cmake невозможна, либо используется незнакомый cmake компилятор.
В таких случаях из командной строки возможна сборка библиотеки, а также тестовых примеров.

Общая схема командной строки для сборки тестовых примеров проста:

- компилятор
- параметры сборки
- имена файлов
- имя результирующей программы.

Следующий простой вызов из командной строки в Linux
позволяет собрать один из тестовых примеров (в корневом каталоге библиотеки).

\code
gcc -Isource -O3 -DLIBAKRYPT_CONF=\"/etc\" source/*.c examples/example-intro.c -o intro
\endcode

Как мы говорили выше, параметр LIBAKRYPT_CONF пределяет каталог в котором библиотека
будет искать файл с настройками (подробнее смотри в разделе \ref options).
Если данный параметр не указан, то месторасположение файла с настройками будет
выбрано библиотекой самостоятельно.

\section intro_internet_resources Интернет ресурсы

<a href="http://www.openskzi.ru">Проект OpenSKZI</a>

\section intro_steps Этапы разработки и нумерация версий

При разработке библиотеки нами были приняты следующая последовательность разработки
и принцип нумерации версий библиотеки.

\li Версия 0.3.х - реализация бесключевых функций хеширования
                   (последняя версия в этой ветке 0.3.28)

\li Версия 0.4.х - реализация алгоритмов блочного шифрования и режимов их использования
                   в соответствии с ГОСТ Р 34.12-2015 и ГОСТ Р 34.13-2015.

\li Версия 0.5.х - реализация механизмов выработки кодов аутентичности (HMAC и AEAD)

\li Версия 0.6.х - реализация ключевого хранилища

\li Версия 0.7a.х - реализация вычислений с эллиптическими кривыми (сделано к версии 0.4.26)
                    и алгоритмов выработки и проверки электронной подписи в соответствии ГОСТ Р 34.10-2012.

\li Версия 0.7b.х - разборка/создание ASN1 контейнеров

\li Версия 0.7с.х - сертификаты открытых ключей

\li Версия 0.8.x - реализация гибридных алгоритмов шифрования

\li Версия 0.9.x - реализация механизмов хранения ключевой информации в памяти
                  (данная функциональность не зависит от предыдущих версий)

\li Версия 0.10.x -

\li Версия 0.11.x -


\page libex Правила использования библиотеки

В настоящей главе мы приводим рекомендации по встраиванию библиотеки libakrypt
в программные средства. Рекомендации оформлены в виде примеров,
иллюстрирующих основные функциональные особенности библиотеки.

Перечень экспортируемых библиотекой констант, типов данных и функций содержится в заголовочном
файле \ref libakrypt.h. Для встраивания библиотек должны использоваться только сущности,
определенные в этом файле.
Вызов не экспортируемых функций библиотеки считается недопустимым и
не должен применяться при ее использовании.

\section tinit Инициализация и настройка библиотеки

\subsection tinit_libex1 Пример инициализации библиотеки

Перед тем, как вызывать какие-либо функции библиотеки, необходимо провести ее инициализацию.
Для этого предназначена функция ak_libakrypt_create() - она выполняет проверку корректности работы
криптографических механизмов и инициализирует внутренние переменные библиотеки.

Простейшая программа (\ref exampla-intro.c), использующая библиотеку,
должна выглядеть следующим образом.

\include examples/example-intro.c

Используемая нами для инициализации библиотеки функция ak_libakrypt_create() принимает один параметр,
а именно, указатель на функцию, которая используется для вывода сообщений о работе или ошибках библиотеки.
В заголовочном файле \ref libakrypt.h содержится перечень из нескольких заранее предопределенных функций,
предназначенных для вывода сообщений.

\code
 int ak_function_log_stderr( const char * );
#ifdef __linux__
 int ak_function_log_syslog( const char * );
#endif
\endcode

Функция ak_function_log_stderr() использует для вывода сообщений стандартный поток вывода ошибок операционной системы.
Реализация данной функции доступна для всех операционных систем.

Функция ak_function_log_syslog() использует для вывода сообщений демон операционной системы Linux,
предназначенный для журналирования событий в системе. Реализация данной функции доступна только
в операционной системе Linux.

Пользователь может самостоятельно определить и использовать свою собственную функцию
вывода сообщений об ошибках Для этого он должен реализовать функцию, удовлетворяющую следующему определению.

\code
// Функция аудита
 typedef int ( ak_function_log )( const char * );
\endcode

Более подробно о принципах, на которых основан отбор выводимых сообщений,
можно узнать в разделе \ref audit.

В заключение раздела добавим, что завершение работы с функциями библиотеки должно производиться
при помощи вызова функции ak_libakrypt_destroy(). Данная функция останавливает внутренние механизмы
и освобождает используемую библиотекой память.

\subsection tinit_libex2 Пример установки пользовательской функции аудита
Пользователь библиотеки libakrypt может настроить вывод сообщений библиотеки
удобным для него способом. Далее мы приведем простой пример (\ref example-log.c)
в котором используется функция ak_log_set_function(). Эта функция
устанавливает пользовательскую функцию аудита.

\include examples/example-log.c

Обратим внимание на то, что
вывод сообщений производится с помощью функции ak_log_set_message().


\section toid Идентификаторы криптографических механизмов

Идентификатор (Object IDentifier, OID) это уникальная последовательность чисел, разделенных точками.
OID'ы могут быть присвоены любому криптографическому механизму (алгоритму,
схеме, протоколу), а также параметрам этих механизмов.
Использование OID'ов позволяет однозначно определять тип криптографического механизма или
значения его параметров на этапе выполнения программы, а также
однозначно связывать данные (как правило ключевые) с алгоритмами, в которых эти данные
используются.

Конкретные значения OID реализуются с помощью контекстов класса \ref oid,
каждый объект которого содержит в себе
\li читаемое (пользователем библиотеки) имя OID,
\li идентификатор OID (последовательность чисел, разделенных точками),
\li тип криптографического механизма (элемент \ref ak_oid_engine),
    в качестве которого может выступать алгоритм или параметры алгоритма,
\li режим использования криптографического алгоритма (элемент \ref ak_oid_mode).

Ниже мы приведем несколько примеров использования OID'ов библиотеки.

\subsection toid_ex1 Получение перечня всех доступных идентификаторов библиотеки

Нижеследующая программа (\ref example-oid.c) позволяет вывести список всех
существующих OID'ов библиотеки. Для вывода используется перебор в цикле
всех возможных значений.

\include examples/example-oid.c

Отметим, что количество существующих OID'ов может быть получено с помощью вызова
функции ak_oids_get_count(). После чего,
конкретный контекст OID может быть получен с помощью вызова функции ak_oids_get_oid(),
аргументом которой является индекс OID'a во внутреннем массиве (целое число, принимающее значения от
нуля и меньшее, чем значение, возвращаемое функцией ak_oids_get_count()).

OID также может быть найден во внутреннем массиве по имени или по его идентификатору.
Для этого предназначены функции

\li ak_oids_find_by_name(),
\li ak_oids_find_by_id().

Функции поиска OID'ов могут быть использованы при переборе всех однотипных
криптографических механизмов, например, функций хеширования. Пример такого использования
мы приводим в разделе \ref thash_ex3.

\subsection toid_ex2 Добавление новых идентификаторов в библиотеку

В ряде случаев может возникнуть ситуация, когда необходимо использовать параметры алгоритмов,
не определенные в библиотеке в явном виде. В первую очередь это относится к
таблицам замен для алгоритма блочного шифрования ГОСТ 28147-89 (Магма), а также к параметрам
эллиптических кривых, используемых при выработке электронной подписи.

В такой ситуации библиотека представляет ряд интерфейсов для добавления пользовательских
параметров. Так, для добавления таблиц замен алгоритма ГОСТ 28147-89 (Магма) может быть использована
функция ak_oids_add_magma_tables(). Пример использования этой функции приводится
ниже (\ref example-oid-magma.c).

\include examples/example-oid-magma.c

Отметим, что в приведенном примере общее число OID'ов
библиотеки выводится в самом начале программы, еще
до добавления нового значения.


\section trand Генерация псевдо-случайных чисел

Для генерации псевдо-случайных чисел в библиотеке реализован класс \ref random,
который предоставляет унифицированный интерфейс для инициализации, удаления генераторов,
а также для выработки пседвдо случайных чисел.

Перечень реализованных генераторов был приведен нами ранее
в разделе \ref intro_features.
Ниже мы приведем два примера использования генераторов.

\subsection trand_lcg Пример использования линейного конгруэнтного генератора

Простейшим псевдо случайным генератором, который может быть использован для генерации
псевдослучайных последовательностей является линейный конгруэнтный генератор
(linear congruence generator). Этот генератор вырабатывает последовательность внутренних состояний,
удовлетворяющую линейному сравнению \f$ x_{n+1} \equiv a\cdot x_n + c \pmod{2^{64}}, \f$
в котором константы a и c удовлетворяют равенствам
\f$ a = 125643267795740073 \f$ и \f$ b = 506098983240188723 \f$.

Далее, последовательность внутренних состояний преобразуется в последовательность
байт по следующему правилу
\f$ \gamma_n = \displaystyle\frac{x_n - \hat x_n}{2^{24}} \pmod{256}, \f$
где \f$\hat x_n \equiv x_n \pmod{2^{24}} \f$
(приведенные формулы означают, что если мы рассмотрим \f$ x_n \f$ как восьмибайтный вектор,
то \f$ \gamma_n \f$ есть четвертый младший байт).

Ниже мы приводим простейший пример использования данного генератора.

\include examples/example-random.c

В начале мы создаем контекст генератора при помощи
производящей функции ak_random_new_lcg(). Данная функция
инициализирует начальное состояние генератора, используя для этого
вызов функции ak_random_value().

Далее мы используем вызовы функций ak_random_uint64() и ak_random_ptr()
для генерации псевдослучайных значений. Вызов функции ak_random_randomize_uint64()
позволяет установить новое начальное значение генератора.
Отметим, что установки начального значения также может быть использована функция
ak_random_randomize_ptr().

\subsection trand_file Пример использования файлового устройства /dev/random

Операционная система Linux предоставляет пользователям
файловое устройство /dev/random, которое может быть использовано
для получения псевдо случайных значений.
В библиотеке реализован специальный генератор \ref random_file,
который позволяет считывать значения из произвольных файлов и, в частности,
из /dev/random.

Пример использования такого генератора приводится ниже.

\include examples/example-dev-random.c

В начале мы создаем генератор с помощью производящей функции ak_random_new_file(),
аргументом которой является имя файла из которого считываются псевдо случайные значения.
Далее, мы получаем данные используя вызовы функций ak_random_uint8() и ak_random_ptr().

Отметим, что генератор производит считывание из файла циклически:
после того, как будет достигнут конец файла, чтение начинается с начала.
При этом, для файловых устройств типа /dev/random конец файла достигнуть быть не может.


\section thash Хеширование данных

Бесключевые функции хеширования очень активно используются в криптографических приложениях,
например, для контроля целостности данных (файлов) или при выработке электронной подписи.
Библиотека реализует контекст \ref hash, который обеспечивает реализацию
бесключевых функций хеширования и позволяет вычислить значение хеш-кода данных.
Перечень реализованных функций хеширования был приведен нами ранее
в разделе \ref intro_features.

\subsection thash_ex1 Пример хеширования данных

Для вычисления хеш-кода данных Вам необходимо выполнить последовательность из трех шагов
\li создать контекст с помощью производящей функции,
\li вычислить значение хеш-кода,
\li удалить контекст.

Приведем пример, иллюстрирующий описанную последовательность действий.

\include examples/example-hash.c

В приведенном примере для создания контекста, т.е. указателя на структуру данных \ref hash,
используется производящая функция
ak_hash_new_streebog(). В случае, если контекст создать не удается,
функция возвращает NULL.

Отметим, что производящие функции, позволяющие создать контекст функции хеширования,
носят однообразные названия, например
\li ak_hash_new_streebog256(),
\li ak_hash_new_streebog512(),
\li ak_hash_new_gosthash94().

Последняя функция принимает один аргумент, а именно, контекст OID,
определяющий таблицу замен согласно стандарту ГОСТ Р 34.11-94.

Далее в примеденном примере происходит
собственно вычисление хеш-кода от заданной области памяти,
представленной например, в виде массива данных.
Вычисление производятся с помощью функции ak_hash_data(),
а результат вычислений (хеш-код) помещается в новый буффер,
реализуемый классом \ref buffer. Данный буффер должен потом удаляться пользователем самостоятельно.

В случае, когда пользователь не хочет (или не может)
размещать хеш-код в оперативной памяти, он может передать в функцию
ak_hash_data() в качестве четвертого аргумента указатель на область памяти,
в которую будет помещен результат. Размер области памяти может быть вычислен заранее
с помощью функции ak_hash_get_code_size().

\subsection thash_ex3 Пример выбора функции хеширования по ее OID

Аналогично хешированию размещенных в оперативной памяти данных, пользователь
может выполнить хеширование файлов.
Для этого необходимо воспользоваться функцией ak_hash_file().
Приведем пример использования этой функции.

Одновременно мы покажем, как
для создания контекста функции хеширования может быть использован OID алгоритма.
Необходимость создания контекста функции хеширования по ее OID возникает
в приложениях, в которых пользователь самостоятельно выбирает алгоритм хеширования.

В следующем примере (\ref example-hash-oids.c) мы находим все алгоритмы бесключевого хеширования,
предоставляемые библиотекой и для каждого из них вычисляем хеш-код одного и того же файла.
Мы также сравниваем быстродействие реализованных в библиотеке алгоритмов.

\include examples/example-hash-oids.c

Также как и в примере \ref toid_ex1, мы перебираем все доступные OID библиотеки.
Для каждого найденного OID проверяем, является ли он бесключевой функцией хеширования.
Для это необходимо, чтобы engine (который мы получаем с помощью вызова функции ak_oid_get_engine())
был равен \ref hash_function, а режим использования
(который мы получаем с помощью вызова функции ak_oid_get_mode()) был равен \ref algorithm.

Далее, найденный OID используется для создания контекста функции хеширования
с помощью функции ak_hash_new_oid(). Заданный заранее файл хешируется с помощью вызова функции
ak_hash_file(), а результат помещается во временный буффер.

\subsection thash_ex2 Пример хеширования фрагментированных данных

В предыдущих примерах до вызова функции хеширования нам был известен
размер хешируемых данных. Вместе с тем, на практике
возникают ситуации, когда обработка данных должна начинаться до
того момента, как станет известен общий размер хешируемых данных. Такая ситуация возникает, например, при
вычислении хеш-кода от информации, получаемой из сети (потоковых данных) --
видео-файлов, аудио информации или просто файлов большого размера.

В этом случае, алгоритм хеширования допускает
возможность начать вычисления до окончания приема данных. Общая последовательность
такой реализации алгоритма хеширования выглядит следующим образом

\li создать контекст с помощью производящей функции,
\li для каждого нового фрагмента обрабатываемой последовательности обновить
    внутренние состояния контекста,
\li после окончания приема данных закрыть контекст и получить значение хеш-кода,
\li удалить контекст.

Описанная выше последовательность действий может быть проиллюстрирована следующим примером.
Отметим, что
подобная схема реализована в функции ak_hash_file()
для оптимизации операций чтения с диска при хешировании файлов.

\include examples/example-hash-parts.c

В приведенном примере данные для хеширования разбиваются на parts фрагментов, при этом,
длина каждого фрагмента равна значению, которое возвращается функцией ak_hash_get_block_size().
На практике можно использовать фрагменты, кратные этой величине.

Далее, каждый фрагмент обрабатывается с помощью функции ak_hash_update(), а завершается
преобразование данных вызовом функции ak_hash_finalize(), которая возвращает результат
вычислений спсобом, аналогичным функции ak_hash_data().



\section encrypt Шифрование информации

Теперь мы опишем действия,
которые необходимы для зашифрования и расшифрования информации.

\subsection encrypt_ex1 Пример шифрования массивов данных

В качестве простейшей иллюстрации приведем пример шифрования произвольного массива данных.

\include examples/example-encrypt-ecb.c

Данный пример не является функционально полезным, но он иллюстрирует последовательность действий,
которую необходимо выполнить:

\li создать ключ шифрования,
\li преобразовать (зашифровать/расшифровать) данные.

В приведенном примере вырабатывается случайный ключ блочного алгоритма шифрования Магма.
Для выработки ключа используется производящая функция ak_key_new_magma(),
единственным аргументом которой является строка символов с произвольным (понятным пользователю)
описанием ключа.

В библиотеке реализованы другие производящие функции, позволяющие создавать
ключи других алгоритмов блочного шифрования
\li ak_key_new_magma_oid() - функция создает ключ алгоритма блочного шифрования ГОСТ 28147-89,
аргументами функции являются OID таблицы замен, используемой в алгоритме, а также описание ключа.
\li ak_key_new_kuznetchik() - функция создает ключ алгоритма блочного
шифрования Кузнечик (ГОСТ Р 34.12-2015).

Стоит также обратить внимание на тот факт, что внутренние механизмы контроля
за секретными ключами самостоятельно уничтожают и очищают выделенную под ключи память.
Данные операции выполняются в теле функции ak_libakrypt_destroy().

Пользователь может получить некоторые сведения о созданном ключе. Для этого
предназначены следующие функции.

\li ak_key_get_number() - функция возвращает константный указатель на строку, содержащую
последовательность шестнадцатеричных символов (hexstr) с уникальным номером, присвоенным
ключу при его создании.
\li ak_key_get_description() - функция возвращает константный указатель на строку, содержащую
(понятное пользователю) описание ключа.
\li ak_key_get_resource() - функция возвращает количество блоков информации,
которое может быть уммарно зашифровано/расшифровано с использованием данного ключа. Данное значение
ограничивает объем информации, обрабатываемой на данном ключе
(о ключевых ресурсах смотри также в разделе \ref options).

В приведенном примере зашифрование и, соответсвенно, расшифрование данных производятся с
помощью функций ak_key_encrypt_ecb() и ak_key_decrypt_ecb(). Для преобразования
исходного массива данных используется режим простой замены (ГОСТ Р 34.13-2015).
В реальных приложениях данный режим использовать нецелесообразно.

\page construction Внутреннее строение библиотеки

В этом разделе мы постараемся изложить основные принципы
построения библиотеки и описать технические приемы ее реализации. Для начала,
мы формализуем используемые понятия и термины.

\li \b класс -- тип данных, представляющий собой структуру языка С, содержащую в себе данные и указатели
на функции, обрабатывающие эти данные. В преобладающем большинстве случаев
описание классов библиотекой не экспортируется.

\li \b контекст -- объект класса, представляющий собой указатель на фиксированную структуру данных (класс).
Для унификации работы с контекстами они типизируются при помощи префикса ak_.

\li \b идентификатор -- символьная последовательность чисел, разделенных точками.
Для работы с идентификаторами предназначен специальный класс \ref oid.

\li \b производящая \b функция -- функция, предназначенная для создания контекстов заданного класса.
В качестве синонима к производящей функции может выступать термин "конструктор".
Производящие функции представляют собой единственный разрешенный способ создания контекстов (объектов какого-либо класса).

\li \b деструктор -- функция, предназначенная для удаления контекстов и очищения занимаемой ими памяти.

\li handle (ручка :)

\section names Принципы наименования функций библиотеки

Для всех функций библиотеки принят единый принцип наименования.
Имя функции строится следующим образом

\code
  ak_класс_действие
  ak_класс_действие_объект
  ak_класс_действие_предлог_действие2
\endcode

где

\li ak        - префикс библиотеки
\li класс     - класс, над объектами которого производятся действия
\li действие  - основное действие над объектом
\li действие2 - следующее действие над объектом
\li предлог   - направление действия
\li объект    - объект, на который направлено действие, либо объект,
                являющийся параметром действия

\subsection names_rules Основные действия

При выборе имен функций использовались следующие основные действия.

\li  create    - определить поля существующего указателя на объект (конструктор по-умолчанию)
\li  new       - создать указатель на объект и определить его поля
\li  destroy   - очитить поля существующего указателя на объект (деструктор)
\li  delete    - очистить поля существующего указателя и удалить сам указатель
\li  set       - присвоить объекту некоторое значение
\li  get       - преобразовать объект к некорому другому классу

\subsection names_to Предлоги

\li to        - действие направлено от объекта к объекту2 (константная функция)
\li from      - действие направлено к объекту от объекта2 (функция присвоения нового значения)
\li and       - предлог для связи нескольких действий над объектом

\subsection names_order Порядок следования аргументов функции

\li  арг1      - объект являющийся результатом действия
\li  арг2, ... - объекты, участвующие в действии

\section audit Аудит
В библиотеке libakrypt реализован механизм аудита - вывода сообщений
о выполняемых библиотекой действиях. В настоящее время реализовано три уровня аудита.

\li минимальный (ak_log_none),
\li стандартный (ak_log_standard),
\li максимальный (ak_log_maximum).

На минимальном уровне выводятся сообщения об ошибках, возникающих к процессе выполнения функций
библиотеки. Коды (численные значения) возможных ошибок могут быть найдены в файле \ref libakrypt.h.
Помимо сообщений об ошибках на минимальном уровне выводится сообщение о корректном
тестировании работы всех криптографических механизмов, реализуемых библиотекой
(тестирование происходит в процессе выполнения функции ak_libakrypt_create() ).

На стандартном уровне аудита выводятся все сообщения, которые выводятся на минимальном уровне,
а также сообщения о фактах использования ключевой информации. К таким фактам относятся

\li факты создания секретных ключей,
\li факты удаления секретных ключей,
\li ввод секретных ключей с внешних носителей,
\li запись секретных ключей на внешние носители и т.п.

На максимальном уровне аудита выводятся все сообщения, которые выводятся на стандартном уровне,
а также отладочные сообщения, позволяющие понять логику работы ряда функций.
Так, выводятся сообщения о процессе тестирования, с кратким описанием тестов и
результатами их выполнения, а также сообщения об изменении эксплуатационных
характеристик библиотеки.

Пример определения функции,
реализующей вывод сообщений о выполняемых библиотекой действиях, приводится
в разделе \ref tinit_libex1.

В ходе выполнения программы, использующей библиотеку libakrypt,
пользователь может узнать установленный для него уровень аудита. Для этого библиотекой
экспортируется функция ak_log_get_level().

Установка уровня аудита из программ, использующих библиотеку libakrypt, запрещена.
Уровень аудита относится к контролируемым характеристикам СКЗИ.
Его значение содержится в файле \b libakrypt.conf и считывается перед началом тестирования
криптографических механизмов. За уровень аудита в файле \b libakrypt.conf отвечает
переменная log_level, которая может принимать значения 0 (\b ak_log_none),
1 (\b ak_log_standard) или 2 (\b ak_log_maximum).
Более подробно о контролируемых характеристиках СКЗИ рассказывается в разделе \ref options.

\section options Настройка и эксплуатационные характеристики

Согласно отечественным требованиям к СКЗИ, для СКЗИ класса КС3 необходима роль администратора,
устанавливающего различные эксплуатационные характеристики. Перечень таких характеристик
содержится в инсталлируемом вместе с библиотекой файле \b libakrypt.conf.
В процессе тестирования криптографических механизмов,
функция ak_libakrypt_create() проверяет наличие этого файла и, в случае его отсутствия,
прекращает работу библиотеки.

При инсталляции файла \b libakrypt.conf ему присваиваются права,
позволяющие считывать хранящиеся в нем значения всем пользователям. При этом запись в файл
и изменение хранящихся в нем значений разрешается только администратору (суперпользователю).

В настоящее время в файле \b libakrypt.conf содержатся следующие эксплуатационные характеристики.

\li \b log_level - константа, определяющая уровень аудита библиотеки. Данная константа может принимать
значения от нуля до двух. Более подробно об аудите библиотеки libakrypt изложено в разделе \ref audit.

\li \b magma_block_resource - константа, определяющая количество блоков текста, которые могут быть
зашифрованы/расшифрованы на одном ключе блочного алгоритма шифрования ГОСТ 28147-89 (Магма).
После зашифрования/расшифрования заданного количества блоков работа с секретным ключом блокируется.

\li \b kuznetchik_block_resource - константа, определяющая количество блоков текста, которые могут быть
зашифрованы/расшифрованы на одном ключе блочного алгоритма шифрования ГОСТ Р 34.12-2015 (Кузнечик).
После зашифрования/расшифрования заданного количества блоков работа с секретным ключом блокируется.

Месторасположение файла \b libakrypt.conf может контролироваться при сборке библиотеки libakrypt -
в этот момент можно задать каталог расположения файла в явном виде, указав его значение
с помощью переменной LIBAKRYPT_CONF. Например, следующий фрагмент кода
позволяет поместить файл \b libakrypt.conf в каталог /etc.

\code
cmake -DLIBAKRYPT_CONF=/etc ../libakrypt-0.x
\endcode

По умолчанию, значение переменной LIBAKRYPT_CONF определяется в зависимости
от используемой операционной системы.

В операционной системе Linux месторасположение файла \b libakrypt.conf
определяется следующим образом. В каталоге инсталляции библиотеки
создается подкаталог \b /share/libakrypt, в который помещается конфигурационный файл.
Каталог инсталляции библиотеки может быть изменен с помощью переменной CMAKE_INSTALL_PREFIX.
Более подробно об этом смотри в разделе \ref intro_make_unix, а также в
документации на CMake.

*/

