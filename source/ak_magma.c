/* ----------------------------------------------------------------------------------------------- */
/*  Copyright (c) 2014 - 2018 by Axel Kenzo, axelkenzo@mail.ru                                     */
/*                            by Mikhail Lavrinovich, mikhail.lavrinovich@netcracker.com           */
/*                                                                                                 */
/*  Файл ak_magma.h                                                                                */
/*  - содержит реализацию алгоритма блочного шифрования Магма,                                     */
/*    регламентированного ГОСТ Р 34.12-2015                                                        */
/* ----------------------------------------------------------------------------------------------- */
 #include <ak_tools.h>
 #include <ak_bckey.h>

/* ----------------------------------------------------------------------------------------------- */
 const magma magma_boxes[2][2] = {
  {
   {
    {
     0x6C, 0x64, 0x66, 0x62, 0x6A, 0x65, 0x6B, 0x69, 0x6E, 0x68, 0x6D, 0x67, 0x60, 0x63, 0x6F, 0x61,
     0x8C, 0x84, 0x86, 0x82, 0x8A, 0x85, 0x8B, 0x89, 0x8E, 0x88, 0x8D, 0x87, 0x80, 0x83, 0x8F, 0x81,
     0x2C, 0x24, 0x26, 0x22, 0x2A, 0x25, 0x2B, 0x29, 0x2E, 0x28, 0x2D, 0x27, 0x20, 0x23, 0x2F, 0x21,
     0x3C, 0x34, 0x36, 0x32, 0x3A, 0x35, 0x3B, 0x39, 0x3E, 0x38, 0x3D, 0x37, 0x30, 0x33, 0x3F, 0x31,
     0x9C, 0x94, 0x96, 0x92, 0x9A, 0x95, 0x9B, 0x99, 0x9E, 0x98, 0x9D, 0x97, 0x90, 0x93, 0x9F, 0x91,
     0xAC, 0xA4, 0xA6, 0xA2, 0xAA, 0xA5, 0xAB, 0xA9, 0xAE, 0xA8, 0xAD, 0xA7, 0xA0, 0xA3, 0xAF, 0xA1,
     0x5C, 0x54, 0x56, 0x52, 0x5A, 0x55, 0x5B, 0x59, 0x5E, 0x58, 0x5D, 0x57, 0x50, 0x53, 0x5F, 0x51,
     0xCC, 0xC4, 0xC6, 0xC2, 0xCA, 0xC5, 0xCB, 0xC9, 0xCE, 0xC8, 0xCD, 0xC7, 0xC0, 0xC3, 0xCF, 0xC1,
     0x1C, 0x14, 0x16, 0x12, 0x1A, 0x15, 0x1B, 0x19, 0x1E, 0x18, 0x1D, 0x17, 0x10, 0x13, 0x1F, 0x11,
     0xEC, 0xE4, 0xE6, 0xE2, 0xEA, 0xE5, 0xEB, 0xE9, 0xEE, 0xE8, 0xED, 0xE7, 0xE0, 0xE3, 0xEF, 0xE1,
     0x4C, 0x44, 0x46, 0x42, 0x4A, 0x45, 0x4B, 0x49, 0x4E, 0x48, 0x4D, 0x47, 0x40, 0x43, 0x4F, 0x41,
     0x7C, 0x74, 0x76, 0x72, 0x7A, 0x75, 0x7B, 0x79, 0x7E, 0x78, 0x7D, 0x77, 0x70, 0x73, 0x7F, 0x71,
     0xBC, 0xB4, 0xB6, 0xB2, 0xBA, 0xB5, 0xBB, 0xB9, 0xBE, 0xB8, 0xBD, 0xB7, 0xB0, 0xB3, 0xBF, 0xB1,
     0xDC, 0xD4, 0xD6, 0xD2, 0xDA, 0xD5, 0xDB, 0xD9, 0xDE, 0xD8, 0xDD, 0xD7, 0xD0, 0xD3, 0xDF, 0xD1,
     0x0C, 0x04, 0x06, 0x02, 0x0A, 0x05, 0x0B, 0x09, 0x0E, 0x08, 0x0D, 0x07, 0x00, 0x03, 0x0F, 0x01,
     0xFC, 0xF4, 0xF6, 0xF2, 0xFA, 0xF5, 0xFB, 0xF9, 0xFE, 0xF8, 0xFD, 0xF7, 0xF0, 0xF3, 0xFF, 0xF1,
    },
    {
     0xCB, 0xC3, 0xC5, 0xC8, 0xC2, 0xCF, 0xCA, 0xCD, 0xCE, 0xC1, 0xC7, 0xC4, 0xCC, 0xC9, 0xC6, 0xC0,
     0x8B, 0x83, 0x85, 0x88, 0x82, 0x8F, 0x8A, 0x8D, 0x8E, 0x81, 0x87, 0x84, 0x8C, 0x89, 0x86, 0x80,
     0x2B, 0x23, 0x25, 0x28, 0x22, 0x2F, 0x2A, 0x2D, 0x2E, 0x21, 0x27, 0x24, 0x2C, 0x29, 0x26, 0x20,
     0x1B, 0x13, 0x15, 0x18, 0x12, 0x1F, 0x1A, 0x1D, 0x1E, 0x11, 0x17, 0x14, 0x1C, 0x19, 0x16, 0x10,
     0xDB, 0xD3, 0xD5, 0xD8, 0xD2, 0xDF, 0xDA, 0xDD, 0xDE, 0xD1, 0xD7, 0xD4, 0xDC, 0xD9, 0xD6, 0xD0,
     0x4B, 0x43, 0x45, 0x48, 0x42, 0x4F, 0x4A, 0x4D, 0x4E, 0x41, 0x47, 0x44, 0x4C, 0x49, 0x46, 0x40,
     0xFB, 0xF3, 0xF5, 0xF8, 0xF2, 0xFF, 0xFA, 0xFD, 0xFE, 0xF1, 0xF7, 0xF4, 0xFC, 0xF9, 0xF6, 0xF0,
     0x6B, 0x63, 0x65, 0x68, 0x62, 0x6F, 0x6A, 0x6D, 0x6E, 0x61, 0x67, 0x64, 0x6C, 0x69, 0x66, 0x60,
     0x7B, 0x73, 0x75, 0x78, 0x72, 0x7F, 0x7A, 0x7D, 0x7E, 0x71, 0x77, 0x74, 0x7C, 0x79, 0x76, 0x70,
     0x0B, 0x03, 0x05, 0x08, 0x02, 0x0F, 0x0A, 0x0D, 0x0E, 0x01, 0x07, 0x04, 0x0C, 0x09, 0x06, 0x00,
     0xAB, 0xA3, 0xA5, 0xA8, 0xA2, 0xAF, 0xAA, 0xAD, 0xAE, 0xA1, 0xA7, 0xA4, 0xAC, 0xA9, 0xA6, 0xA0,
     0x5B, 0x53, 0x55, 0x58, 0x52, 0x5F, 0x5A, 0x5D, 0x5E, 0x51, 0x57, 0x54, 0x5C, 0x59, 0x56, 0x50,
     0x3B, 0x33, 0x35, 0x38, 0x32, 0x3F, 0x3A, 0x3D, 0x3E, 0x31, 0x37, 0x34, 0x3C, 0x39, 0x36, 0x30,
     0xEB, 0xE3, 0xE5, 0xE8, 0xE2, 0xEF, 0xEA, 0xED, 0xEE, 0xE1, 0xE7, 0xE4, 0xEC, 0xE9, 0xE6, 0xE0,
     0x9B, 0x93, 0x95, 0x98, 0x92, 0x9F, 0x9A, 0x9D, 0x9E, 0x91, 0x97, 0x94, 0x9C, 0x99, 0x96, 0x90,
     0xBB, 0xB3, 0xB5, 0xB8, 0xB2, 0xBF, 0xBA, 0xBD, 0xBE, 0xB1, 0xB7, 0xB4, 0xBC, 0xB9, 0xB6, 0xB0,
    },
    {
     0x57, 0x5F, 0x55, 0x5A, 0x58, 0x51, 0x56, 0x5D, 0x50, 0x59, 0x53, 0x5E, 0x5B, 0x54, 0x52, 0x5C,
     0xD7, 0xDF, 0xD5, 0xDA, 0xD8, 0xD1, 0xD6, 0xDD, 0xD0, 0xD9, 0xD3, 0xDE, 0xDB, 0xD4, 0xD2, 0xDC,
     0xF7, 0xFF, 0xF5, 0xFA, 0xF8, 0xF1, 0xF6, 0xFD, 0xF0, 0xF9, 0xF3, 0xFE, 0xFB, 0xF4, 0xF2, 0xFC,
     0x67, 0x6F, 0x65, 0x6A, 0x68, 0x61, 0x66, 0x6D, 0x60, 0x69, 0x63, 0x6E, 0x6B, 0x64, 0x62, 0x6C,
     0x97, 0x9F, 0x95, 0x9A, 0x98, 0x91, 0x96, 0x9D, 0x90, 0x99, 0x93, 0x9E, 0x9B, 0x94, 0x92, 0x9C,
     0x27, 0x2F, 0x25, 0x2A, 0x28, 0x21, 0x26, 0x2D, 0x20, 0x29, 0x23, 0x2E, 0x2B, 0x24, 0x22, 0x2C,
     0xC7, 0xCF, 0xC5, 0xCA, 0xC8, 0xC1, 0xC6, 0xCD, 0xC0, 0xC9, 0xC3, 0xCE, 0xCB, 0xC4, 0xC2, 0xCC,
     0xA7, 0xAF, 0xA5, 0xAA, 0xA8, 0xA1, 0xA6, 0xAD, 0xA0, 0xA9, 0xA3, 0xAE, 0xAB, 0xA4, 0xA2, 0xAC,
     0xB7, 0xBF, 0xB5, 0xBA, 0xB8, 0xB1, 0xB6, 0xBD, 0xB0, 0xB9, 0xB3, 0xBE, 0xBB, 0xB4, 0xB2, 0xBC,
     0x77, 0x7F, 0x75, 0x7A, 0x78, 0x71, 0x76, 0x7D, 0x70, 0x79, 0x73, 0x7E, 0x7B, 0x74, 0x72, 0x7C,
     0x87, 0x8F, 0x85, 0x8A, 0x88, 0x81, 0x86, 0x8D, 0x80, 0x89, 0x83, 0x8E, 0x8B, 0x84, 0x82, 0x8C,
     0x17, 0x1F, 0x15, 0x1A, 0x18, 0x11, 0x16, 0x1D, 0x10, 0x19, 0x13, 0x1E, 0x1B, 0x14, 0x12, 0x1C,
     0x47, 0x4F, 0x45, 0x4A, 0x48, 0x41, 0x46, 0x4D, 0x40, 0x49, 0x43, 0x4E, 0x4B, 0x44, 0x42, 0x4C,
     0x37, 0x3F, 0x35, 0x3A, 0x38, 0x31, 0x36, 0x3D, 0x30, 0x39, 0x33, 0x3E, 0x3B, 0x34, 0x32, 0x3C,
     0xE7, 0xEF, 0xE5, 0xEA, 0xE8, 0xE1, 0xE6, 0xED, 0xE0, 0xE9, 0xE3, 0xEE, 0xEB, 0xE4, 0xE2, 0xEC,
     0x07, 0x0F, 0x05, 0x0A, 0x08, 0x01, 0x06, 0x0D, 0x00, 0x09, 0x03, 0x0E, 0x0B, 0x04, 0x02, 0x0C,
    },
    {
     0x18, 0x1E, 0x12, 0x15, 0x16, 0x19, 0x11, 0x1C, 0x1F, 0x14, 0x1B, 0x10, 0x1D, 0x1A, 0x13, 0x17,
     0x78, 0x7E, 0x72, 0x75, 0x76, 0x79, 0x71, 0x7C, 0x7F, 0x74, 0x7B, 0x70, 0x7D, 0x7A, 0x73, 0x77,
     0xE8, 0xEE, 0xE2, 0xE5, 0xE6, 0xE9, 0xE1, 0xEC, 0xEF, 0xE4, 0xEB, 0xE0, 0xED, 0xEA, 0xE3, 0xE7,
     0xD8, 0xDE, 0xD2, 0xD5, 0xD6, 0xD9, 0xD1, 0xDC, 0xDF, 0xD4, 0xDB, 0xD0, 0xDD, 0xDA, 0xD3, 0xD7,
     0x08, 0x0E, 0x02, 0x05, 0x06, 0x09, 0x01, 0x0C, 0x0F, 0x04, 0x0B, 0x00, 0x0D, 0x0A, 0x03, 0x07,
     0x58, 0x5E, 0x52, 0x55, 0x56, 0x59, 0x51, 0x5C, 0x5F, 0x54, 0x5B, 0x50, 0x5D, 0x5A, 0x53, 0x57,
     0x88, 0x8E, 0x82, 0x85, 0x86, 0x89, 0x81, 0x8C, 0x8F, 0x84, 0x8B, 0x80, 0x8D, 0x8A, 0x83, 0x87,
     0x38, 0x3E, 0x32, 0x35, 0x36, 0x39, 0x31, 0x3C, 0x3F, 0x34, 0x3B, 0x30, 0x3D, 0x3A, 0x33, 0x37,
     0x48, 0x4E, 0x42, 0x45, 0x46, 0x49, 0x41, 0x4C, 0x4F, 0x44, 0x4B, 0x40, 0x4D, 0x4A, 0x43, 0x47,
     0xF8, 0xFE, 0xF2, 0xF5, 0xF6, 0xF9, 0xF1, 0xFC, 0xFF, 0xF4, 0xFB, 0xF0, 0xFD, 0xFA, 0xF3, 0xF7,
     0xA8, 0xAE, 0xA2, 0xA5, 0xA6, 0xA9, 0xA1, 0xAC, 0xAF, 0xA4, 0xAB, 0xA0, 0xAD, 0xAA, 0xA3, 0xA7,
     0x68, 0x6E, 0x62, 0x65, 0x66, 0x69, 0x61, 0x6C, 0x6F, 0x64, 0x6B, 0x60, 0x6D, 0x6A, 0x63, 0x67,
     0x98, 0x9E, 0x92, 0x95, 0x96, 0x99, 0x91, 0x9C, 0x9F, 0x94, 0x9B, 0x90, 0x9D, 0x9A, 0x93, 0x97,
     0xC8, 0xCE, 0xC2, 0xC5, 0xC6, 0xC9, 0xC1, 0xCC, 0xCF, 0xC4, 0xCB, 0xC0, 0xCD, 0xCA, 0xC3, 0xC7,
     0xB8, 0xBE, 0xB2, 0xB5, 0xB6, 0xB9, 0xB1, 0xBC, 0xBF, 0xB4, 0xBB, 0xB0, 0xBD, 0xBA, 0xB3, 0xB7,
     0x28, 0x2E, 0x22, 0x25, 0x26, 0x29, 0x21, 0x2C, 0x2F, 0x24, 0x2B, 0x20, 0x2D, 0x2A, 0x23, 0x27,
    }
  },
  {
    {
     0x93, 0x9B, 0x99, 0x9D, 0x95, 0x9A, 0x94, 0x96, 0x91, 0x97, 0x92, 0x98, 0x9F, 0x9C, 0x90, 0x9E,
     0x73, 0x7B, 0x79, 0x7D, 0x75, 0x7A, 0x74, 0x76, 0x71, 0x77, 0x72, 0x78, 0x7F, 0x7C, 0x70, 0x7E,
     0xD3, 0xDB, 0xD9, 0xDD, 0xD5, 0xDA, 0xD4, 0xD6, 0xD1, 0xD7, 0xD2, 0xD8, 0xDF, 0xDC, 0xD0, 0xDE,
     0xC3, 0xCB, 0xC9, 0xCD, 0xC5, 0xCA, 0xC4, 0xC6, 0xC1, 0xC7, 0xC2, 0xC8, 0xCF, 0xCC, 0xC0, 0xCE,
     0x63, 0x6B, 0x69, 0x6D, 0x65, 0x6A, 0x64, 0x66, 0x61, 0x67, 0x62, 0x68, 0x6F, 0x6C, 0x60, 0x6E,
     0x53, 0x5B, 0x59, 0x5D, 0x55, 0x5A, 0x54, 0x56, 0x51, 0x57, 0x52, 0x58, 0x5F, 0x5C, 0x50, 0x5E,
     0xA3, 0xAB, 0xA9, 0xAD, 0xA5, 0xAA, 0xA4, 0xA6, 0xA1, 0xA7, 0xA2, 0xA8, 0xAF, 0xAC, 0xA0, 0xAE,
     0x33, 0x3B, 0x39, 0x3D, 0x35, 0x3A, 0x34, 0x36, 0x31, 0x37, 0x32, 0x38, 0x3F, 0x3C, 0x30, 0x3E,
     0xE3, 0xEB, 0xE9, 0xED, 0xE5, 0xEA, 0xE4, 0xE6, 0xE1, 0xE7, 0xE2, 0xE8, 0xEF, 0xEC, 0xE0, 0xEE,
     0x13, 0x1B, 0x19, 0x1D, 0x15, 0x1A, 0x14, 0x16, 0x11, 0x17, 0x12, 0x18, 0x1F, 0x1C, 0x10, 0x1E,
     0xB3, 0xBB, 0xB9, 0xBD, 0xB5, 0xBA, 0xB4, 0xB6, 0xB1, 0xB7, 0xB2, 0xB8, 0xBF, 0xBC, 0xB0, 0xBE,
     0x83, 0x8B, 0x89, 0x8D, 0x85, 0x8A, 0x84, 0x86, 0x81, 0x87, 0x82, 0x88, 0x8F, 0x8C, 0x80, 0x8E,
     0x43, 0x4B, 0x49, 0x4D, 0x45, 0x4A, 0x44, 0x46, 0x41, 0x47, 0x42, 0x48, 0x4F, 0x4C, 0x40, 0x4E,
     0x23, 0x2B, 0x29, 0x2D, 0x25, 0x2A, 0x24, 0x26, 0x21, 0x27, 0x22, 0x28, 0x2F, 0x2C, 0x20, 0x2E,
     0xF3, 0xFB, 0xF9, 0xFD, 0xF5, 0xFA, 0xF4, 0xF6, 0xF1, 0xF7, 0xF2, 0xF8, 0xFF, 0xFC, 0xF0, 0xFE,
     0x03, 0x0B, 0x09, 0x0D, 0x05, 0x0A, 0x04, 0x06, 0x01, 0x07, 0x02, 0x08, 0x0F, 0x0C, 0x00, 0x0E,
    },
    {
     0x34, 0x3C, 0x3A, 0x37, 0x3D, 0x30, 0x35, 0x32, 0x31, 0x3E, 0x38, 0x3B, 0x33, 0x36, 0x39, 0x3F,
     0x74, 0x7C, 0x7A, 0x77, 0x7D, 0x70, 0x75, 0x72, 0x71, 0x7E, 0x78, 0x7B, 0x73, 0x76, 0x79, 0x7F,
     0xD4, 0xDC, 0xDA, 0xD7, 0xDD, 0xD0, 0xD5, 0xD2, 0xD1, 0xDE, 0xD8, 0xDB, 0xD3, 0xD6, 0xD9, 0xDF,
     0xE4, 0xEC, 0xEA, 0xE7, 0xED, 0xE0, 0xE5, 0xE2, 0xE1, 0xEE, 0xE8, 0xEB, 0xE3, 0xE6, 0xE9, 0xEF,
     0x24, 0x2C, 0x2A, 0x27, 0x2D, 0x20, 0x25, 0x22, 0x21, 0x2E, 0x28, 0x2B, 0x23, 0x26, 0x29, 0x2F,
     0xB4, 0xBC, 0xBA, 0xB7, 0xBD, 0xB0, 0xB5, 0xB2, 0xB1, 0xBE, 0xB8, 0xBB, 0xB3, 0xB6, 0xB9, 0xBF,
     0x04, 0x0C, 0x0A, 0x07, 0x0D, 0x00, 0x05, 0x02, 0x01, 0x0E, 0x08, 0x0B, 0x03, 0x06, 0x09, 0x0F,
     0x94, 0x9C, 0x9A, 0x97, 0x9D, 0x90, 0x95, 0x92, 0x91, 0x9E, 0x98, 0x9B, 0x93, 0x96, 0x99, 0x9F,
     0x84, 0x8C, 0x8A, 0x87, 0x8D, 0x80, 0x85, 0x82, 0x81, 0x8E, 0x88, 0x8B, 0x83, 0x86, 0x89, 0x8F,
     0xF4, 0xFC, 0xFA, 0xF7, 0xFD, 0xF0, 0xF5, 0xF2, 0xF1, 0xFE, 0xF8, 0xFB, 0xF3, 0xF6, 0xF9, 0xFF,
     0x54, 0x5C, 0x5A, 0x57, 0x5D, 0x50, 0x55, 0x52, 0x51, 0x5E, 0x58, 0x5B, 0x53, 0x56, 0x59, 0x5F,
     0xA4, 0xAC, 0xAA, 0xA7, 0xAD, 0xA0, 0xA5, 0xA2, 0xA1, 0xAE, 0xA8, 0xAB, 0xA3, 0xA6, 0xA9, 0xAF,
     0xC4, 0xCC, 0xCA, 0xC7, 0xCD, 0xC0, 0xC5, 0xC2, 0xC1, 0xCE, 0xC8, 0xCB, 0xC3, 0xC6, 0xC9, 0xCF,
     0x14, 0x1C, 0x1A, 0x17, 0x1D, 0x10, 0x15, 0x12, 0x11, 0x1E, 0x18, 0x1B, 0x13, 0x16, 0x19, 0x1F,
     0x64, 0x6C, 0x6A, 0x67, 0x6D, 0x60, 0x65, 0x62, 0x61, 0x6E, 0x68, 0x6B, 0x63, 0x66, 0x69, 0x6F,
     0x44, 0x4C, 0x4A, 0x47, 0x4D, 0x40, 0x45, 0x42, 0x41, 0x4E, 0x48, 0x4B, 0x43, 0x46, 0x49, 0x4F,
    },
    {
     0xA8, 0xA0, 0xAA, 0xA5, 0xA7, 0xAE, 0xA9, 0xA2, 0xAF, 0xA6, 0xAC, 0xA1, 0xA4, 0xAB, 0xAD, 0xA3,
     0x28, 0x20, 0x2A, 0x25, 0x27, 0x2E, 0x29, 0x22, 0x2F, 0x26, 0x2C, 0x21, 0x24, 0x2B, 0x2D, 0x23,
     0x08, 0x00, 0x0A, 0x05, 0x07, 0x0E, 0x09, 0x02, 0x0F, 0x06, 0x0C, 0x01, 0x04, 0x0B, 0x0D, 0x03,
     0x98, 0x90, 0x9A, 0x95, 0x97, 0x9E, 0x99, 0x92, 0x9F, 0x96, 0x9C, 0x91, 0x94, 0x9B, 0x9D, 0x93,
     0x68, 0x60, 0x6A, 0x65, 0x67, 0x6E, 0x69, 0x62, 0x6F, 0x66, 0x6C, 0x61, 0x64, 0x6B, 0x6D, 0x63,
     0xD8, 0xD0, 0xDA, 0xD5, 0xD7, 0xDE, 0xD9, 0xD2, 0xDF, 0xD6, 0xDC, 0xD1, 0xD4, 0xDB, 0xDD, 0xD3,
     0x38, 0x30, 0x3A, 0x35, 0x37, 0x3E, 0x39, 0x32, 0x3F, 0x36, 0x3C, 0x31, 0x34, 0x3B, 0x3D, 0x33,
     0x58, 0x50, 0x5A, 0x55, 0x57, 0x5E, 0x59, 0x52, 0x5F, 0x56, 0x5C, 0x51, 0x54, 0x5B, 0x5D, 0x53,
     0x48, 0x40, 0x4A, 0x45, 0x47, 0x4E, 0x49, 0x42, 0x4F, 0x46, 0x4C, 0x41, 0x44, 0x4B, 0x4D, 0x43,
     0x88, 0x80, 0x8A, 0x85, 0x87, 0x8E, 0x89, 0x82, 0x8F, 0x86, 0x8C, 0x81, 0x84, 0x8B, 0x8D, 0x83,
     0x78, 0x70, 0x7A, 0x75, 0x77, 0x7E, 0x79, 0x72, 0x7F, 0x76, 0x7C, 0x71, 0x74, 0x7B, 0x7D, 0x73,
     0xE8, 0xE0, 0xEA, 0xE5, 0xE7, 0xEE, 0xE9, 0xE2, 0xEF, 0xE6, 0xEC, 0xE1, 0xE4, 0xEB, 0xED, 0xE3,
     0xB8, 0xB0, 0xBA, 0xB5, 0xB7, 0xBE, 0xB9, 0xB2, 0xBF, 0xB6, 0xBC, 0xB1, 0xB4, 0xBB, 0xBD, 0xB3,
     0xC8, 0xC0, 0xCA, 0xC5, 0xC7, 0xCE, 0xC9, 0xC2, 0xCF, 0xC6, 0xCC, 0xC1, 0xC4, 0xCB, 0xCD, 0xC3,
     0x18, 0x10, 0x1A, 0x15, 0x17, 0x1E, 0x19, 0x12, 0x1F, 0x16, 0x1C, 0x11, 0x14, 0x1B, 0x1D, 0x13,
     0xF8, 0xF0, 0xFA, 0xF5, 0xF7, 0xFE, 0xF9, 0xF2, 0xFF, 0xF6, 0xFC, 0xF1, 0xF4, 0xFB, 0xFD, 0xF3,
    },
    {
     0xE7, 0xE1, 0xED, 0xEA, 0xE9, 0xE6, 0xEE, 0xE3, 0xE0, 0xEB, 0xE4, 0xEF, 0xE2, 0xE5, 0xEC, 0xE8,
     0x87, 0x81, 0x8D, 0x8A, 0x89, 0x86, 0x8E, 0x83, 0x80, 0x8B, 0x84, 0x8F, 0x82, 0x85, 0x8C, 0x88,
     0x17, 0x11, 0x1D, 0x1A, 0x19, 0x16, 0x1E, 0x13, 0x10, 0x1B, 0x14, 0x1F, 0x12, 0x15, 0x1C, 0x18,
     0x27, 0x21, 0x2D, 0x2A, 0x29, 0x26, 0x2E, 0x23, 0x20, 0x2B, 0x24, 0x2F, 0x22, 0x25, 0x2C, 0x28,
     0xF7, 0xF1, 0xFD, 0xFA, 0xF9, 0xF6, 0xFE, 0xF3, 0xF0, 0xFB, 0xF4, 0xFF, 0xF2, 0xF5, 0xFC, 0xF8,
     0xA7, 0xA1, 0xAD, 0xAA, 0xA9, 0xA6, 0xAE, 0xA3, 0xA0, 0xAB, 0xA4, 0xAF, 0xA2, 0xA5, 0xAC, 0xA8,
     0x77, 0x71, 0x7D, 0x7A, 0x79, 0x76, 0x7E, 0x73, 0x70, 0x7B, 0x74, 0x7F, 0x72, 0x75, 0x7C, 0x78,
     0xC7, 0xC1, 0xCD, 0xCA, 0xC9, 0xC6, 0xCE, 0xC3, 0xC0, 0xCB, 0xC4, 0xCF, 0xC2, 0xC5, 0xCC, 0xC8,
     0xB7, 0xB1, 0xBD, 0xBA, 0xB9, 0xB6, 0xBE, 0xB3, 0xB0, 0xBB, 0xB4, 0xBF, 0xB2, 0xB5, 0xBC, 0xB8,
     0x07, 0x01, 0x0D, 0x0A, 0x09, 0x06, 0x0E, 0x03, 0x00, 0x0B, 0x04, 0x0F, 0x02, 0x05, 0x0C, 0x08,
     0x57, 0x51, 0x5D, 0x5A, 0x59, 0x56, 0x5E, 0x53, 0x50, 0x5B, 0x54, 0x5F, 0x52, 0x55, 0x5C, 0x58,
     0x97, 0x91, 0x9D, 0x9A, 0x99, 0x96, 0x9E, 0x93, 0x90, 0x9B, 0x94, 0x9F, 0x92, 0x95, 0x9C, 0x98,
     0x67, 0x61, 0x6D, 0x6A, 0x69, 0x66, 0x6E, 0x63, 0x60, 0x6B, 0x64, 0x6F, 0x62, 0x65, 0x6C, 0x68,
     0x37, 0x31, 0x3D, 0x3A, 0x39, 0x36, 0x3E, 0x33, 0x30, 0x3B, 0x34, 0x3F, 0x32, 0x35, 0x3C, 0x38,
     0x47, 0x41, 0x4D, 0x4A, 0x49, 0x46, 0x4E, 0x43, 0x40, 0x4B, 0x44, 0x4F, 0x42, 0x45, 0x4C, 0x48,
     0xD7, 0xD1, 0xDD, 0xDA, 0xD9, 0xD6, 0xDE, 0xD3, 0xD0, 0xDB, 0xD4, 0xDF, 0xD2, 0xD5, 0xDC, 0xD8,
    }
   }
  },
  {
   {
    {
     0xF1, 0xFF, 0xF3, 0xF0, 0xF7, 0xFD, 0xF8, 0xFE, 0xF9, 0xFB, 0xF5, 0xFA, 0xF2, 0xF6, 0xF4, 0xFC,
     0x01, 0x0F, 0x03, 0x00, 0x07, 0x0D, 0x08, 0x0E, 0x09, 0x0B, 0x05, 0x0A, 0x02, 0x06, 0x04, 0x0C,
     0xD1, 0xDF, 0xD3, 0xD0, 0xD7, 0xDD, 0xD8, 0xDE, 0xD9, 0xDB, 0xD5, 0xDA, 0xD2, 0xD6, 0xD4, 0xDC,
     0xB1, 0xBF, 0xB3, 0xB0, 0xB7, 0xBD, 0xB8, 0xBE, 0xB9, 0xBB, 0xB5, 0xBA, 0xB2, 0xB6, 0xB4, 0xBC,
     0x71, 0x7F, 0x73, 0x70, 0x77, 0x7D, 0x78, 0x7E, 0x79, 0x7B, 0x75, 0x7A, 0x72, 0x76, 0x74, 0x7C,
     0x41, 0x4F, 0x43, 0x40, 0x47, 0x4D, 0x48, 0x4E, 0x49, 0x4B, 0x45, 0x4A, 0x42, 0x46, 0x44, 0x4C,
     0xE1, 0xEF, 0xE3, 0xE0, 0xE7, 0xED, 0xE8, 0xEE, 0xE9, 0xEB, 0xE5, 0xEA, 0xE2, 0xE6, 0xE4, 0xEC,
     0x11, 0x1F, 0x13, 0x10, 0x17, 0x1D, 0x18, 0x1E, 0x19, 0x1B, 0x15, 0x1A, 0x12, 0x16, 0x14, 0x1C,
     0xC1, 0xCF, 0xC3, 0xC0, 0xC7, 0xCD, 0xC8, 0xCE, 0xC9, 0xCB, 0xC5, 0xCA, 0xC2, 0xC6, 0xC4, 0xCC,
     0x51, 0x5F, 0x53, 0x50, 0x57, 0x5D, 0x58, 0x5E, 0x59, 0x5B, 0x55, 0x5A, 0x52, 0x56, 0x54, 0x5C,
     0xA1, 0xAF, 0xA3, 0xA0, 0xA7, 0xAD, 0xA8, 0xAE, 0xA9, 0xAB, 0xA5, 0xAA, 0xA2, 0xA6, 0xA4, 0xAC,
     0x91, 0x9F, 0x93, 0x90, 0x97, 0x9D, 0x98, 0x9E, 0x99, 0x9B, 0x95, 0x9A, 0x92, 0x96, 0x94, 0x9C,
     0x31, 0x3F, 0x33, 0x30, 0x37, 0x3D, 0x38, 0x3E, 0x39, 0x3B, 0x35, 0x3A, 0x32, 0x36, 0x34, 0x3C,
     0x21, 0x2F, 0x23, 0x20, 0x27, 0x2D, 0x28, 0x2E, 0x29, 0x2B, 0x25, 0x2A, 0x22, 0x26, 0x24, 0x2C,
     0x81, 0x8F, 0x83, 0x80, 0x87, 0x8D, 0x88, 0x8E, 0x89, 0x8B, 0x85, 0x8A, 0x82, 0x86, 0x84, 0x8C,
     0x61, 0x6F, 0x63, 0x60, 0x67, 0x6D, 0x68, 0x6E, 0x69, 0x6B, 0x65, 0x6A, 0x62, 0x66, 0x64, 0x6C,
    },
    {
     0xB0, 0xB6, 0xB9, 0xBC, 0xB4, 0xB7, 0xB1, 0xBE, 0xBD, 0xBA, 0xBF, 0xB2, 0xB8, 0xB5, 0xB3, 0xBB,
     0x90, 0x96, 0x99, 0x9C, 0x94, 0x97, 0x91, 0x9E, 0x9D, 0x9A, 0x9F, 0x92, 0x98, 0x95, 0x93, 0x9B,
     0xE0, 0xE6, 0xE9, 0xEC, 0xE4, 0xE7, 0xE1, 0xEE, 0xED, 0xEA, 0xEF, 0xE2, 0xE8, 0xE5, 0xE3, 0xEB,
     0x30, 0x36, 0x39, 0x3C, 0x34, 0x37, 0x31, 0x3E, 0x3D, 0x3A, 0x3F, 0x32, 0x38, 0x35, 0x33, 0x3B,
     0x50, 0x56, 0x59, 0x5C, 0x54, 0x57, 0x51, 0x5E, 0x5D, 0x5A, 0x5F, 0x52, 0x58, 0x55, 0x53, 0x5B,
     0xA0, 0xA6, 0xA9, 0xAC, 0xA4, 0xA7, 0xA1, 0xAE, 0xAD, 0xAA, 0xAF, 0xA2, 0xA8, 0xA5, 0xA3, 0xAB,
     0x00, 0x06, 0x09, 0x0C, 0x04, 0x07, 0x01, 0x0E, 0x0D, 0x0A, 0x0F, 0x02, 0x08, 0x05, 0x03, 0x0B,
     0x70, 0x76, 0x79, 0x7C, 0x74, 0x77, 0x71, 0x7E, 0x7D, 0x7A, 0x7F, 0x72, 0x78, 0x75, 0x73, 0x7B,
     0x60, 0x66, 0x69, 0x6C, 0x64, 0x67, 0x61, 0x6E, 0x6D, 0x6A, 0x6F, 0x62, 0x68, 0x65, 0x63, 0x6B,
     0xF0, 0xF6, 0xF9, 0xFC, 0xF4, 0xF7, 0xF1, 0xFE, 0xFD, 0xFA, 0xFF, 0xF2, 0xF8, 0xF5, 0xF3, 0xFB,
     0x40, 0x46, 0x49, 0x4C, 0x44, 0x47, 0x41, 0x4E, 0x4D, 0x4A, 0x4F, 0x42, 0x48, 0x45, 0x43, 0x4B,
     0xD0, 0xD6, 0xD9, 0xDC, 0xD4, 0xD7, 0xD1, 0xDE, 0xDD, 0xDA, 0xDF, 0xD2, 0xD8, 0xD5, 0xD3, 0xDB,
     0x10, 0x16, 0x19, 0x1C, 0x14, 0x17, 0x11, 0x1E, 0x1D, 0x1A, 0x1F, 0x12, 0x18, 0x15, 0x13, 0x1B,
     0x20, 0x26, 0x29, 0x2C, 0x24, 0x27, 0x21, 0x2E, 0x2D, 0x2A, 0x2F, 0x22, 0x28, 0x25, 0x23, 0x2B,
     0x80, 0x86, 0x89, 0x8C, 0x84, 0x87, 0x81, 0x8E, 0x8D, 0x8A, 0x8F, 0x82, 0x88, 0x85, 0x83, 0x8B,
     0xC0, 0xC6, 0xC9, 0xCC, 0xC4, 0xC7, 0xC1, 0xCE, 0xCD, 0xCA, 0xCF, 0xC2, 0xC8, 0xC5, 0xC3, 0xCB,
    },
    {
     0x0C, 0x02, 0x04, 0x0B, 0x0E, 0x03, 0x09, 0x00, 0x0D, 0x06, 0x01, 0x08, 0x0A, 0x05, 0x0F, 0x07,
     0xEC, 0xE2, 0xE4, 0xEB, 0xEE, 0xE3, 0xE9, 0xE0, 0xED, 0xE6, 0xE1, 0xE8, 0xEA, 0xE5, 0xEF, 0xE7,
     0x3C, 0x32, 0x34, 0x3B, 0x3E, 0x33, 0x39, 0x30, 0x3D, 0x36, 0x31, 0x38, 0x3A, 0x35, 0x3F, 0x37,
     0x4C, 0x42, 0x44, 0x4B, 0x4E, 0x43, 0x49, 0x40, 0x4D, 0x46, 0x41, 0x48, 0x4A, 0x45, 0x4F, 0x47,
     0x1C, 0x12, 0x14, 0x1B, 0x1E, 0x13, 0x19, 0x10, 0x1D, 0x16, 0x11, 0x18, 0x1A, 0x15, 0x1F, 0x17,
     0x8C, 0x82, 0x84, 0x8B, 0x8E, 0x83, 0x89, 0x80, 0x8D, 0x86, 0x81, 0x88, 0x8A, 0x85, 0x8F, 0x87,
     0x7C, 0x72, 0x74, 0x7B, 0x7E, 0x73, 0x79, 0x70, 0x7D, 0x76, 0x71, 0x78, 0x7A, 0x75, 0x7F, 0x77,
     0xBC, 0xB2, 0xB4, 0xBB, 0xBE, 0xB3, 0xB9, 0xB0, 0xBD, 0xB6, 0xB1, 0xB8, 0xBA, 0xB5, 0xBF, 0xB7,
     0xAC, 0xA2, 0xA4, 0xAB, 0xAE, 0xA3, 0xA9, 0xA0, 0xAD, 0xA6, 0xA1, 0xA8, 0xAA, 0xA5, 0xAF, 0xA7,
     0xCC, 0xC2, 0xC4, 0xCB, 0xCE, 0xC3, 0xC9, 0xC0, 0xCD, 0xC6, 0xC1, 0xC8, 0xCA, 0xC5, 0xCF, 0xC7,
     0x2C, 0x22, 0x24, 0x2B, 0x2E, 0x23, 0x29, 0x20, 0x2D, 0x26, 0x21, 0x28, 0x2A, 0x25, 0x2F, 0x27,
     0x9C, 0x92, 0x94, 0x9B, 0x9E, 0x93, 0x99, 0x90, 0x9D, 0x96, 0x91, 0x98, 0x9A, 0x95, 0x9F, 0x97,
     0x6C, 0x62, 0x64, 0x6B, 0x6E, 0x63, 0x69, 0x60, 0x6D, 0x66, 0x61, 0x68, 0x6A, 0x65, 0x6F, 0x67,
     0xFC, 0xF2, 0xF4, 0xFB, 0xFE, 0xF3, 0xF9, 0xF0, 0xFD, 0xF6, 0xF1, 0xF8, 0xFA, 0xF5, 0xFF, 0xF7,
     0xDC, 0xD2, 0xD4, 0xDB, 0xDE, 0xD3, 0xD9, 0xD0, 0xDD, 0xD6, 0xD1, 0xD8, 0xDA, 0xD5, 0xDF, 0xD7,
     0x5C, 0x52, 0x54, 0x5B, 0x5E, 0x53, 0x59, 0x50, 0x5D, 0x56, 0x51, 0x58, 0x5A, 0x55, 0x5F, 0x57,
    },
    {
     0x27, 0x23, 0x2A, 0x2D, 0x20, 0x2B, 0x24, 0x2F, 0x2C, 0x21, 0x29, 0x26, 0x25, 0x22, 0x2E, 0x28,
     0xB7, 0xB3, 0xBA, 0xBD, 0xB0, 0xBB, 0xB4, 0xBF, 0xBC, 0xB1, 0xB9, 0xB6, 0xB5, 0xB2, 0xBE, 0xB8,
     0xC7, 0xC3, 0xCA, 0xCD, 0xC0, 0xCB, 0xC4, 0xCF, 0xCC, 0xC1, 0xC9, 0xC6, 0xC5, 0xC2, 0xCE, 0xC8,
     0x97, 0x93, 0x9A, 0x9D, 0x90, 0x9B, 0x94, 0x9F, 0x9C, 0x91, 0x99, 0x96, 0x95, 0x92, 0x9E, 0x98,
     0x67, 0x63, 0x6A, 0x6D, 0x60, 0x6B, 0x64, 0x6F, 0x6C, 0x61, 0x69, 0x66, 0x65, 0x62, 0x6E, 0x68,
     0xA7, 0xA3, 0xAA, 0xAD, 0xA0, 0xAB, 0xA4, 0xAF, 0xAC, 0xA1, 0xA9, 0xA6, 0xA5, 0xA2, 0xAE, 0xA8,
     0xF7, 0xF3, 0xFA, 0xFD, 0xF0, 0xFB, 0xF4, 0xFF, 0xFC, 0xF1, 0xF9, 0xF6, 0xF5, 0xF2, 0xFE, 0xF8,
     0x47, 0x43, 0x4A, 0x4D, 0x40, 0x4B, 0x44, 0x4F, 0x4C, 0x41, 0x49, 0x46, 0x45, 0x42, 0x4E, 0x48,
     0x37, 0x33, 0x3A, 0x3D, 0x30, 0x3B, 0x34, 0x3F, 0x3C, 0x31, 0x39, 0x36, 0x35, 0x32, 0x3E, 0x38,
     0x87, 0x83, 0x8A, 0x8D, 0x80, 0x8B, 0x84, 0x8F, 0x8C, 0x81, 0x89, 0x86, 0x85, 0x82, 0x8E, 0x88,
     0x57, 0x53, 0x5A, 0x5D, 0x50, 0x5B, 0x54, 0x5F, 0x5C, 0x51, 0x59, 0x56, 0x55, 0x52, 0x5E, 0x58,
     0x07, 0x03, 0x0A, 0x0D, 0x00, 0x0B, 0x04, 0x0F, 0x0C, 0x01, 0x09, 0x06, 0x05, 0x02, 0x0E, 0x08,
     0xD7, 0xD3, 0xDA, 0xDD, 0xD0, 0xDB, 0xD4, 0xDF, 0xDC, 0xD1, 0xD9, 0xD6, 0xD5, 0xD2, 0xDE, 0xD8,
     0xE7, 0xE3, 0xEA, 0xED, 0xE0, 0xEB, 0xE4, 0xEF, 0xEC, 0xE1, 0xE9, 0xE6, 0xE5, 0xE2, 0xEE, 0xE8,
     0x77, 0x73, 0x7A, 0x7D, 0x70, 0x7B, 0x74, 0x7F, 0x7C, 0x71, 0x79, 0x76, 0x75, 0x72, 0x7E, 0x78,
     0x17, 0x13, 0x1A, 0x1D, 0x10, 0x1B, 0x14, 0x1F, 0x1C, 0x11, 0x19, 0x16, 0x15, 0x12, 0x1E, 0x18,
    }
   },
   {
    {
     0x0E, 0x00, 0x0C, 0x0F, 0x08, 0x02, 0x07, 0x01, 0x06, 0x04, 0x0A, 0x05, 0x0D, 0x09, 0x0B, 0x03,
     0xFE, 0xF0, 0xFC, 0xFF, 0xF8, 0xF2, 0xF7, 0xF1, 0xF6, 0xF4, 0xFA, 0xF5, 0xFD, 0xF9, 0xFB, 0xF3,
     0x2E, 0x20, 0x2C, 0x2F, 0x28, 0x22, 0x27, 0x21, 0x26, 0x24, 0x2A, 0x25, 0x2D, 0x29, 0x2B, 0x23,
     0x4E, 0x40, 0x4C, 0x4F, 0x48, 0x42, 0x47, 0x41, 0x46, 0x44, 0x4A, 0x45, 0x4D, 0x49, 0x4B, 0x43,
     0x8E, 0x80, 0x8C, 0x8F, 0x88, 0x82, 0x87, 0x81, 0x86, 0x84, 0x8A, 0x85, 0x8D, 0x89, 0x8B, 0x83,
     0xBE, 0xB0, 0xBC, 0xBF, 0xB8, 0xB2, 0xB7, 0xB1, 0xB6, 0xB4, 0xBA, 0xB5, 0xBD, 0xB9, 0xBB, 0xB3,
     0x1E, 0x10, 0x1C, 0x1F, 0x18, 0x12, 0x17, 0x11, 0x16, 0x14, 0x1A, 0x15, 0x1D, 0x19, 0x1B, 0x13,
     0xEE, 0xE0, 0xEC, 0xEF, 0xE8, 0xE2, 0xE7, 0xE1, 0xE6, 0xE4, 0xEA, 0xE5, 0xED, 0xE9, 0xEB, 0xE3,
     0x3E, 0x30, 0x3C, 0x3F, 0x38, 0x32, 0x37, 0x31, 0x36, 0x34, 0x3A, 0x35, 0x3D, 0x39, 0x3B, 0x33,
     0xAE, 0xA0, 0xAC, 0xAF, 0xA8, 0xA2, 0xA7, 0xA1, 0xA6, 0xA4, 0xAA, 0xA5, 0xAD, 0xA9, 0xAB, 0xA3,
     0x5E, 0x50, 0x5C, 0x5F, 0x58, 0x52, 0x57, 0x51, 0x56, 0x54, 0x5A, 0x55, 0x5D, 0x59, 0x5B, 0x53,
     0x6E, 0x60, 0x6C, 0x6F, 0x68, 0x62, 0x67, 0x61, 0x66, 0x64, 0x6A, 0x65, 0x6D, 0x69, 0x6B, 0x63,
     0xCE, 0xC0, 0xCC, 0xCF, 0xC8, 0xC2, 0xC7, 0xC1, 0xC6, 0xC4, 0xCA, 0xC5, 0xCD, 0xC9, 0xCB, 0xC3,
     0xDE, 0xD0, 0xDC, 0xDF, 0xD8, 0xD2, 0xD7, 0xD1, 0xD6, 0xD4, 0xDA, 0xD5, 0xDD, 0xD9, 0xDB, 0xD3,
     0x7E, 0x70, 0x7C, 0x7F, 0x78, 0x72, 0x77, 0x71, 0x76, 0x74, 0x7A, 0x75, 0x7D, 0x79, 0x7B, 0x73,
     0x9E, 0x90, 0x9C, 0x9F, 0x98, 0x92, 0x97, 0x91, 0x96, 0x94, 0x9A, 0x95, 0x9D, 0x99, 0x9B, 0x93,
    },
    {
     0x4F, 0x49, 0x46, 0x43, 0x4B, 0x48, 0x4E, 0x41, 0x42, 0x45, 0x40, 0x4D, 0x47, 0x4A, 0x4C, 0x44,
     0x6F, 0x69, 0x66, 0x63, 0x6B, 0x68, 0x6E, 0x61, 0x62, 0x65, 0x60, 0x6D, 0x67, 0x6A, 0x6C, 0x64,
     0x1F, 0x19, 0x16, 0x13, 0x1B, 0x18, 0x1E, 0x11, 0x12, 0x15, 0x10, 0x1D, 0x17, 0x1A, 0x1C, 0x14,
     0xCF, 0xC9, 0xC6, 0xC3, 0xCB, 0xC8, 0xCE, 0xC1, 0xC2, 0xC5, 0xC0, 0xCD, 0xC7, 0xCA, 0xCC, 0xC4,
     0xAF, 0xA9, 0xA6, 0xA3, 0xAB, 0xA8, 0xAE, 0xA1, 0xA2, 0xA5, 0xA0, 0xAD, 0xA7, 0xAA, 0xAC, 0xA4,
     0x5F, 0x59, 0x56, 0x53, 0x5B, 0x58, 0x5E, 0x51, 0x52, 0x55, 0x50, 0x5D, 0x57, 0x5A, 0x5C, 0x54,
     0xFF, 0xF9, 0xF6, 0xF3, 0xFB, 0xF8, 0xFE, 0xF1, 0xF2, 0xF5, 0xF0, 0xFD, 0xF7, 0xFA, 0xFC, 0xF4,
     0x8F, 0x89, 0x86, 0x83, 0x8B, 0x88, 0x8E, 0x81, 0x82, 0x85, 0x80, 0x8D, 0x87, 0x8A, 0x8C, 0x84,
     0x9F, 0x99, 0x96, 0x93, 0x9B, 0x98, 0x9E, 0x91, 0x92, 0x95, 0x90, 0x9D, 0x97, 0x9A, 0x9C, 0x94,
     0x0F, 0x09, 0x06, 0x03, 0x0B, 0x08, 0x0E, 0x01, 0x02, 0x05, 0x00, 0x0D, 0x07, 0x0A, 0x0C, 0x04,
     0xBF, 0xB9, 0xB6, 0xB3, 0xBB, 0xB8, 0xBE, 0xB1, 0xB2, 0xB5, 0xB0, 0xBD, 0xB7, 0xBA, 0xBC, 0xB4,
     0x2F, 0x29, 0x26, 0x23, 0x2B, 0x28, 0x2E, 0x21, 0x22, 0x25, 0x20, 0x2D, 0x27, 0x2A, 0x2C, 0x24,
     0xEF, 0xE9, 0xE6, 0xE3, 0xEB, 0xE8, 0xEE, 0xE1, 0xE2, 0xE5, 0xE0, 0xED, 0xE7, 0xEA, 0xEC, 0xE4,
     0xDF, 0xD9, 0xD6, 0xD3, 0xDB, 0xD8, 0xDE, 0xD1, 0xD2, 0xD5, 0xD0, 0xDD, 0xD7, 0xDA, 0xDC, 0xD4,
     0x7F, 0x79, 0x76, 0x73, 0x7B, 0x78, 0x7E, 0x71, 0x72, 0x75, 0x70, 0x7D, 0x77, 0x7A, 0x7C, 0x74,
     0x3F, 0x39, 0x36, 0x33, 0x3B, 0x38, 0x3E, 0x31, 0x32, 0x35, 0x30, 0x3D, 0x37, 0x3A, 0x3C, 0x34,
    },
    {
     0xF3, 0xFD, 0xFB, 0xF4, 0xF1, 0xFC, 0xF6, 0xFF, 0xF2, 0xF9, 0xFE, 0xF7, 0xF5, 0xFA, 0xF0, 0xF8,
     0x13, 0x1D, 0x1B, 0x14, 0x11, 0x1C, 0x16, 0x1F, 0x12, 0x19, 0x1E, 0x17, 0x15, 0x1A, 0x10, 0x18,
     0xC3, 0xCD, 0xCB, 0xC4, 0xC1, 0xCC, 0xC6, 0xCF, 0xC2, 0xC9, 0xCE, 0xC7, 0xC5, 0xCA, 0xC0, 0xC8,
     0xB3, 0xBD, 0xBB, 0xB4, 0xB1, 0xBC, 0xB6, 0xBF, 0xB2, 0xB9, 0xBE, 0xB7, 0xB5, 0xBA, 0xB0, 0xB8,
     0xE3, 0xED, 0xEB, 0xE4, 0xE1, 0xEC, 0xE6, 0xEF, 0xE2, 0xE9, 0xEE, 0xE7, 0xE5, 0xEA, 0xE0, 0xE8,
     0x73, 0x7D, 0x7B, 0x74, 0x71, 0x7C, 0x76, 0x7F, 0x72, 0x79, 0x7E, 0x77, 0x75, 0x7A, 0x70, 0x78,
     0x83, 0x8D, 0x8B, 0x84, 0x81, 0x8C, 0x86, 0x8F, 0x82, 0x89, 0x8E, 0x87, 0x85, 0x8A, 0x80, 0x88,
     0x43, 0x4D, 0x4B, 0x44, 0x41, 0x4C, 0x46, 0x4F, 0x42, 0x49, 0x4E, 0x47, 0x45, 0x4A, 0x40, 0x48,
     0x53, 0x5D, 0x5B, 0x54, 0x51, 0x5C, 0x56, 0x5F, 0x52, 0x59, 0x5E, 0x57, 0x55, 0x5A, 0x50, 0x58,
     0x33, 0x3D, 0x3B, 0x34, 0x31, 0x3C, 0x36, 0x3F, 0x32, 0x39, 0x3E, 0x37, 0x35, 0x3A, 0x30, 0x38,
     0xD3, 0xDD, 0xDB, 0xD4, 0xD1, 0xDC, 0xD6, 0xDF, 0xD2, 0xD9, 0xDE, 0xD7, 0xD5, 0xDA, 0xD0, 0xD8,
     0x63, 0x6D, 0x6B, 0x64, 0x61, 0x6C, 0x66, 0x6F, 0x62, 0x69, 0x6E, 0x67, 0x65, 0x6A, 0x60, 0x68,
     0x93, 0x9D, 0x9B, 0x94, 0x91, 0x9C, 0x96, 0x9F, 0x92, 0x99, 0x9E, 0x97, 0x95, 0x9A, 0x90, 0x98,
     0x03, 0x0D, 0x0B, 0x04, 0x01, 0x0C, 0x06, 0x0F, 0x02, 0x09, 0x0E, 0x07, 0x05, 0x0A, 0x00, 0x08,
     0x23, 0x2D, 0x2B, 0x24, 0x21, 0x2C, 0x26, 0x2F, 0x22, 0x29, 0x2E, 0x27, 0x25, 0x2A, 0x20, 0x28,
     0xA3, 0xAD, 0xAB, 0xA4, 0xA1, 0xAC, 0xA6, 0xAF, 0xA2, 0xA9, 0xAE, 0xA7, 0xA5, 0xAA, 0xA0, 0xA8,
    },
    {
     0xD8, 0xDC, 0xD5, 0xD2, 0xDF, 0xD4, 0xDB, 0xD0, 0xD3, 0xDE, 0xD6, 0xD9, 0xDA, 0xDD, 0xD1, 0xD7,
     0x48, 0x4C, 0x45, 0x42, 0x4F, 0x44, 0x4B, 0x40, 0x43, 0x4E, 0x46, 0x49, 0x4A, 0x4D, 0x41, 0x47,
     0x38, 0x3C, 0x35, 0x32, 0x3F, 0x34, 0x3B, 0x30, 0x33, 0x3E, 0x36, 0x39, 0x3A, 0x3D, 0x31, 0x37,
     0x68, 0x6C, 0x65, 0x62, 0x6F, 0x64, 0x6B, 0x60, 0x63, 0x6E, 0x66, 0x69, 0x6A, 0x6D, 0x61, 0x67,
     0x98, 0x9C, 0x95, 0x92, 0x9F, 0x94, 0x9B, 0x90, 0x93, 0x9E, 0x96, 0x99, 0x9A, 0x9D, 0x91, 0x97,
     0x58, 0x5C, 0x55, 0x52, 0x5F, 0x54, 0x5B, 0x50, 0x53, 0x5E, 0x56, 0x59, 0x5A, 0x5D, 0x51, 0x57,
     0x08, 0x0C, 0x05, 0x02, 0x0F, 0x04, 0x0B, 0x00, 0x03, 0x0E, 0x06, 0x09, 0x0A, 0x0D, 0x01, 0x07,
     0xB8, 0xBC, 0xB5, 0xB2, 0xBF, 0xB4, 0xBB, 0xB0, 0xB3, 0xBE, 0xB6, 0xB9, 0xBA, 0xBD, 0xB1, 0xB7,
     0xC8, 0xCC, 0xC5, 0xC2, 0xCF, 0xC4, 0xCB, 0xC0, 0xC3, 0xCE, 0xC6, 0xC9, 0xCA, 0xCD, 0xC1, 0xC7,
     0x78, 0x7C, 0x75, 0x72, 0x7F, 0x74, 0x7B, 0x70, 0x73, 0x7E, 0x76, 0x79, 0x7A, 0x7D, 0x71, 0x77,
     0xA8, 0xAC, 0xA5, 0xA2, 0xAF, 0xA4, 0xAB, 0xA0, 0xA3, 0xAE, 0xA6, 0xA9, 0xAA, 0xAD, 0xA1, 0xA7,
     0xF8, 0xFC, 0xF5, 0xF2, 0xFF, 0xF4, 0xFB, 0xF0, 0xF3, 0xFE, 0xF6, 0xF9, 0xFA, 0xFD, 0xF1, 0xF7,
     0x28, 0x2C, 0x25, 0x22, 0x2F, 0x24, 0x2B, 0x20, 0x23, 0x2E, 0x26, 0x29, 0x2A, 0x2D, 0x21, 0x27,
     0x18, 0x1C, 0x15, 0x12, 0x1F, 0x14, 0x1B, 0x10, 0x13, 0x1E, 0x16, 0x19, 0x1A, 0x1D, 0x11, 0x17,
     0x88, 0x8C, 0x85, 0x82, 0x8F, 0x84, 0x8B, 0x80, 0x83, 0x8E, 0x86, 0x89, 0x8A, 0x8D, 0x81, 0x87,
     0xE8, 0xEC, 0xE5, 0xE2, 0xEF, 0xE4, 0xEB, 0xE0, 0xE3, 0xEE, 0xE6, 0xE9, 0xEA, 0xED, 0xE1, 0xE7,
    }
   }
  }
 };

/* ----------------------------------------------------------------------------------------------- */
/*! \brief  Структура для хранения внутренних данных в маскированной реализации Магмы. */
 struct magma_ctx {
  /*! \brief  две ключевые последовательности - прямая и инвертированная. */
  ak_uint32 inkey[2][8];
  /*! \brief  два маски для двух ключевых последовательностей, соответственно,
      прямой и инвертированной. */
  ak_uint32 inmask[2][8];
};

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция реализует один такт шифрующего преобразования ГОСТ 34.12-2015 (Mагма).

    @param x Обрабатываемая половина блока (более детально смотри описание сети Фейстеля).
    @return Результат криптографического преобразования.                                           */
/* ----------------------------------------------------------------------------------------------- */
 static inline ak_uint32 ak_magma_gostf_boxes( ak_uint32 x, const ak_uint8 i, const ak_uint8 j )
{
  x = magma_boxes[j][i][3][x>>24 & 255] << 24 | magma_boxes[j][i][2][x>>16 & 255] << 16 |
                           magma_boxes[j][i][1][x>> 8 & 255] <<  8 | magma_boxes[j][i][0][x & 255];
  return x<<11 | x>>(32-11);
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция зашифрования одного блока информации алгоритмом ГОСТ 34.12-2015 (Магма).

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (открытый текст).
    @param out Блок выходной информации (шифртекст).                                               */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_encrypt_with_random_walk( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_ctx *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_ctx *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[33] = 0;
  for( i = 0; i < 32; i++ ) m[i+1] = (ak_uint8)(( mv >> i) & 0x01 );

 /* начинаем движение */
  n3 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n4 = ((ak_uint32 *) in)[1];

  p = n3; p -= mp[m[ 1]][7]; p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes( p, m[ 2] ^ m[ 0], m[ 1] );
  p = n4; p -= mp[m[ 2]][6]; p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes( p, m[ 3] ^ m[ 1], m[ 2] );
  p = n3; p -= mp[m[ 3]][5]; p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes( p, m[ 4] ^ m[ 2], m[ 3] );
  p = n4; p -= mp[m[ 4]][4]; p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes( p, m[ 5] ^ m[ 3], m[ 4] );
  p = n3; p -= mp[m[ 5]][3]; p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes( p, m[ 6] ^ m[ 4], m[ 5] );
  p = n4; p -= mp[m[ 6]][2]; p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes( p, m[ 7] ^ m[ 5], m[ 6] );
  p = n3; p -= mp[m[ 7]][1]; p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes( p, m[ 8] ^ m[ 6], m[ 7] );
  p = n4; p -= mp[m[ 8]][0]; p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes( p, m[ 9] ^ m[ 7], m[ 8] );

  p = n3; p -= mp[m[ 9]][7]; p += kp[m[ 9]][7] + m[ 9]; n4 ^= ak_magma_gostf_boxes( p, m[10] ^ m[ 8], m[ 9] );
  p = n4; p -= mp[m[10]][6]; p += kp[m[10]][6] + m[10]; n3 ^= ak_magma_gostf_boxes( p, m[11] ^ m[ 9], m[10] );
  p = n3; p -= mp[m[11]][5]; p += kp[m[11]][5] + m[11]; n4 ^= ak_magma_gostf_boxes( p, m[12] ^ m[10], m[11] );
  p = n4; p -= mp[m[12]][4]; p += kp[m[12]][4] + m[12]; n3 ^= ak_magma_gostf_boxes( p, m[13] ^ m[11], m[12] );
  p = n3; p -= mp[m[13]][3]; p += kp[m[13]][3] + m[13]; n4 ^= ak_magma_gostf_boxes( p, m[14] ^ m[12], m[13] );
  p = n4; p -= mp[m[14]][2]; p += kp[m[14]][2] + m[14]; n3 ^= ak_magma_gostf_boxes( p, m[15] ^ m[13], m[14] );
  p = n3; p -= mp[m[15]][1]; p += kp[m[15]][1] + m[15]; n4 ^= ak_magma_gostf_boxes( p, m[16] ^ m[14], m[15] );
  p = n4; p -= mp[m[16]][0]; p += kp[m[16]][0] + m[16]; n3 ^= ak_magma_gostf_boxes( p, m[17] ^ m[15], m[16] );

  p = n3; p -= mp[m[17]][7]; p += kp[m[17]][7] + m[17]; n4 ^= ak_magma_gostf_boxes( p, m[18] ^ m[16], m[17] );
  p = n4; p -= mp[m[18]][6]; p += kp[m[18]][6] + m[18]; n3 ^= ak_magma_gostf_boxes( p, m[19] ^ m[17], m[18] );
  p = n3; p -= mp[m[19]][5]; p += kp[m[19]][5] + m[19]; n4 ^= ak_magma_gostf_boxes( p, m[20] ^ m[18], m[19] );
  p = n4; p -= mp[m[20]][4]; p += kp[m[20]][4] + m[20]; n3 ^= ak_magma_gostf_boxes( p, m[21] ^ m[19], m[20] );
  p = n3; p -= mp[m[21]][3]; p += kp[m[21]][3] + m[21]; n4 ^= ak_magma_gostf_boxes( p, m[22] ^ m[20], m[21] );
  p = n4; p -= mp[m[22]][2]; p += kp[m[22]][2] + m[22]; n3 ^= ak_magma_gostf_boxes( p, m[23] ^ m[21], m[22] );
  p = n3; p -= mp[m[23]][1]; p += kp[m[23]][1] + m[23]; n4 ^= ak_magma_gostf_boxes( p, m[24] ^ m[22], m[23] );
  p = n4; p -= mp[m[24]][0]; p += kp[m[24]][0] + m[24]; n3 ^= ak_magma_gostf_boxes( p, m[25] ^ m[23], m[24] );

  p = n3; p -= mp[m[25]][0]; p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes( p, m[26] ^ m[24], m[25] );
  p = n4; p -= mp[m[26]][1]; p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes( p, m[27] ^ m[25], m[26] );
  p = n3; p -= mp[m[27]][2]; p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes( p, m[28] ^ m[26], m[27] );
  p = n4; p -= mp[m[28]][3]; p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes( p, m[29] ^ m[27], m[28] );
  p = n3; p -= mp[m[29]][4]; p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes( p, m[30] ^ m[28], m[29] );
  p = n4; p -= mp[m[30]][5]; p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes( p, m[31] ^ m[29], m[30] );
  p = n3; p -= mp[m[31]][6]; p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes( p, m[32] ^ m[30], m[31] );
  p = n4; p -= mp[m[32]][7]; p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes( p, m[33] ^ m[31], m[32] );

  ((ak_uint32 *)out)[0] = n4^( m[32] * 0xffffffff ); ((ak_uint32 *)out)[1] = n3;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция расшифрования одного блока информации маскированного
    алгоритмом ГОСТ 34.12-2015 (Магма).

    @param skey Контекст секретного ключа.
    @param in Блок входной информации (шифртекст).
    @param out Блок выходной информации (открытый текст).                                          */
/* ----------------------------------------------------------------------------------------------- */
 static void ak_magma_decrypt_with_random_walk( ak_skey skey, ak_pointer in, ak_pointer out )
{
  ak_uint8 m[34];
  ak_uint32 i, mv = 0;
  ak_uint32 (*kp)[8] = ((struct magma_ctx *)skey->data)->inkey;
  ak_uint32 (*mp)[8] = ((struct magma_ctx *)skey->data)->inmask;
  register ak_uint32 n3, n4, p = 0;

 /* вырабатываем случайную траекторию */
  skey->generator.random( &skey->generator, &mv, sizeof( ak_uint32 ));

 /* формируем вектор раундовых поворотов */
  m[0] = m[33] = 0;
  for( i = 0; i < 32; i++ ) m[i+1] = (ak_uint8)((mv >> i) & 0x01 );

 /* начинаем движение */
  n3 = ((ak_uint32 *) in)[0]^( m[1] * 0xffffffff );
  n4 = ((ak_uint32 *) in)[1];

  p = (n3 - mp[m[ 1]][7]); p += kp[m[ 1]][7] + m[ 1]; n4 ^= ak_magma_gostf_boxes(p, m[ 2] ^ m[ 0], m[ 1] );
  p = (n4 - mp[m[ 2]][6]); p += kp[m[ 2]][6] + m[ 2]; n3 ^= ak_magma_gostf_boxes(p, m[ 3] ^ m[ 1], m[ 2] );
  p = (n3 - mp[m[ 3]][5]); p += kp[m[ 3]][5] + m[ 3]; n4 ^= ak_magma_gostf_boxes(p, m[ 4] ^ m[ 2], m[ 3] );
  p = (n4 - mp[m[ 4]][4]); p += kp[m[ 4]][4] + m[ 4]; n3 ^= ak_magma_gostf_boxes(p, m[ 5] ^ m[ 3], m[ 4] );
  p = (n3 - mp[m[ 5]][3]); p += kp[m[ 5]][3] + m[ 5]; n4 ^= ak_magma_gostf_boxes(p, m[ 6] ^ m[ 4], m[ 5] );
  p = (n4 - mp[m[ 6]][2]); p += kp[m[ 6]][2] + m[ 6]; n3 ^= ak_magma_gostf_boxes(p, m[ 7] ^ m[ 5], m[ 6] );
  p = (n3 - mp[m[ 7]][1]); p += kp[m[ 7]][1] + m[ 7]; n4 ^= ak_magma_gostf_boxes(p, m[ 8] ^ m[ 6], m[ 7] );
  p = (n4 - mp[m[ 8]][0]); p += kp[m[ 8]][0] + m[ 8]; n3 ^= ak_magma_gostf_boxes(p, m[ 9] ^ m[ 7], m[ 8] );

  p = (n3 - mp[m[ 9]][0]); p += kp[m[ 9]][0] + m[ 9]; n4 ^= ak_magma_gostf_boxes(p, m[10] ^ m[ 8], m[ 9] );
  p = (n4 - mp[m[10]][1]); p += kp[m[10]][1] + m[10]; n3 ^= ak_magma_gostf_boxes(p, m[11] ^ m[ 9], m[10] );
  p = (n3 - mp[m[11]][2]); p += kp[m[11]][2] + m[11]; n4 ^= ak_magma_gostf_boxes(p, m[12] ^ m[10], m[11] );
  p = (n4 - mp[m[12]][3]); p += kp[m[12]][3] + m[12]; n3 ^= ak_magma_gostf_boxes(p, m[13] ^ m[11], m[12] );
  p = (n3 - mp[m[13]][4]); p += kp[m[13]][4] + m[13]; n4 ^= ak_magma_gostf_boxes(p, m[14] ^ m[12], m[13] );
  p = (n4 - mp[m[14]][5]); p += kp[m[14]][5] + m[14]; n3 ^= ak_magma_gostf_boxes(p, m[15] ^ m[13], m[14] );
  p = (n3 - mp[m[15]][6]); p += kp[m[15]][6] + m[15]; n4 ^= ak_magma_gostf_boxes(p, m[16] ^ m[14], m[15] );
  p = (n4 - mp[m[16]][7]); p += kp[m[16]][7] + m[16]; n3 ^= ak_magma_gostf_boxes(p, m[17] ^ m[15], m[16] );

  p = (n3 - mp[m[17]][0]); p += kp[m[17]][0] + m[17]; n4 ^= ak_magma_gostf_boxes(p, m[18] ^ m[16], m[17] );
  p = (n4 - mp[m[18]][1]); p += kp[m[18]][1] + m[18]; n3 ^= ak_magma_gostf_boxes(p, m[19] ^ m[17], m[18] );
  p = (n3 - mp[m[19]][2]); p += kp[m[19]][2] + m[19]; n4 ^= ak_magma_gostf_boxes(p, m[20] ^ m[18], m[19] );
  p = (n4 - mp[m[20]][3]); p += kp[m[20]][3] + m[20]; n3 ^= ak_magma_gostf_boxes(p, m[21] ^ m[19], m[20] );
  p = (n3 - mp[m[21]][4]); p += kp[m[21]][4] + m[21]; n4 ^= ak_magma_gostf_boxes(p, m[22] ^ m[20], m[21] );
  p = (n4 - mp[m[22]][5]); p += kp[m[22]][5] + m[22]; n3 ^= ak_magma_gostf_boxes(p, m[23] ^ m[21], m[22] );
  p = (n3 - mp[m[23]][6]); p += kp[m[23]][6] + m[23]; n4 ^= ak_magma_gostf_boxes(p, m[24] ^ m[22], m[23] );
  p = (n4 - mp[m[24]][7]); p += kp[m[24]][7] + m[24]; n3 ^= ak_magma_gostf_boxes(p, m[25] ^ m[23], m[24] );

  p = (n3 - mp[m[25]][0]); p += kp[m[25]][0] + m[25]; n4 ^= ak_magma_gostf_boxes(p, m[26] ^ m[24], m[25] );
  p = (n4 - mp[m[26]][1]); p += kp[m[26]][1] + m[26]; n3 ^= ak_magma_gostf_boxes(p, m[27] ^ m[25], m[26] );
  p = (n3 - mp[m[27]][2]); p += kp[m[27]][2] + m[27]; n4 ^= ak_magma_gostf_boxes(p, m[28] ^ m[26], m[27] );
  p = (n4 - mp[m[28]][3]); p += kp[m[28]][3] + m[28]; n3 ^= ak_magma_gostf_boxes(p, m[29] ^ m[27], m[28] );
  p = (n3 - mp[m[29]][4]); p += kp[m[29]][4] + m[29]; n4 ^= ak_magma_gostf_boxes(p, m[30] ^ m[28], m[29] );
  p = (n4 - mp[m[30]][5]); p += kp[m[30]][5] + m[30]; n3 ^= ak_magma_gostf_boxes(p, m[31] ^ m[29], m[30] );
  p = (n3 - mp[m[31]][6]); p += kp[m[31]][6] + m[31]; n4 ^= ak_magma_gostf_boxes(p, m[32] ^ m[30], m[31] );
  p = (n4 - mp[m[32]][7]); p += kp[m[32]][7] + m[32]; n3 ^= ak_magma_gostf_boxes(p, m[33] ^ m[31], m[32] );

  ((ak_uint32 *)out)[0] = n4 ^ (m[32] * 0xffffffff); ((ak_uint32 *)out)[1] = n3;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция выработки инвертированного ключа и ключевых масок.

    @param skey Указатель на контекст секретного ключа

    @return В случае успеха функция возвращает \ref ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_magma_context_schedule_keys(ak_skey skey)
{
  int idx, error = ak_error_ok;
  struct magma_ctx *data = NULL;

  if( skey == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                            "using a null pointer to secret key" );
  if(( data = malloc( sizeof( struct magma_ctx ))) == NULL )
    return ak_error_message( ak_error_out_of_memory, __func__, "incorrect memory allocation" );

 /* выставляем флаги того, что память выделена */
  memset( data, 0, sizeof( struct magma_ctx ));
  skey->data = ( ak_pointer )data;
  skey->flags |= skey_flag_data_not_free;

 /* размещаем данные */
  if(( error = ak_random_context_random( &skey->generator, data->inmask[0], 32 )) != ak_error_ok )
    return ak_error_message( error, __func__, "incorrect generation first secret key mask" );
  if(( error = ak_random_context_random( &skey->generator, data->inmask[1], 32 )) != ak_error_ok )
    return ak_error_message( error, __func__, "incorrect generation second secret key mask" );

  for( idx = 0; idx < 8; idx++ ) {
     data->inkey[0][idx] = ((ak_uint32 *) skey->key.data )[idx];          /* скопировали */
     data->inkey[0][idx] += data->inmask[0][idx];                /* наложили новую маску */
     data->inkey[0][idx] -= ((ak_uint32 *) skey->mask.data )[idx]; /* сняли старую маску */
                                /* копирование с одновременным обращением (вычисляем ~k) */
     data->inkey[1][idx] = -data->inkey[0][idx];                 /* скопировали значение */
     data->inkey[1][idx] -= ( 1 - data->inmask[1][idx] );        /* наложили новую маску */
     data->inkey[1][idx] += data->inmask[0][idx];                  /* сняли старую маску */
  }

 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Функция уничтожения развернутых ключей для маскированной магмы

    В данной функции освобождается память выделенная под дополнительные s-боксы а хранящиеся маски
    и ключи заполняются случайнам мусором

    @param skey Указатель на контекст секретного ключа

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_magma_context_free_keys (ak_skey skey)
{
  if( skey == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                            "using a null pointer to secret key" );
  if( skey->data == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                      "unexpected null pointer to internal data" );

  ak_ptr_wipe( skey->data, sizeof( struct magma_ctx ), &skey->generator, ak_true );
  free( skey->data );

 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Наложение аддитивной в кольце \f$ \mathbb Z_{2^{32}}\f$ маски на ключ.

    Функция рассматривает вектор ключа как последовательность \f$ k_1, \ldots, k_n\f$, состоящую
    из элементов кольца  \f$ \mathbb Z_{2^{32}}\f$. Функция вырабатывает случайный вектор
    \f$ x_1, \ldots, x_n\f$ и заменяет ключевой вектор на последовательность значений
    \f$ k_1 + x_1 \pmod{2^{32}}, \ldots, k_n + x_n \pmod{2^{32}}\f$.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_context_set_mask_additive( ak_skey skey )
{
  size_t j, idx = 0;
  ak_uint32 newmask[8];
  int error = ak_error_ok;
  struct magma_ctx *data = NULL;

  if( skey == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                            "using a null pointer to secret key" );
  /* выполняем стандартные проверки длин и указателей */
  if(( error = ak_skey_context_check( skey )) != ak_error_ok )
    return ak_error_message( error, __func__ , "using invalid secret key" );

 /* проверяем длину ключа */
  if( skey->key.size != 32 ) return ak_error_message( ak_error_undefined_value, __func__ ,
                                                          "using a key buffer with wrong length" );
 /* проверяем, установлена ли маска ранее */
  if( (( skey->flags)&skey_flag_set_mask ) == 0 ) {
    /* создаем маску*/
     if(( error = ak_random_context_random( &skey->generator,
                                           skey->mask.data, skey->mask.size )) != ak_error_ok )
       return ak_error_message( error, __func__ , "wrong random mask generation for key buffer" );
    /* накладываем маску на ключ */
     for( idx = 0; idx < (skey->key.size >> 2); idx++ )
        ((ak_uint32 *) skey->key.data)[idx] += ((ak_uint32 *) skey->mask.data)[idx];
    /* меняем значение флага */
     skey->flags |= skey_flag_set_mask;

  } else { /* если маска уже установлена, то мы ее сменяем */
           /* для очень длинных ключей маска не изменяется */
            if( skey->mask.size > sizeof( newmask ))
              return ak_error_message( ak_error_wrong_length, __func__ ,
                                                     "unsupported length for secret key buffer" );
            if(( error = ak_random_context_random( &skey->generator,
                                                     newmask, skey->mask.size )) != ak_error_ok )
              return ak_error_message( error, __func__ ,
                                                  "wrong random mask generation for key buffer" );
           /* меняем маску для вектора, хранящегося в структуре skey */
            for( idx = 0; idx < ( skey->key.size >> 2 ); idx++ ) {
               ((ak_uint32 *) skey->key.data)[idx] += newmask[idx];
               ((ak_uint32 *) skey->key.data)[idx] -= ((ak_uint32 *) skey->mask.data)[idx];
               ((ak_uint32 *) skey->mask.data)[idx] = newmask[idx];
            }
          /* меняем маску для внутреннего представления ключевой информации */
            if(( data = ( struct magma_ctx *)skey->data ) == NULL ) return error;
            for( j = 0; j < 2; j++ ) {
              if(( error = ak_random_context_random( &skey->generator,
                                                     newmask, skey->mask.size )) != ak_error_ok )
                return ak_error_message( error, __func__ ,
                                                  "wrong random mask generation for key buffer" );
              for( idx = 0; idx < ( skey->key.size >> 2 ); idx++ ) {
                 data->inkey[j][idx] += newmask[idx];
                 data->inkey[j][idx] -= data->inmask[j][idx];
                 data->inmask[j][idx] = newmask[idx];
              }
            }
    }

 return error;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Снятие аддитивной в кольце \f$ \mathbb Z_{2^{32}}\f$ маски на ключ.

    Функция снимает наложенную ранее маску и оставляет значение ключа в его истинном виде.
    В буффер `mask` помещается нулевое значение.
    @param skey Указатель на контекст секретного ключа.
    @return В случае успеха функция возвращает \ref ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_context_unmask_additive( ak_skey skey )
{
  size_t idx = 0;
  int error = ak_error_ok;

 /* выполняем стандартные проверки */
  if(( error = ak_skey_context_check( skey )) != ak_error_ok )
    return ak_error_message( error, __func__ , "using invalid secret key" );

 /* проверяем, установлена ли маска ранее */
  if( (( skey->flags)&skey_flag_set_mask ) == 0 ) return ak_error_ok;

 /* снимаем маску с ключа */
  for( idx = 0; idx < ( skey->key.size >> 2 ); idx++ ) {
     ((ak_uint32 *) skey->key.data)[idx] -= ((ak_uint8 *) skey->mask.data)[idx];
     ((ak_uint32 *) skey->mask.data)[idx] = 0;
  }
 /* меняем значение флага */
  skey->flags ^= skey_flag_set_mask;

 return error;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Нелинейная перестановка в кольце \f$ \mathbb Z_{2^{64}} \f$

    Функция реализует преобразование, которое можно рассматривать как нелинейную
    перестановку \f$ \pi \f$ элементов кольца \f$ \mathbb Z_{2^{64}} \f$, задаваемое следующим образом.

    Пусть \f$ \overline x \f$ есть побитовое инвертирование переменной x,
    a \f$ f(x,y)\in\mathbb Z[x]\f$ многочлен,
    определяемый равенством \f$ f(x,y) = \frac{1}{2}\left( (x+y)^2 + x + 3y \right)\f$. Тогда
    перестановка \f$ \pi \f$ определяется равенством
    \f$ \pi(x,y) = const \oplus
                    \left\{ \begin{array}{ll}
                              f(x,y), & x+y < 2^{32}, \\
                              \overline{f(\overline{x},\overline{y})}, & 2^{32} \le x+y < 2^{64}.
                            \end{array}
                    \right.\f$

    @param xv Величина \f$ x \in \mathbb Z_{2^{32}} \f$
    @param yv Величина \f$ y \in \mathbb Z_{2^{32}} \f$
    @return Значение перестановки \f$ \pi \f$                                                      */
/* ----------------------------------------------------------------------------------------------- */
 static ak_uint64 ak_skey_context_icode_permutation( const ak_uint32 xv, const ak_uint32 yv )
{
  ak_uint32 x = xv, y = yv, carry = 0;
  ak_uint64 s =  ( ak_uint64 )x + y, more = s&0x100000000, result = 0;

  if( more ) { x = ~x; y = ~y; s = ( ak_uint64 )x + y; }
  result = y; result *= 3; result += x;
  s *= s; result += s; if( result < s ) carry = 1;

  result >>= 1;
  if( carry ) result ^= 0x8000000000000000L;
  if( more ) result = ~result;
 return result^0xC5BF891B4EF6AA79L; // константа есть \sqrt{\pi}
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Реализация алгоритма вычисления контрольной суммы для аддитивной маски ключа */
 static void ak_skey_context_icode_additive_sum( ak_skey skey, ak_uint64 *result )
{
  size_t i = 0;
  for( i = 0; i < (skey->key.size >> 2); i+=4 ) {
     ak_uint32 x = ((ak_uint32 *) skey->key.data)[i],
               y = ((ak_uint32 *) skey->key.data)[i+2];
     x += ((ak_uint32 *) skey->key.data)[i+1];
     y += ((ak_uint32 *) skey->key.data)[i+3];
     x -= ((ak_uint32 *) skey->mask.data)[i];
     x -= ((ak_uint32 *) skey->mask.data)[i+1];
     y -= ((ak_uint32 *) skey->mask.data)[i+2];
     y -= ((ak_uint32 *) skey->mask.data)[i+3];
     *result += ak_skey_context_icode_permutation( x, y );
  }
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Вычисление значения контрольной суммы ключа.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае успеха функция возвращает ak_error_ok. В противном случае,
    возвращается код ошибки.                                                                       */
/* ----------------------------------------------------------------------------------------------- */
 static int ak_skey_context_set_icode_additive( ak_skey skey )
{
  ak_uint64 result = 0;
  int error = ak_error_ok;

 /* выполняем стандартные проверки */
  if(( error = ak_skey_context_check( skey )) != ak_error_ok )
    return ak_error_message( error, __func__ , "using invalid secret key" );

 /* проверяем длину ключа */
  if( skey->key.size != 32 ) return ak_error_message( ak_error_wrong_length, __func__ ,
                                                          "using a key buffer with wrong length" );
  if( skey->icode.data == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                                   "using undefined mask buffer" );
  if( skey->icode.size != 8 ) return ak_error_message( ak_error_wrong_length, __func__ ,
                                                 "using integrity code buffer with wrong length" );

 /* теперь, собственно вычисление контрольной суммы */
  ak_skey_context_icode_additive_sum( skey, &result );
  memcpy( skey->icode.data, &result, 8 );

 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \brief Проверка значения контрольной суммы ключа.

    @param skey Указатель на контекст секретного ключа. Длина ключа (в байтах)
    должна быть в точности равна 32.

    @return В случае совпадения контрольной суммы ключа функция возвращает истину (\ref ak_true).
    В противном случае, возвращается ложь (\ref ak_false).                                         */
/* ----------------------------------------------------------------------------------------------- */
 static ak_bool ak_skey_context_check_icode_additive( ak_skey skey )
{
  ak_uint64 result = 0;
  int error = ak_error_ok;

 /* выполняем стандартные проверки */
  if(( error = ak_skey_context_check( skey )) != ak_error_ok )
    return ak_error_message( error, __func__ , "using invalid secret key" );

 /* проверяем наличие и длину ключа */
  if( skey->key.size != 32 ) return ak_error_message( ak_error_wrong_length, __func__ ,
                                                           "using a key buffer with wrong length" );
  if( skey->icode.data == NULL ) return ak_error_message( ak_error_null_pointer, __func__ ,
                                                                    "using undefined mask buffer" );
  if( skey->icode.size != 8 ) return ak_error_message( ak_error_wrong_length, __func__ ,
                                                  "using integrity code buffer with wrong length" );

 /* теперь, собственно вычисление контрольной суммы */
  ak_skey_context_icode_additive_sum( skey, &result );
 /* и сравнение */
  if( memcmp( skey->icode.data, &result, 8 )) return ak_false;
   else return ak_true;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Функция инициализируете контекст ключа алгоритма блочного шифрования Магма (ГОСТ Р 34.12-2015).
    После инициализации устанавливаются обработчики (функции класса). Однако само значение
    ключу не присваивается - поле `bkey->key` остается неопределенным.

    @param bkey Контекст секретного ключа алгоритма блочного шифрования.

    @return Функция возвращает код ошибки. В случаее успеха возвращается \ref ak_error_ok.         */
/* ----------------------------------------------------------------------------------------------- */
int ak_bckey_context_create_magma( ak_bckey bkey )
{
  int error = ak_error_ok;
  if( bkey == NULL ) return ak_error_message( ak_error_null_pointer, __func__,
                                               "using null pointer to block cipher key context" );

 /* создаем ключ алгоритма шифрования и определяем его методы */
  if(( error = ak_bckey_context_create( bkey, 32, 8 )) != ak_error_ok )
    return ak_error_message( error, __func__, "wrong initalization of block cipher key context" );

 /* устанавливаем OID алгоритма шифрования */
  if(( bkey->key.oid = ak_oid_context_find_by_name( "magma" )) == NULL ) {
    error = ak_error_get_value();
    ak_error_message( error, __func__, "wrong search of predefined magma block cipher OID" );
    ak_bckey_context_destroy( bkey );
    return error;
  };

 /* устанавливаем ресурс использования серетного ключа */
  bkey->key.resource.counter = ak_libakrypt_get_option( "magma_cipher_resource" );

 /* устанавливаем методы */
  bkey->key.set_mask = ak_skey_context_set_mask_additive;
  bkey->key.unmask = ak_skey_context_unmask_additive;
  bkey->key.set_icode = ak_skey_context_set_icode_additive;
  bkey->key.check_icode = ak_skey_context_check_icode_additive;

  bkey->schedule_keys = ak_magma_context_schedule_keys;
  bkey->delete_keys = ak_magma_context_free_keys;
  bkey->encrypt = ak_magma_encrypt_with_random_walk;
  bkey->decrypt = ak_magma_decrypt_with_random_walk;

  return error;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Тестирование производится в соответствии с примерами из ГОСТ Р 34.12-2015 и ГОСТ Р 34.13-2015. */
/* ----------------------------------------------------------------------------------------------- */
 ak_bool ak_bckey_test_magma( void )
{
  char *str = NULL;
  ak_uint8 out[32];
  struct bckey bkey; /* контекст используемого для тестов ключа */
  int error = ak_error_ok, audit = ak_log_get_level();
  ak_bool result = ak_true;

  ak_uint8 gost3412_2015_key[32] = { /* тестовый ключ из ГОСТ Р 34.12-2015, приложение А.2 */
     0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0,
     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
  };

 /* подлежащий зашифрованию открытый текст из ГОСТ Р 34.12-2015, приложение А.2 */
  ak_uint8 a[8] = { 0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe };
 /* зашифрованный текст из ГОСТ Р 34.12-2015 */
  ak_uint8 b[8] = { 0x3d, 0xca, 0xd8, 0xc2, 0xe5, 0x01, 0xe9, 0x4e };

 /* открытый текст из ГОСТ Р 34.13-2015, приложение А.2 */
  ak_uint64 in_3413_2015_text[4] = {
                  0x92def06b3c130a59, 0xdb54c704f8189d20, 0x4a98fb2e67a8024c, 0x8912409b17b57e41 };
 /* зашифрованный в режиме простой замены текст из ГОСТ Р 34.13-2015, приложение А.2 */
  ak_uint64 out_3413_2015_ecb_text[4] = {
                  0x2b073f0494f372a0, 0xde70e715d3556e48, 0x11d8d9e9eacfbc1e, 0x7c68260996c67efb };

 /* синхропосылка и зашифрованный в режиме гаммирования текст из ГОСТ Р 34.13-2015, приложение А.2 */
  ak_uint8 ctr_iv[4] = { 0x78, 0x56, 0x34, 0x12 },
             xiv1[4] = { 0x61, 0x2D, 0x93, 0x42 };
  ak_uint8 xin1[13] = {
    0x31, 0xEA, 0x54, 0xBB, 0xB7, 0xE5, 0xE5, 0x1C, 0xAE, 0xEB, 0x79, 0x28, 0x71 };
  ak_uint8 xout1[13] = {
    0x7C, 0xC9, 0x83, 0x3D, 0x5D, 0x1B, 0x9E, 0x81, 0x07, 0x94, 0x9F, 0x58, 0x15 };

  ak_uint64 out_3413_2015_ctr_text[4] = {
                  0x4e98110c97b7b93c, 0x3e250d93d6e85d69, 0x136d868807b2dbef, 0x568eb680ab52a12d };

 /* 1. Инициализируем ключ алгоритма Магма */
  if(( error = ak_bckey_context_create_magma( &bkey )) != ak_error_ok ) {
    ak_error_message( error, __func__, "wrong initialization of magma secret key" );
    return ak_false;
  }

 /* 2. Присваиваем ключу константное значение */
  if( ak_bckey_context_set_key( &bkey, gost3412_2015_key, 32, ak_false ) != ak_error_ok ) {
    ak_error_message( error, __func__, "wrong assigning a predefined value to magma secret key " );
    return ak_false;
  }

 /* 3. Тестируем зашифрование/расшифрование одного блока согласно ГОСТ Р34.12-2015 */
  bkey.encrypt( &bkey.key, a, out );
  if( !ak_ptr_is_equal( out, b, 8 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                  "the one block encryption test from GOST R 34.12-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 8, ak_true )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( b, 8, ak_true )); free( str );
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                    "the one block encryption test from GOST R 34.12-2015 is Ok" );
  bkey.decrypt( &bkey.key, b, out );
  if( !ak_ptr_is_equal( out, a, 8 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                  "the one block decryption test from GOST R 34.12-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 8, ak_true )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( a, 8, ak_true )); free( str );
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                    "the one block decryption test from GOST R 34.12-2015 is Ok" );

 /* 4. Тестируем режим простой замены согласно ГОСТ Р34.13-2015 */
  if(( error = ak_bckey_context_encrypt_ecb( &bkey, in_3413_2015_text, out, 32 )) != ak_error_ok )
  {
    ak_error_message_fmt( error, __func__ , "wrong plain text encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, out_3413_2015_ecb_text, 32 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                   "the ecb mode encryption test from GOST R 34.13-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 32, ak_true )); free(str);
    ak_log_set_message( str = ak_ptr_to_hexstr( out_3413_2015_ecb_text, 32, ak_true )); free(str);
    result = ak_false;
    goto exit;
  }
  if(( error = ak_bckey_context_decrypt_ecb( &bkey, out_3413_2015_ecb_text, out, 32 )) != ak_error_ok )
  {
    ak_error_message_fmt( error, __func__ , "wrong cipher text decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, in_3413_2015_text, 32 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                   "the ecb mode decryption test from GOST R 34.13-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 32, ak_true )); free(str);
    ak_log_set_message( str = ak_ptr_to_hexstr( in_3413_2015_text, 32, ak_true )); free(str);
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                          "the ecb mode encryption/decryption test from GOST R 34.13-2015 is Ok" );

 /* 5. Тестируем режим гаммирования (счетчика) согласно ГОСТ Р34.13-2015 */
  if( ak_bckey_context_xcrypt( &bkey, in_3413_2015_text, out, 32, ctr_iv, sizeof( ctr_iv )) != ak_error_ok ) {
    ak_error_message_fmt( ak_error_get_value(), __func__ , "wrong plain text encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, out_3413_2015_ctr_text, 32 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                   "the counter mode encryption test from GOST R 34.13-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 32, ak_true )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( out_3413_2015_ctr_text, 32, ak_true )); free(str);
    result = ak_false;
    goto exit;
  }
  if( ak_bckey_context_xcrypt( &bkey, out_3413_2015_ctr_text, out, 32, ctr_iv, sizeof( ctr_iv )) != ak_error_ok ) {
    ak_error_message_fmt( ak_error_get_value(), __func__ , "wrong cipher text decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, in_3413_2015_text, 32 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                   "the counter mode decryption test from GOST R 34.13-2015 is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 32, ak_true )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( in_3413_2015_text, 32, ak_true )); free( str );
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                          "the counter mode encryption/decryption test from GOST R 34.13-2015 is Ok" );

 /* 6. Тестируем режим гаммирования (счетчика) на длинах, не кратных длине блока. */
  if( ak_bckey_context_xcrypt( &bkey, xin1, out, 13, xiv1, 4 ) != ak_error_ok ) {
    ak_error_message_fmt( ak_error_get_value(), __func__ , "wrong plain text encryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, xout1, 13 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                            "the counter mode encryption test for 13 octets is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 13, ak_false )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( xout1, 13, ak_false )); free(str);
    result = ak_false;
    goto exit;
  }
  if( ak_bckey_context_xcrypt( &bkey, xout1, out, 13, xiv1, 4 ) != ak_error_ok ) {
    ak_error_message_fmt( ak_error_get_value(), __func__ , "wrong cipher text decryption" );
    result = ak_false;
    goto exit;
  }
  if( !ak_ptr_is_equal( out, xin1, 13 )) {
    ak_error_message_fmt( ak_error_not_equal_data, __func__ ,
                                            "the counter mode decryption test for 13 octets is wrong");
    ak_log_set_message( str = ak_ptr_to_hexstr( out, 13, ak_true )); free( str );
    ak_log_set_message( str = ak_ptr_to_hexstr( xin1, 13, ak_true )); free( str );
    result = ak_false;
    goto exit;
  }
  if( audit >= ak_log_maximum ) ak_error_message( ak_error_ok, __func__ ,
                                  "the counter mode encryption/decryption test for 13 octets is Ok" );

 /* освобождаем ключ и выходим */
  exit:
  if(( error = ak_bckey_context_destroy( &bkey )) != ak_error_ok ) {
    ak_error_message( error, __func__, "wrong destroying of magma secret key" );
    return ak_false;
  }

 return result;
}

/* ----------------------------------------------------------------------------------------------- */
/*                                                                                     ak_magma.c  */
/* ----------------------------------------------------------------------------------------------- */
