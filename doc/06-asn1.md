Форматы хранения контента с использованием ASN.1 нотации
--------------------------------------------------------

Для локального хранения данных и, при необходимости, передачи данных по каналам связи
в библиотеке поддерживается единый формат хранения контента, основанный на применении ASN.1 нотации для кодирования
данных. Используемый в библиотеке `libakrypt` формат основан на ГОСТ Р ИСО/МЭК 8824-1-2001,
ITU X.509, RFC 5280, отечественнных рекомендациях по стандартизации:

 - Р 50.1.111-2016 "Парольная защита ключевой информации",
 - Р 1323565.1.023-2018 "Использование алгоритмов ГОСТ Р 34.10-2012, ГОСТ Р 34.11-2012 в сертификате,
   списке аннулированных сертификатов (CRL) и запросе на сертификат PKCS #10 инфраструктуры открытых ключей X.509",

а также содержит ряд описываемых далее оригинальных форматов хранения ключевой информации.


Поддерживаемые типы контента и криптографические механизмы его защиты
=====================================================================


<--- тип -> формат-> кодировка --->

Имеем тип        - ключ симметричный, секретный, открытый, данные
      состояние  - зашифрованные, имитозащищенные, подписанные 
      формат     - помещаемые, помещаемые во внешнем формате, ссылка на внешний файл, отсутствуют
       в контейер/внешний формат
      кодировка 

Библиотека допускает хранение в контейнере данных следующих типов
(определяются перечислением \ref crypto_content_t)

 - \ref symmetric_key_content (cекретный ключ симметричного криптографического алгоритма),
 - \ref secret_key_content (секретный ключ асимметричного криптографического алгоритма),
 - \ref public_key_certificate_content (открытый ключ асимметричного алгоритма, представленный в формате сертификата открытого ключа),
 - \ref public_key_request_content (открытый ключ асимметричного алгоритма, представленный в формате запроса на сертификат),
 - \ref encrypted_content (зашифрованные данные) 	
 - \ref plain_content (незашифрованые данные)

 


Формат общего контейнера для хранения данных
============================================


Форматы хранения открытых ключей
================================


### Тип CertificationRequest

### Тип Certificate


    Certificate  ::=  SEQUENCE  {
         tbsCertificate       TBSCertificate,
         signatureAlgorithm   AlgorithmIdentifier,
         signature            BIT STRING  }


### Используемые расширения сертификата открытого ключа

Расширения добавляются в сертификат открытого ключа начиная с третьей версии стандарта x509.
Общая структура расширения имеет следующий вид.

    Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension

    Extension  ::=  SEQUENCE  {
       extnID      OBJECT IDENTIFIER,
       critical    BOOLEAN DEFAULT FALSE,
       extnValue   OCTET STRING
                   -- contains the DER encoding of an ASN.1 value
                   -- corresponding to the extension type identified
                   -- by extnID
    }

Поле `extnID` определяет идентификатор расширения по которому оно может
быть опознано и декодировано.

Полк `critical` определяет, является ли оно критическим или нет.
Не критические расширения могут не обрабатываться при декодировании сертификата.

Поле `extnValue` содержит значение расширения,
закодированное в виде der-строки. Далее мы опишем типы сообщений,
поддерживаемых библиотекой `libakrypt`.


#### Расширение `SubjectKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-subjectKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.14 }

    SubjectKeyIdentifier ::= OCTET STRING


Расширение `SubjectKeyIdentifier`
представляет механизм идентификации сертификата, содержащего данный открытый ключ.

Стандарт RFC 5280 рекомендует брать
в качестве `SubjectKeyIdentifier` значение функции хеширования от поля `SubjectPublicKey'
(см. выше `tbsCertificate`), содержащего значение открытого ключа.


В библиотеке `libakrypt` в качестве данного идентификатора выступает номер
открытого ключа, формируемый при его создании, т.е.

    ak_verifykey public_key;
    public_key->number;  /* это SubjectKeyIdentifier */


Чтобы облегчить построение пути сертификации, расширение `SubjectKeyIdentifier` ДОЛЖНО
появляться во всех соответствующих сертификатах центра сертификации,
то есть во всех сертификатах, включая содержащие расширение `BasicConstraints`
со значением `cA` равным истине.

Ценр сертификации ДОЛЖЕН помечать это расширение как некритическое.
Вместе с тем, во всех доступных реализациях метка некритичности не
ставится, и расширение состоит только из OID и OCTET STRING.


#### Расширение `AuthorityKeyIdentifier`

Расширение определено в RFC 5280 следующим образом.


    id-ce-authorityKeyIdentifier OBJECT IDENTIFIER ::=  { 2.5.29.35 }

    AuthorityKeyIdentifier ::= SEQUENCE {
      keyIdentifier             [0] KeyIdentifier           OPTIONAL,
      authorityCertIssuer       [1] GeneralNames            OPTIONAL,
      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }

    KeyIdentifier ::= OCTET STRING

Расширение `AuthorityKeyIdentifier` обеспечивает средство
идентификации открытого ключа, соответствующего закрытому ключу,
использованному для подписи сертификата.
Другими словами,  расширение `AuthorityKeyIdentifier` позволяет идентифицировать открытый ключ,
с помощью которого можно проверить корректность электронной подписи под данным сертификатом.
Идентификация может быть основана на

 - идентификаторе ключа субъекта (`KeyIdentifier`),
   (это значение содержится в расширении `SubjectKeyIdentifier`
    сертификата верхнего уровня)

 - названии или обобщенном имени эмитента (`authorityCertIssuer`),

 - серийном номере сертификата (`authorityCertSerialNumber`) открытого ключа,
   который должен использоваться для проверки электронной подписи.
   (используется значение `SerialNumber` из `TBSCertificate` сертификата верхнего уровня)

Поле `keyIdentifier` расширения `authorithyKeyIdentifier` ДОЛЖНО
быть включено во все сертификаты, генерируемые соответствующими центрами сертификации,
чтобы облегчить путь поиска цепочки соотвествия.
Для самоподписанного сертификата может быть сделано исключение и
идентификатор ключа авторизации МОЖЕТ быть опущен (поскольку сертификат уже содержит
ключ, с помощью которого можно проверить электронную подпись).

Центр сертификации ДОЛЖЕН помечать это расширение как некритическое.

Пример декодирования расширения `AuthorityKeyIdentifier` выглядит следующим образом.


    └SEQUENCE┐
             ├[0] 5a7bfec75e2dfbc6e4972ebb1c098018c8f2d720
             ├[1]┐
             │   └[4]┐
             │       └SEQUENCE┐
             │                └SET┐
             │                    └SEQUENCE┐
             │                             ├OBJECT IDENTIFIER 2.5.4.3 (CommonName)
             │                             └UTF8 STRING Example
             └[2] 00ce4ccdd344d62dec


#### Расширение `KeyUsage`

Расширение `KeyUsage`, согласно рекомендациям Р 1323565.1.023-2018,
является опциональным полем (расширением) структуры TBSCertificate.
Для ключей, соответствующих алгоритму подписи ГОСТ Р 34.10-2012, данное расширение может
иметь следующие флаги:


    KeyUsage ::= BIT STRING {
       digitalSignature  (0),
       contentCommitment (1),
       keyEncipherment   (2),
       dataEncipherment  (3),
       keyAgreement      (4),
       keyCertSign       (5),
       cRLSign           (6),
       encipherOnly      (7),
       decipherOnly      (8)
    }


\note Отметим, что флаги `keyEncipherment` (2) и `dataEncipherment` (3) из
Р 1323565.1.023-2018 исключены.

Расширение `KeyUsage` определяет цель (например, шифрование, подпись, подпись сертификата)
использования ключа, содержащегося в сертификате.
Центр сертификации ДОЛЖЕН включать это расширение в сертификаты, которые
содержат открытые ключи, используемые для проверки цифровых подписей под другими сертификатами
или списками отозванных сертификатов.

Биты в типе `KeyUsage` используются следующим образом:

 - Бит `digitalSignature` устанавливается, когда открытый ключ субъекта
 используется для проверки цифровых подписей, кроме проверки подписей под сертификатами
 (установлен бит 5) и списками отозванных сертификатов CRL (установлен бит 6).
 Примером такого использования может служить подпись данных, использование
 в службах аутентификации объектов, источников данных и/или сервисах целостности.
 Для сертификатов, используемых при аутентификации участников протоколов выработки общего ключа,
 данный бит не устанавливается.


 - Бит `contentCommitment` устанавливается, когда открытый ключ субъекта
 используется для проверки цифровых подписей, кроме проверки подписей под сертификатами
 (установлен бит 5) и списками отозванных сертификатов CRL (установлен бит 6),
 используемых для предоставления службой аннулирования сертификатов.


 - Бит `keyEncipherment` устанавливается, когда открытый ключ субъекта
 используется для шифрования закрытых или секретных ключей, т. е.
 выступает в роли транспортного ключа.
 В библиотеке `libakrypt` данные сертификаты используются для
 открытых ключей, используемых в гибридной схеме шифрования.


 - Бит `dataEncipherment` устанавливается, когда субъектный открытый ключ
 используется для непосредственного шифрования необработанных пользовательских данных без использования
 промежуточного симметричного шифра.
 В библиотеке `libakrypt` сертификаты с даным установленным битом не используются.


 - Бит `keyAgreement` устанавливается, когда открытый ключ субъекта
 используется для аутентификации сторон в протоколах выработки общего ключа.
 Обязательное наличие этого бита предполагается Р 1323565.1.023-2018.


 - Бит `keyCertSign` устанавливается, когда открытый ключ субъекта
 используется для проверки подписей под сертификатами открытых ключей.
 Для корневого сертификата данный бит ДОЛЖЕН быть установлен.


 - Бит `cRLSign` устанавливается при использовании открытого ключа
 для проверки подписей в списках отозванных сертификатов.


 - Значение бита `encipherOnly` не определено при
 не установленном бите `keyAgreement`. Когда оба бита установлены открытый ключ
 может быть использован для шифрования данных при выполнении протокола выработки общих ключей.


 - Значение бита `decipherOnly` не определено при
 не установленном бите `ketAgreement`. Когда оба бита установлены открытый ключ
 может быть использован для расшифрования данных при выполнении протокола выработки общих ключей.


Флаги `encipherOnly` и `decipherOnly` могут присутствовать опционально.
При этом флаги `encipherOnly` и `decipherOnly` не могут присутствовать в расширении `KeyUsage` одновременно.

Пример декодирования расширения `keyUsage`
может выглядеть слеующим образом


    └SEQUENCE┐
             ├OBJECT IDENTIFIER 2.5.29.15 (Key Usage)
             └OCTET STRING
                03 02 00 84
                ├ encoded (4 octets)
                └BIT STRING
                   84


#### Расширение `Basic Constraints`

Расширение определено в RFC 5280 следующим образом.

    id-ce-basicConstraints OBJECT IDENTIFIER ::=  { 2.5.29.19 }

    BasicConstraints ::= SEQUENCE {
        cA                      BOOLEAN DEFAULT FALSE,
        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }


Расширение `Basic Constraints` определяет, является ли данный сертификат самоподписанным,
а также определяет максимальную глубину цепочки сертификации, которая может порождаться
данным сертификатом.

Булева переменная `cA` указывает, можно ли с помощью данного сертификата порождать
цепочки сертификации.

Значение `false` означает, что данный самоподписанный
сертификат открытого ключа не должен использоваться для проверки подписи.
Также, если значение `cA` ложно (`false`), то в расширении `KeyUsage`, если такое присутствует,
не должен бит устанавливаться бит `keyCertSign`.

Поле pathLenConstraint имеет смысл, только если логическое значение cA истинно.
В этом случае поле задает максимальное возможное количество сертификатов  (длину цепочки),
между самоподписанным сертификатом и последним элементом цепочки.
Поле pathLenConstraint, равное нулю, указывает, что
промежуточных сертификатов нет и цепочка
содержит только один сертификат низлежащего уровня.
Если поле не определено, то ограничений нет.

Центр сертификации ДОЛЖЕН включать это расширение во все самоподписанные сертификаты
и ДОЛЖЕН пометить расширение как критическое.
Это расширение МОЖЕТ появиться как критическое или не
критическое расширение в сертификатах центра сертификации,
которые содержат открытые ключи исключительно для целей, отличных от проверки цифровых подписей
под сертификатами.

Пример декодирования расширения `Basic Constraints` может выглядеть следующим образом.


    ├OBJECT IDENTIFIER 2.5.29.19 (Basic Constraints)
    ├BOOLEAN TRUE
    └OCTET STRING
       30 03 01 01 FF
        ├ encoded (5 octets)
        └SEQUENCE┐
                 └BOOLEAN TRUE


#### Расширение ` ... Policies`

